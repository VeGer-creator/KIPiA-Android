================================================================================
--- АНДРОИД ПРОЕКТ ПАРСЕР ---
================================================================================
Путь к проекту: E:\AndroidStudioProjects\KIPiA_1.0
Тип проекта: android
Только структура: False
Выбор файлов: Включен
Количество выбранных файлов: 110
Время запуска парсера: 0.0

================================================================================
--- СТРУКТУРА ПРОЕКТА (только важные файлы) ---
================================================================================
KIPiA_1.0/
  .gitignore
  build.gradle.kts
  gradle.properties
  gradlew
  gradlew.bat
  KIPiA_1.0_parsed_android_full_all_output.txt
  KIPiA_1.0_parsed_android_full_selected_output.txt
  KIPiA_1.0_parsed_android_structure_all_output.txt
  local.properties
  settings.gradle.kts
  .kotlin/
    errors/
      errors-1763041483556.log
      errors-1763041783863.log
      errors-1763072804995.log
      errors-1763725841172.log
    sessions/
  app/
    .gitignore
    build.gradle.kts
    proguard-rules.pro
    debug/
      output-metadata.json
    src/
      androidTest/
        java/
          com/
            example/
              kipia/
                ExampleInstrumentedTest.kt
      main/
        AndroidManifest.xml
        ic_launcher-playstore.png
        java/
          com/
            example/
              kipia/
                MainActivity.kt
                SplashActivity.kt
                data/
                  PreferencesManager.kt
                database/
                  AppDatabase.kt
                  ControlPointDao.kt
                  ControlPointEntity.kt
                  DetailedEquipmentDao.kt
                  DetailedEquipmentEntity.kt
                  EquipmentDao.kt
                  EquipmentEntity.kt
                  EventDao.kt
                  EventEntity.kt
                  NodeDao.kt
                  NodeEntity.kt
                  PKUDao.kt
                  PKUEntity.kt
                  RemarkDao.kt
                  RemarkEntity.kt
                  SectionDao.kt
                  SectionEntity.kt
                  TubeDao.kt
                  TubeEntity.kt
                model/
                  EquipmentType.kt
                  NodeType.kt
                  PKU.kt
                  SectionType.kt
                  Tube.kt
                sync/
                  ConflictResolver.kt
                  DataMerger.kt
                  EnhancedDataMerger.kt
                  EnhancedSyncManager.kt
                  NearbySyncService.kt
                  PhotoSyncUtils.kt
                  SyncManager.kt
                  SyncModels.kt
                ui/
                  AddEquipmentDialog.kt
                  AddNodeDialog.kt
                  AddPKUDialog.kt
                  AddRemarkDialog.kt
                  AddSectionDialog.kt
                  AddSectionEquipmentDialog.kt
                  AddTubeDialog.kt
                  AdvancedSyncScreen.kt
                  ControlPointDetailScreen.kt
                  ControlPointListScreen.kt
                  ControlPointViewModel.kt
                  ControlPointViewModelFactory.kt
                  EditEquipmentScreen.kt
                  EditNameDialog.kt
                  EditRemarkDialog.kt
                  EquipmentDetailScreen.kt
                  EquipmentPhotoComponents.kt
                  EquipmentPhotoScreen.kt
                  EquipmentViewModel.kt
                  EquipmentViewModelFactory.kt
                  EventViewModel.kt
                  EventViewModelFactory.kt
                  FullScreenPhotoView.kt
                  HelpScreen.kt
                  NodeItem.kt
                  NodeItemWithEquipment.kt
                  NodeViewModel.kt
                  NodeViewModelFactory.kt
                  PermissionScreen.kt
                  PhotoPickerUtils.kt
                  PKUItem.kt
                  PKUViewModel.kt
                  PKUViewModelFactory.kt
                  RemarkComponents.kt
                  RemarkDetailScreen.kt
                  RemarksTab.kt
                  RemarksTabWithArchive.kt
                  RemarkUtils.kt
                  RemarkViewModel.kt
                  RemarkViewModelFactory.kt
                  SectionViewModel.kt
                  SectionViewModelFactory.kt
                  SettingsScreen.kt
                  SimpleDraggableNodeItem.kt
                  SyncScreen.kt
                  SyncState.kt
                  SyncViewModel.kt
                  SyncViewModelFactory.kt
                  TubeItem.kt
                  TubeViewModel.kt
                  TubeViewModelFactory.kt
                  ViewEquipmentScreen.kt
                  ViewRemarkDialog.kt
                  ViewRemarkScreen.kt
                  ViewRemarkUtils.kt
                  theme/
                    Color.kt
                    Shapes.kt
                    Theme.kt
                    Typography.kt
                utils/
                  EquipmentPhotoUtils.kt
                  NameUtils.kt
                  PermissionUtils.kt
                  PhotoStorageUtils.kt
        res/
          drawable/
            ic_launcher_background.xml
          drawable-v24/
            ic_launcher_foreground.xml
          layout/
            activity_splash.xml
            activity_splash11.xml
          mipmap-anydpi-v26/
            ic_launcher.xml
            ic_launcher_round.xml
          mipmap-hdpi/
            ic_launcher.webp
            ic_launcher_foreground.webp
            ic_launcher_round.webp
          mipmap-mdpi/
            ic_launcher.webp
            ic_launcher_foreground.webp
            ic_launcher_round.webp
          mipmap-xhdpi/
            ic_launcher.webp
            ic_launcher_foreground.webp
            ic_launcher_round.webp
          mipmap-xxhdpi/
            ic_launcher.webp
            ic_launcher_foreground.webp
            ic_launcher_round.webp
          mipmap-xxxhdpi/
            ic_launcher.webp
            ic_launcher_foreground.webp
            ic_launcher_round.webp
          raw/
            splash_video.mp4
          values/
            colors.xml
            strings.xml
            themes.xml
          xml/
            backup_rules.xml
            data_extraction_rules.xml
            file_paths.xml
      test/
        java/
          com/
            example/
              kipia/
                ExampleUnitTest.kt
  error/
    buildgradle.txt
    err1.txt
    err10.txt
    err2.txt
    err4.txt
    err5.txt
    err6.txt
    err7.txt
    err8.txt
    err9.txt
    File.txt
    File1.txt
    File2.txt
    Структура и описание.txt
    Характеристики_Оборудования.txt
  gradle/
    libs.versions.toml
    wrapper/
      gradle-wrapper.properties
================================================================================
--- ВЫБРАННЫЕ ФАЙЛЫ ---
================================================================================

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\AndroidManifest.xml ---
------------------------------------------------------------

Корневой элемент: manifest
Package Name: None
Version Name: None, Version Code: None

--- Activity ---
  Activity Name: .SplashActivity, Label: None
  Activity Name: .MainActivity, Label: None

--- Permissions ---
  Permission: android.permission.BLUETOOTH
  Permission: android.permission.BLUETOOTH_ADMIN
  Permission: android.permission.ACCESS_WIFI_STATE
  Permission: android.permission.CHANGE_WIFI_STATE
  Permission: android.permission.ACCESS_COARSE_LOCATION
  Permission: android.permission.ACCESS_FINE_LOCATION
  Permission: android.permission.NEARBY_WIFI_DEVICES
  Permission: android.permission.BLUETOOTH_ADVERTISE
  Permission: android.permission.BLUETOOTH_CONNECT
  Permission: android.permission.BLUETOOTH_SCAN
  Permission: android.permission.READ_MEDIA_VIDEO
  Permission: android.permission.READ_MEDIA_IMAGES
  Permission: android.permission.READ_EXTERNAL_STORAGE
  Permission: android.permission.WRITE_EXTERNAL_STORAGE
  Permission: android.permission.INTERNET
  Permission: android.permission.ACCESS_NETWORK_STATE

--- Services ---
  Service Name: .sync.NearbySyncService


----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\build.gradle.kts ---
------------------------------------------------------------

// build.gradle.kts (корневой файл)
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
    alias(libs.plugins.kotlin.compose) apply false // ✅ ПРАВИЛЬНО: через alias
    id("org.jetbrains.kotlin.plugin.serialization") version "1.9.22" apply false

}


----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\build.gradle.kts ---
------------------------------------------------------------

plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.kotlin.compose)
    id("org.jetbrains.kotlin.plugin.serialization") version "1.9.22"
    id("kotlin-kapt")
}

android {
    namespace = "com.example.kipia"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.example.kipia"
        minSdk = 23
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables.useSupportLibrary = true

        // ДОБАВЬТЕ для Nearby
        multiDexEnabled = true
    }

    buildTypes {
        debug {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }

    kotlinOptions {
        jvmTarget = "11"
    }

    buildFeatures {
        compose = true
        viewBinding = true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.4"
    }
}

dependencies {
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.appcompat:appcompat:1.6.1")
    implementation("com.google.android.material:material:1.10.0")
    implementation("androidx.constraintlayout:constraintlayout:2.1.4")
    implementation("androidx.datastore:datastore-preferences:1.1.1")

    // Compose BOM
    implementation(platform("androidx.compose:compose-bom:2023.10.01"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.compose.material:material")
    implementation("androidx.activity:activity-compose:1.8.0")

    // Компоненты для сетки
    implementation("androidx.compose.foundation:foundation")

    // Room
    implementation("androidx.room:room-runtime:2.6.1")
    implementation("androidx.room:room-ktx:2.6.1")
    kapt("androidx.room:room-compiler:2.6.1")

    // Media3 (ExoPlayer)
    implementation("androidx.media3:media3-exoplayer:1.2.1")
    implementation("androidx.media3:media3-ui:1.2.1")

    // Coroutines
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")

    // ViewModel и Lifecycle
    implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0")
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.7.0")
    implementation("androidx.lifecycle:lifecycle-runtime-compose:2.7.0")

    // Coil для загрузки изображений
    implementation("io.coil-kt:coil-compose:2.5.0")

    // Иконки
    implementation("androidx.compose.material:material-icons-core")
    implementation("androidx.compose.material:material-icons-extended")

    // Navigation
    implementation("androidx.navigation:navigation-compose:2.7.5")

    // Для работы с разрешениями
    implementation("com.google.accompanist:accompanist-permissions:0.32.0")

    // Сериализация JSON
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.0")

    // Nearby Connections - ОБНОВЛЕННЫЕ ЗАВИСИМОСТИ
    implementation("com.google.android.gms:play-services-nearby:18.0.0")

    // WorkManager для фоновых задач
    implementation("androidx.work:work-runtime-ktx:2.9.0")

    // Multidex для Nearby
    implementation("androidx.multidex:multidex:2.0.1")

    // Для работы с файлами
    implementation("commons-io:commons-io:2.11.0")

    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation(platform("androidx.compose:compose-bom:2023.10.01"))
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\androidTest\java\com\example\kipia\ExampleInstrumentedTest.kt ---
------------------------------------------------------------

package com.example.kipia

import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.ext.junit.runners.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getInstrumentation().targetContext
        assertEquals("com.example.kipia", appContext.packageName)
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\data\PreferencesManager.kt ---
------------------------------------------------------------

package com.example.kipia.data

import android.content.Context
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.booleanPreferencesKey
import androidx.datastore.preferences.core.stringPreferencesKey
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.longPreferencesKey
import androidx.datastore.preferences.preferencesDataStore
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "app_settings")

class PreferencesManager(private val context: Context) {

    private object PreferencesKeys {
        val MUTE_SPLASH = booleanPreferencesKey("mute_splash")
        val LAST_SYNC_TIMESTAMP = longPreferencesKey("last_sync_timestamp")
        val DEVICE_ID = stringPreferencesKey("device_id")
        val SYNC_ENABLED = booleanPreferencesKey("sync_enabled")
        val AUTO_SYNC = booleanPreferencesKey("auto_sync")
    }

    // Существующие настройки
    val muteSplashFlow: Flow<Boolean> = context.dataStore.data
        .map { preferences ->
            preferences[PreferencesKeys.MUTE_SPLASH] ?: false
        }

    suspend fun setMuteSplash(mute: Boolean) {
        context.dataStore.edit { preferences ->
            preferences[PreferencesKeys.MUTE_SPLASH] = mute
        }
    }

    // Новые настройки синхронизации
    val lastSyncTimestamp: Flow<Long> = context.dataStore.data
        .map { preferences ->
            preferences[PreferencesKeys.LAST_SYNC_TIMESTAMP] ?: 0L
        }

    val deviceId: Flow<String> = context.dataStore.data
        .map { preferences ->
            preferences[PreferencesKeys.DEVICE_ID] ?: generateDeviceId()
        }

    val syncEnabled: Flow<Boolean> = context.dataStore.data
        .map { preferences ->
            preferences[PreferencesKeys.SYNC_ENABLED] ?: true
        }

    val autoSync: Flow<Boolean> = context.dataStore.data
        .map { preferences ->
            preferences[PreferencesKeys.AUTO_SYNC] ?: false
        }

    suspend fun setLastSyncTimestamp(timestamp: Long) {
        context.dataStore.edit { preferences ->
            preferences[PreferencesKeys.LAST_SYNC_TIMESTAMP] = timestamp
        }
    }

    suspend fun setSyncEnabled(enabled: Boolean) {
        context.dataStore.edit { preferences ->
            preferences[PreferencesKeys.SYNC_ENABLED] = enabled
        }
    }

    suspend fun setAutoSync(enabled: Boolean) {
        context.dataStore.edit { preferences ->
            preferences[PreferencesKeys.AUTO_SYNC] = enabled
        }
    }

    private suspend fun generateDeviceId(): String {
        val newId = "DEV_${System.currentTimeMillis()}_${(1000..9999).random()}"
        context.dataStore.edit { preferences ->
            preferences[PreferencesKeys.DEVICE_ID] = newId
        }
        return newId
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\AppDatabase.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import android.content.Context

@Database(
    entities = [
        ControlPointEntity::class,
        PKUEntity::class,
        TubeEntity::class,
        NodeEntity::class,
        SectionEntity::class,
        EquipmentEntity::class,
        DetailedEquipmentEntity::class,
        RemarkEntity::class,
        EventEntity::class
    ],
    version = 13, // НЕ МЕНЯЙТЕ эту версию без необходимости
    exportSchema = false // Отключаем экспорт схемы чтобы избежать проверок
)
abstract class AppDatabase : RoomDatabase() {
    abstract fun controlPointDao(): ControlPointDao
    abstract fun pkuDao(): PKUDao
    abstract fun tubeDao(): TubeDao
    abstract fun nodeDao(): NodeDao
    abstract fun sectionDao(): SectionDao
    abstract fun equipmentDao(): EquipmentDao
    abstract fun detailedEquipmentDao(): DetailedEquipmentDao
    abstract fun remarkDao(): RemarkDao
    abstract fun eventDao(): EventDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        fun getInstance(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "kipia_database"
                )
                    .fallbackToDestructiveMigration() // Всегда используем деструктивную миграцию
                    .build()
                INSTANCE = instance
                instance
            }
        }

        // Метод для принудительного пересоздания базы (для разработки)
        fun recreateInstance(context: Context): AppDatabase {
            INSTANCE = null
            return getInstance(context)
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\ControlPointDao.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Delete
import kotlinx.coroutines.flow.Flow

@Dao
interface ControlPointDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(controlPoint: ControlPointEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(controlPoints: List<ControlPointEntity>)

    @Query("SELECT * FROM control_point_table ORDER BY name ASC")
    suspend fun getAllControlPoints(): List<ControlPointEntity>

    @Query("SELECT * FROM control_point_table ORDER BY name ASC")
    fun getAllControlPointsFlow(): Flow<List<ControlPointEntity>>

    @Query("SELECT * FROM control_point_table WHERE id = :id")
    suspend fun getControlPointById(id: Long): ControlPointEntity?

    @Delete
    suspend fun delete(controlPoint: ControlPointEntity)

    @Query("DELETE FROM control_point_table WHERE id = :id")
    suspend fun deleteById(id: Long)

    @Query("UPDATE control_point_table SET name = :name, description = :description WHERE id = :id")
    suspend fun update(id: Long, name: String, description: String)
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\ControlPointEntity.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "control_point_table")
data class ControlPointEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0L,

    // Название КП, например "КП 937 км"
    val name: String,

    // Описание КП
    val description: String = ""

)


----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\DetailedEquipmentDao.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Delete
import androidx.room.Update

@Dao
interface DetailedEquipmentDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(equipment: DetailedEquipmentEntity)

    @Query("SELECT * FROM detailed_equipment_table WHERE nodeId = :nodeId")
    suspend fun getEquipmentByNodeId(nodeId: Long): List<DetailedEquipmentEntity>

    @Query("SELECT * FROM detailed_equipment_table WHERE sectionId = :sectionId")
    suspend fun getEquipmentBySectionId(sectionId: Long): List<DetailedEquipmentEntity>

    @Query("SELECT * FROM detailed_equipment_table")
    suspend fun getAllDetailedEquipment(): List<DetailedEquipmentEntity>

    @Query("SELECT * FROM detailed_equipment_table WHERE id = :id")
    suspend fun getEquipmentById(id: Long): DetailedEquipmentEntity?

    @Delete
    suspend fun delete(equipment: DetailedEquipmentEntity)

    @Query("DELETE FROM detailed_equipment_table WHERE id = :id")
    suspend fun deleteById(id: Long)

    @Query("UPDATE detailed_equipment_table SET photoPaths = :photoPaths WHERE id = :id")
    suspend fun updatePhotoPaths(id: Long, photoPaths: String)

    @Query("SELECT photoPaths FROM detailed_equipment_table WHERE id = :id")
    suspend fun getPhotoPaths(id: Long): String?

    @Update
    suspend fun update(equipment: DetailedEquipmentEntity)
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\DetailedEquipmentEntity.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "detailed_equipment_table",
    foreignKeys = [
        ForeignKey(
            entity = NodeEntity::class,
            parentColumns = ["id"],
            childColumns = ["nodeId"],
            onDelete = ForeignKey.CASCADE
        ),
        ForeignKey(
            entity = SectionEntity::class,
            parentColumns = ["id"],
            childColumns = ["sectionId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["nodeId"]),
        Index(value = ["sectionId"])
    ]
)
data class DetailedEquipmentEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0L,
    val equipmentType: String = "", // ИСПРАВЛЕНО: значение по умолчанию
    val name: String = "", // ИСПРАВЛЕНО: значение по умолчанию
    val nodeId: Long? = null,
    val sectionId: Long? = null,

    // Общие характеристики
    val model: String = "",
    val manufacturer: String = "",
    val serialNumber: String = "",
    val productionYear: String = "",
    val verificationYear: String = "",

    // Специфические характеристики
    val nominal: String = "",
    val pressureLimit: String = "",
    val softwareVersion: String = "",
    val mo: String = "",
    val mz: String = "",
    val mto: String = "",
    val mtz: String = "",
    val muo: String = "",
    val muz: String = "",
    val outputContacts: String = "",

    // ДОБАВЛЕНО ПОЛЕ ДЛЯ ФОТО
    val photoPaths: String = ""
)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\EquipmentDao.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Delete
import androidx.room.Update

@Dao
interface EquipmentDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(equipment: EquipmentEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(equipments: List<EquipmentEntity>)

    @Query("SELECT * FROM equipment_table WHERE nodeId = :nodeId")
    suspend fun getEquipmentByNodeId(nodeId: Long): List<EquipmentEntity>

    @Query("SELECT * FROM equipment_table WHERE sectionId = :sectionId")
    suspend fun getEquipmentBySectionId(sectionId: Long): List<EquipmentEntity>

    @Query("SELECT * FROM equipment_table")
    suspend fun getAllEquipment(): List<EquipmentEntity>

    @Query("SELECT * FROM equipment_table WHERE id = :id")
    suspend fun getEquipmentById(id: Long): EquipmentEntity?

    @Delete
    suspend fun delete(equipment: EquipmentEntity)

    @Query("DELETE FROM equipment_table WHERE id = :id")
    suspend fun deleteById(id: Long)

    @Query("UPDATE equipment_table SET photoPaths = :photoPaths WHERE id = :id")
    suspend fun updatePhotoPaths(id: Long, photoPaths: String)

    @Query("SELECT photoPaths FROM equipment_table WHERE id = :id")
    suspend fun getPhotoPaths(id: Long): String?

    @Update
    suspend fun update(equipment: EquipmentEntity)
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\EquipmentEntity.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "equipment_table",
    foreignKeys = [
        ForeignKey(
            entity = NodeEntity::class,
            parentColumns = ["id"],
            childColumns = ["nodeId"],
            onDelete = ForeignKey.CASCADE
        ),
        ForeignKey(
            entity = SectionEntity::class,
            childColumns = ["sectionId"],
            parentColumns = ["id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["nodeId"]),
        Index(value = ["sectionId"])
    ]
)
data class EquipmentEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0L,
    val name: String = "", // ИСПРАВЛЕНО: значение по умолчанию
    val nodeId: Long? = null,
    val sectionId: Long? = null,
    val model: String = "",
    val manufacturer: String = "",
    val serialNumber: String = "", // ИСПРАВЛЕНО: значение по умолчанию
    val nominal: String = "", // ИСПРАВЛЕНО: значение по умолчанию
    val verificationYear: String = "", // ИСПРАВЛЕНО: значение по умолчанию
    val photoPaths: String = ""
)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\EventDao.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.*

@Dao
interface EventDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(event: EventEntity)

    @Query("SELECT * FROM event_table WHERE controlPointId = :controlPointId ORDER BY date DESC")
    suspend fun getEventsByControlPointId(controlPointId: Long): List<EventEntity>

    @Query("SELECT * FROM event_table")
    suspend fun getAllEvents(): List<EventEntity>

    @Query("SELECT * FROM event_table WHERE id = :id")
    suspend fun getEventById(id: Long): EventEntity?

    @Update
    suspend fun update(event: EventEntity)

    @Delete
    suspend fun delete(event: EventEntity)

    @Query("DELETE FROM event_table WHERE controlPointId = :controlPointId")
    suspend fun deleteByControlPointId(controlPointId: Long)
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\EventEntity.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "event_table",
    foreignKeys = [
        ForeignKey(
            entity = ControlPointEntity::class,
            parentColumns = ["id"],
            childColumns = ["controlPointId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index(value = ["controlPointId"])]
)
data class EventEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0L,
    val controlPointId: Long,
    val title: String,                    // Краткое название события
    val description: String = "",         // Описание
    val type: String = "Проверка",       // "Проверка", "Обслуживание", "Ремонт"
    val date: String,                     // Дата события
    val time: String = "",                // Время
    val isCompleted: Boolean = false,
    val participants: String = ""         // Участники (JSON)
)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\NodeDao.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Delete
import androidx.room.Update

@Dao
interface NodeDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(node: NodeEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(nodes: List<NodeEntity>)

    @Query("SELECT * FROM node_table WHERE tubeId = :tubeId ORDER BY orderIndex ASC")
    suspend fun getNodesByTubeId(tubeId: Long): List<NodeEntity>

    @Query("SELECT * FROM node_table")
    suspend fun getAllNodes(): List<NodeEntity>

    @Query("SELECT * FROM node_table WHERE id = :id")
    suspend fun getNodeById(id: Long): NodeEntity?

    @Delete
    suspend fun delete(node: NodeEntity)

    @Query("DELETE FROM node_table WHERE id = :id")
    suspend fun deleteById(id: Long)

    @Query("UPDATE node_table SET name = :name WHERE id = :id")
    suspend fun update(id: Long, name: String)

    @Query("UPDATE node_table SET orderIndex = :orderIndex WHERE id = :id")
    suspend fun updateOrder(id: Long, orderIndex: Int)

    @Update
    suspend fun updateNode(node: NodeEntity)
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\NodeEntity.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/database/NodeEntity.kt
package com.example.kipia.database

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "node_table",
    foreignKeys = [
        ForeignKey(
            entity = TubeEntity::class,
            parentColumns = ["id"],
            childColumns = ["tubeId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index(value = ["tubeId"])] // ДОБАВИТЬ ЭТУ СТРОКУ
)
data class NodeEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0L,
    val name: String,
    val tubeId: Long,
    val nodeType: String,
    val orderIndex: Int = 0
)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\PKUDao.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Delete

@Dao
interface PKUDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(pku: PKUEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(pkus: List<PKUEntity>)

    @Query("SELECT * FROM pku_table ORDER BY name ASC")
    suspend fun getAllPKUs(): List<PKUEntity>

    @Query("SELECT * FROM pku_table WHERE controlPointId = :controlPointId")
    suspend fun getPKUsByControlPointId(controlPointId: Long): List<PKUEntity>

    @Query("SELECT * FROM pku_table WHERE id = :id")
    suspend fun getPKUById(id: Long): PKUEntity?

    @Delete
    suspend fun delete(pku: PKUEntity)

    @Query("DELETE FROM pku_table WHERE id = :id")
    suspend fun deleteById(id: Long)

    @Query("UPDATE pku_table SET name = :name, description = :description WHERE id = :id")
    suspend fun update(id: Long, name: String, description: String)
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\PKUEntity.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "pku_table",
    foreignKeys = [
        ForeignKey(
            entity = ControlPointEntity::class,
            parentColumns = ["id"],
            childColumns = ["controlPointId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index(value = ["controlPointId"])] // ДОБАВИТЬ ЭТУ СТРОКУ
)
data class PKUEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0L,
    val name: String,
    val description: String = "",
    val isCompleted: Boolean = false,
    val controlPointId: Long
)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\RemarkDao.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.*

@Dao
interface RemarkDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(remark: RemarkEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(remarks: List<RemarkEntity>)

    @Query("SELECT * FROM remark_table WHERE controlPointId = :controlPointId ORDER BY " +
            "CASE WHEN priority = 'Высокий' THEN 1 " +
            "WHEN priority = 'Средний' THEN 2 " +
            "ELSE 3 END, deadline ASC")
    suspend fun getRemarksByControlPointId(controlPointId: Long): List<RemarkEntity>

    @Query("SELECT * FROM remark_table")
    suspend fun getAllRemarks(): List<RemarkEntity>

    @Query("SELECT * FROM remark_table WHERE controlPointId = :controlPointId AND isArchived = 0 ORDER BY " +
            "CASE WHEN priority = 'Высокий' THEN 1 " +
            "WHEN priority = 'Средний' THEN 2 " +
            "ELSE 3 END, deadline ASC")
    suspend fun getActiveRemarksByControlPointId(controlPointId: Long): List<RemarkEntity>

    @Query("SELECT * FROM remark_table WHERE controlPointId = :controlPointId AND isArchived = 1 ORDER BY " +
            "CASE WHEN priority = 'Высокий' THEN 1 " +
            "WHEN priority = 'Средний' THEN 2 " +
            "ELSE 3 END, deadline ASC")
    suspend fun getArchivedRemarksByControlPointId(controlPointId: Long): List<RemarkEntity>

    @Query("SELECT * FROM remark_table WHERE id = :id")
    suspend fun getRemarkById(id: Long): RemarkEntity?

    @Query("UPDATE remark_table SET status = :status, completedDate = :completedDate WHERE id = :id")
    suspend fun updateStatus(id: Long, status: String, completedDate: String)

    @Query("UPDATE remark_table SET isArchived = 1 WHERE id = :id")
    suspend fun archiveRemark(id: Long)

    @Query("UPDATE remark_table SET isArchived = 0 WHERE id = :id")
    suspend fun unarchiveRemark(id: Long)

    @Update
    suspend fun update(remark: RemarkEntity)

    @Delete
    suspend fun delete(remark: RemarkEntity)

    @Query("DELETE FROM remark_table WHERE controlPointId = :controlPointId")
    suspend fun deleteByControlPointId(controlPointId: Long)
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\RemarkEntity.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey
import android.util.Log

@Entity(
    tableName = "remark_table",
    foreignKeys = [
        ForeignKey(
            entity = ControlPointEntity::class,
            parentColumns = ["id"],
            childColumns = ["controlPointId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index(value = ["controlPointId"])]
)
data class RemarkEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0L,
    val controlPointId: Long,
    val title: String,
    val description: String = "",
    val category: String = "Оборудование",
    val priority: String = "Средний",
    val status: String = "Открыто",
    val createdDate: String,
    val deadline: String,
    val completedDate: String = "",
    val photos: String = "",
    val isArchived: Boolean = false // ДОБАВЛЕНО ПОЛЕ АРХИВА
) {
    fun getPhotoList(): List<String> {
        Log.d("RemarkEntity", "Getting photos from: $photos")
        return if (photos.isNotEmpty()) {
            try {
                val paths = photos.split(",").filter { it.isNotBlank() }
                Log.d("RemarkEntity", "Parsed ${paths.size} photos")
                paths
            } catch (e: Exception) {
                Log.e("RemarkEntity", "Error parsing photos", e)
                emptyList()
            }
        } else {
            emptyList()
        }
    }

    fun withPhotos(photoPaths: List<String>): RemarkEntity {
        Log.d("RemarkEntity", "Setting ${photoPaths.size} photos")
        val photosString = if (photoPaths.isNotEmpty()) {
            photoPaths.joinToString(",")
        } else {
            ""
        }
        Log.d("RemarkEntity", "Photos string: $photosString")
        return this.copy(photos = photosString)
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\SectionDao.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.*
import kotlinx.coroutines.flow.Flow

@Dao
interface SectionDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(section: SectionEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(sections: List<SectionEntity>)

    @Query("SELECT * FROM section_table WHERE pkuId = :pkuId")
    suspend fun getSectionsByPKUId(pkuId: Long): List<SectionEntity>

    @Query("SELECT * FROM section_table WHERE id = :id")
    suspend fun getSectionById(id: Long): SectionEntity?

    @Update
    suspend fun update(section: SectionEntity)

    @Delete
    suspend fun delete(section: SectionEntity)

    @Query("DELETE FROM section_table WHERE id = :id")
    suspend fun deleteById(id: Long)

    @Query("SELECT * FROM section_table")
    suspend fun getAllSections(): List<SectionEntity>
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\SectionEntity.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "section_table",
    foreignKeys = [
        ForeignKey(
            entity = PKUEntity::class,
            parentColumns = ["id"],
            childColumns = ["pkuId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index(value = ["pkuId"])] // ДОБАВИТЬ ЭТУ СТРОКУ
)
data class SectionEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0L,
    val name: String,
    val pkuId: Long
)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\TubeDao.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Delete

@Dao
interface TubeDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(tube: TubeEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(tubes: List<TubeEntity>)

    @Query("SELECT * FROM tube_table WHERE controlPointId = :controlPointId")
    suspend fun getTubesByControlPointId(controlPointId: Long): List<TubeEntity>

    @Query("SELECT * FROM tube_table")
    suspend fun getAllTubes(): List<TubeEntity>

    @Query("SELECT * FROM tube_table WHERE id = :id")
    suspend fun getTubeById(id: Long): TubeEntity?

    @Delete
    suspend fun delete(tube: TubeEntity)

    @Query("DELETE FROM tube_table WHERE id = :id")
    suspend fun deleteById(id: Long)

    @Query("UPDATE tube_table SET name = :name WHERE id = :id")
    suspend fun update(id: Long, name: String)
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\database\TubeEntity.kt ---
------------------------------------------------------------

package com.example.kipia.database

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "tube_table",
    foreignKeys = [
        ForeignKey(
            entity = ControlPointEntity::class,
            parentColumns = ["id"],
            childColumns = ["controlPointId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index(value = ["controlPointId"])] // ДОБАВИТЬ ЭТУ СТРОКУ
)
data class TubeEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0L,
    val name: String,
    val controlPointId: Long
)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\MainActivity.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/MainActivity.kt
package com.example.kipia

import android.net.Uri
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.BackHandler
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.AlertDialog
import androidx.compose.material.Button
import androidx.compose.material.Card
import androidx.compose.material.Divider
import androidx.compose.material.ExperimentalMaterialApi
import androidx.compose.material.FloatingActionButton
import androidx.compose.material.Icon
import androidx.compose.material.IconButton
import androidx.compose.material.MaterialTheme
import androidx.compose.material.OutlinedTextField
import androidx.compose.material.Scaffold
import androidx.compose.material.Surface
import androidx.compose.material.Text
import androidx.compose.material.TextButton
import androidx.compose.material.TopAppBar
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.filled.Place
import androidx.compose.material.icons.filled.Sync
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.example.kipia.database.AppDatabase
import com.example.kipia.database.ControlPointEntity
import com.example.kipia.ui.ControlPointDetailScreen
import com.example.kipia.ui.ControlPointViewModel
import com.example.kipia.ui.ControlPointViewModelFactory
import com.example.kipia.ui.EditEquipmentScreen
import com.example.kipia.ui.EquipmentDetailScreen
import com.example.kipia.ui.EquipmentPhotoScreen
import com.example.kipia.ui.EquipmentViewModel
import com.example.kipia.ui.EquipmentViewModelFactory
import com.example.kipia.ui.FullScreenPhotoView
import com.example.kipia.ui.NodeViewModel
import com.example.kipia.ui.NodeViewModelFactory
import com.example.kipia.ui.PKUViewModel
import com.example.kipia.ui.PKUViewModelFactory
import com.example.kipia.ui.SyncScreen
import com.example.kipia.ui.TubeViewModel
import com.example.kipia.ui.TubeViewModelFactory
import com.example.kipia.ui.ViewEquipmentScreen
import com.example.kipia.ui.theme.KIPITheme

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            KIPITheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colors.background
                ) {
                    AppNavigation()
                }
            }
        }
    }
}

// Расширенное состояние навигации
data class NavigationState(
    val selectedControlPoint: ControlPointEntity? = null,
    val selectedNodeForEquipment: com.example.kipia.database.NodeEntity? = null,
    val selectedSectionForEquipment: com.example.kipia.database.SectionEntity? = null,
    val selectedEquipmentForPhotos: Pair<Long, String>? = null,
    val selectedEquipmentForView: Long? = null,
    val selectedEquipmentForEdit: Long? = null,
    val fullScreenPhotoUri: Uri? = null,
    val showSyncScreen: Boolean = false // Добавляем флаг для экрана синхронизации
)

@Composable
fun AppNavigation() {
    val context = LocalContext.current
    val controlPointViewModel: ControlPointViewModel = viewModel(
        factory = ControlPointViewModelFactory(AppDatabase.getInstance(context))
    )
    val controlPoints by controlPointViewModel.controlPoints.collectAsState()

    var navState by remember { mutableStateOf(NavigationState()) }

    // Обновляем обработчик BackHandler
    BackHandler(
        enabled = navState.selectedControlPoint != null ||
                navState.selectedNodeForEquipment != null ||
                navState.selectedSectionForEquipment != null ||
                navState.selectedEquipmentForPhotos != null ||
                navState.selectedEquipmentForView != null ||
                navState.selectedEquipmentForEdit != null ||
                navState.fullScreenPhotoUri != null ||
                navState.showSyncScreen
    ) {
        navState = when {
            navState.fullScreenPhotoUri != null -> navState.copy(fullScreenPhotoUri = null)
            navState.selectedEquipmentForEdit != null -> navState.copy(selectedEquipmentForEdit = null)
            navState.selectedEquipmentForView != null -> navState.copy(selectedEquipmentForView = null)
            navState.selectedEquipmentForPhotos != null -> navState.copy(selectedEquipmentForPhotos = null)
            navState.selectedNodeForEquipment != null -> navState.copy(selectedNodeForEquipment = null)
            navState.selectedSectionForEquipment != null -> navState.copy(selectedSectionForEquipment = null)
            navState.showSyncScreen -> navState.copy(showSyncScreen = false)
            else -> navState.copy(selectedControlPoint = null)
        }
    }

    // Объединяем все when условия в один блок
    when {
        navState.showSyncScreen -> {
            SyncScreen(
                onBackClick = {
                    navState = navState.copy(showSyncScreen = false)
                }
            )
        }
        navState.fullScreenPhotoUri != null -> {
            FullScreenPhotoView(
                photoUri = navState.fullScreenPhotoUri!!,
                onDismiss = {
                    navState = navState.copy(fullScreenPhotoUri = null)
                }
            )
        }
        navState.selectedEquipmentForEdit != null -> {
            EditEquipmentScreen(
                equipmentId = navState.selectedEquipmentForEdit!!,
                onBackClick = {
                    navState = navState.copy(selectedEquipmentForEdit = null)
                },
                onSaveClick = {
                    navState = navState.copy(selectedEquipmentForEdit = null)
                }
            )
        }
        navState.selectedEquipmentForView != null -> {
            ViewEquipmentScreen(
                equipmentId = navState.selectedEquipmentForView!!,
                onBackClick = {
                    navState = navState.copy(selectedEquipmentForView = null)
                },
                onEditClick = {
                    navState = navState.copy(
                        selectedEquipmentForEdit = navState.selectedEquipmentForView,
                        selectedEquipmentForView = null
                    )
                }
            )
        }
        navState.selectedEquipmentForPhotos != null -> {
            val (equipmentId, equipmentName) = navState.selectedEquipmentForPhotos!!
            EquipmentPhotoScreen(
                equipmentId = equipmentId,
                equipmentName = equipmentName,
                onBackClick = {
                    navState = navState.copy(selectedEquipmentForPhotos = null)
                },
                onViewFullScreen = { uri ->
                    navState = navState.copy(fullScreenPhotoUri = uri)
                }
            )
        }
        navState.selectedNodeForEquipment != null || navState.selectedSectionForEquipment != null -> {
            // Экран оборудования узла или отсека
            EquipmentNavigation(
                navState = navState,
                onUpdateNavState = { newState -> navState = newState },
                controlPointViewModel = controlPointViewModel
            )
        }
        navState.selectedControlPoint != null -> {
            // Экран контрольной точки
            ControlPointNavigation(
                controlPoint = navState.selectedControlPoint!!,
                onBackClick = {
                    navState = navState.copy(selectedControlPoint = null)
                },
                onNodeSelected = { node ->
                    navState = navState.copy(selectedNodeForEquipment = node)
                },
                onSectionSelected = { section ->
                    navState = navState.copy(selectedSectionForEquipment = section)
                },
                onEquipmentViewSelected = { equipmentId ->
                    navState = navState.copy(selectedEquipmentForView = equipmentId)
                },
                onEquipmentEditSelected = { equipmentId ->
                    navState = navState.copy(selectedEquipmentForEdit = equipmentId)
                },
                onEquipmentPhotosSelected = { equipmentId, equipmentName ->
                    navState = navState.copy(selectedEquipmentForPhotos = Pair(equipmentId, equipmentName))
                }
            )
        }
        else -> {
            // Список контрольных точек
            ControlPointListScreen(
                controlPoints = controlPoints,
                onControlPointClick = { cp ->
                    navState = navState.copy(selectedControlPoint = cp)
                },
                onAddControlPoint = { name, desc ->
                    controlPointViewModel.addControlPoint(name, desc)
                },
                onDeleteControlPoint = { id ->
                    controlPointViewModel.deleteControlPoint(id)
                },
                onEditControlPoint = { id, newName, description ->
                    controlPointViewModel.updateControlPoint(id, newName, description)
                },
                onSyncClick = {
                    navState = navState.copy(showSyncScreen = true)
                }
            )
        }
    }
}

// Выносим ControlPointListScreen как отдельную функцию
// В MainActivity.kt замените текущий ControlPointListScreen на:

@Composable
fun ControlPointListScreen(
    controlPoints: List<ControlPointEntity>,
    onControlPointClick: (ControlPointEntity) -> Unit,
    onAddControlPoint: (String, String) -> Unit,
    onDeleteControlPoint: (Long) -> Unit,
    onEditControlPoint: (Long, String, String) -> Unit,
    onSyncClick: () -> Unit = {}
) {
    var showAddDialog by remember { mutableStateOf(false) }
    var newControlPointName by remember { mutableStateOf("") }
    var newControlPointDescription by remember { mutableStateOf("") }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Контрольные точки") }
            )
        },
        floatingActionButton = {
            Column {
                // Кнопка синхронизации
                FloatingActionButton(
                    onClick = onSyncClick,
                    modifier = Modifier.padding(bottom = 8.dp),
                    backgroundColor = MaterialTheme.colors.secondary
                ) {
                    Icon(Icons.Default.Sync, contentDescription = "Синхронизация")
                }
                // Кнопка добавления
                FloatingActionButton(
                    onClick = { showAddDialog = true }
                ) {
                    Icon(Icons.Default.Add, contentDescription = "Добавить КП")
                }
            }
        }
    ) { padding ->
        if (controlPoints.isEmpty()) {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding)
                    .padding(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.Center
            ) {
                Icon(
                    imageVector = Icons.Default.Place,
                    contentDescription = "Нет КП",
                    modifier = Modifier.size(64.dp),
                    tint = MaterialTheme.colors.onSurface.copy(alpha = 0.6f)
                )
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    text = "Нет контрольных точек",
                    style = MaterialTheme.typography.h6,
                    color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f)
                )
                Text(
                    text = "Нажмите + чтобы добавить первую КП",
                    color = MaterialTheme.colors.onSurface.copy(alpha = 0.4f)
                )
            }
        } else {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding)
            ) {
                items(controlPoints) { controlPoint ->
                    ControlPointListItem(
                        controlPoint = controlPoint,
                        onItemClick = { onControlPointClick(controlPoint) },
                        onDeleteClick = { onDeleteControlPoint(controlPoint.id) },
                        onEditClick = { name, description ->
                            onEditControlPoint(controlPoint.id, name, description)
                        }
                    )
                    Divider()
                }
            }
        }
    }

    // Диалог добавления КП
    if (showAddDialog) {
        AlertDialog(
            onDismissRequest = { showAddDialog = false },
            title = { Text("Добавить контрольную точку") },
            text = {
                Column {
                    OutlinedTextField(
                        value = newControlPointName,
                        onValueChange = { newControlPointName = it },
                        label = { Text("Название КП") },
                        modifier = Modifier.fillMaxWidth()
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    OutlinedTextField(
                        value = newControlPointDescription,
                        onValueChange = { newControlPointDescription = it },
                        label = { Text("Описание") },
                        modifier = Modifier.fillMaxWidth()
                    )
                }
            },
            confirmButton = {
                Button(
                    onClick = {
                        if (newControlPointName.isNotBlank()) {
                            onAddControlPoint(newControlPointName, newControlPointDescription)
                            newControlPointName = ""
                            newControlPointDescription = ""
                            showAddDialog = false
                        }
                    },
                    enabled = newControlPointName.isNotBlank()
                ) {
                    Text("Добавить")
                }
            },
            dismissButton = {
                TextButton(onClick = { showAddDialog = false }) {
                    Text("Отмена")
                }
            }
        )
    }
}

@OptIn(ExperimentalMaterialApi::class)
@Composable
fun ControlPointListItem(
    controlPoint: ControlPointEntity,
    onItemClick: () -> Unit,
    onDeleteClick: () -> Unit,
    onEditClick: (String, String) -> Unit
) {
    var showEditDialog by remember { mutableStateOf(false) }
    var editName by remember { mutableStateOf(controlPoint.name) }
    var editDescription by remember { mutableStateOf(controlPoint.description) }

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp),
        elevation = 2.dp,
        onClick = onItemClick
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = controlPoint.name,
                    style = MaterialTheme.typography.h6
                )
                if (controlPoint.description.isNotBlank()) {
                    Text(
                        text = controlPoint.description,
                        style = MaterialTheme.typography.body2,
                        color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f)
                    )
                }
            }

            Row {
                IconButton(onClick = { showEditDialog = true }) {
                    Icon(Icons.Default.Edit, contentDescription = "Редактировать")
                }
                IconButton(onClick = onDeleteClick) {
                    Icon(Icons.Default.Delete, contentDescription = "Удалить", tint = MaterialTheme.colors.error)
                }
            }
        }
    }

    // Диалог редактирования
    if (showEditDialog) {
        AlertDialog(
            onDismissRequest = { showEditDialog = false },
            title = { Text("Редактировать КП") },
            text = {
                Column {
                    OutlinedTextField(
                        value = editName,
                        onValueChange = { editName = it },
                        label = { Text("Название КП") },
                        modifier = Modifier.fillMaxWidth()
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    OutlinedTextField(
                        value = editDescription,
                        onValueChange = { editDescription = it },
                        label = { Text("Описание") },
                        modifier = Modifier.fillMaxWidth()
                    )
                }
            },
            confirmButton = {
                Button(
                    onClick = {
                        if (editName.isNotBlank()) {
                            onEditClick(editName, editDescription)
                            showEditDialog = false
                        }
                    },
                    enabled = editName.isNotBlank()
                ) {
                    Text("Сохранить")
                }
            },
            dismissButton = {
                TextButton(onClick = { showEditDialog = false }) {
                    Text("Отмена")
                }
            }
        )
    }
}

@Composable
fun EquipmentNavigation(
    navState: NavigationState,
    onUpdateNavState: (NavigationState) -> Unit,
    controlPointViewModel: ControlPointViewModel
) {
    val node = navState.selectedNodeForEquipment
    val section = navState.selectedSectionForEquipment

    if (node != null) {
        EquipmentDetailScreen(
            nodeName = node.name,
            nodeId = node.id,
            onBackClick = {
                onUpdateNavState(navState.copy(selectedNodeForEquipment = null))
            },
            onViewEquipment = { equipmentId ->
                // Находим имя оборудования для передачи
                val equipmentName = "Оборудование $equipmentId" // Можно улучшить, получая реальное имя
                onUpdateNavState(navState.copy(
                    selectedEquipmentForView = equipmentId
                ))
            },
            onViewEquipmentPhotos = { equipmentId, photoPaths ->
                // Передаем имя узла как контекст
                onUpdateNavState(navState.copy(
                    selectedEquipmentForPhotos = Pair(equipmentId, node.name)
                ))
            },
            onAddPhotosToEquipment = { equipmentId, equipmentName ->
                onUpdateNavState(navState.copy(
                    selectedEquipmentForPhotos = Pair(equipmentId, equipmentName)
                ))
            }
        )
    } else if (section != null) {
        EquipmentDetailScreen(
            sectionName = section.name,
            sectionId = section.id,
            onBackClick = {
                onUpdateNavState(navState.copy(selectedSectionForEquipment = null))
            },
            onViewEquipment = { equipmentId ->
                // Находим имя оборудования для передачи
                val equipmentName = "Оборудование $equipmentId" // Можно улучшить, получая реальное имя
                onUpdateNavState(navState.copy(
                    selectedEquipmentForView = equipmentId
                ))
            },
            onViewEquipmentPhotos = { equipmentId, photoPaths ->
                // Передаем имя секции как контекст
                onUpdateNavState(navState.copy(
                    selectedEquipmentForPhotos = Pair(equipmentId, section.name)
                ))
            },
            onAddPhotosToEquipment = { equipmentId, equipmentName ->
                onUpdateNavState(navState.copy(
                    selectedEquipmentForPhotos = Pair(equipmentId, equipmentName)
                ))
            }
        )
    }
}

@Composable
fun ControlPointNavigation(
    controlPoint: ControlPointEntity,
    onBackClick: () -> Unit,
    onNodeSelected: (com.example.kipia.database.NodeEntity) -> Unit,
    onSectionSelected: (com.example.kipia.database.SectionEntity) -> Unit,
    onEquipmentViewSelected: (Long) -> Unit,
    onEquipmentEditSelected: (Long) -> Unit,
    onEquipmentPhotosSelected: (Long, String) -> Unit
) {
    val context = LocalContext.current
    val pkuViewModel: PKUViewModel = viewModel(
        factory = PKUViewModelFactory(AppDatabase.getInstance(context))
    )
    val tubeViewModel: TubeViewModel = viewModel(
        factory = TubeViewModelFactory(AppDatabase.getInstance(context))
    )
    val nodeViewModel: NodeViewModel = viewModel(
        factory = NodeViewModelFactory(AppDatabase.getInstance(context))
    )
    val equipmentViewModel: EquipmentViewModel = viewModel(
        factory = EquipmentViewModelFactory(AppDatabase.getInstance(context))
    )

    LaunchedEffect(controlPoint) {
        pkuViewModel.loadPKUsByControlPointId(controlPoint.id)
        tubeViewModel.loadTubesByControlPointId(controlPoint.id)
    }

    ControlPointDetailScreen(
        controlPoint = controlPoint,
        pkuViewModel = pkuViewModel,
        tubeViewModel = tubeViewModel,
        nodeViewModel = nodeViewModel,
        equipmentViewModel = equipmentViewModel,
        onBackClick = onBackClick,
        onAddPKU = { name, desc ->
            pkuViewModel.addPKU(name, desc, controlPoint.id)
        },
        onDeletePKU = { id ->
            pkuViewModel.deletePKU(id, controlPoint.id)
        },
        onAddTube = { name ->
            tubeViewModel.addTube(name, controlPoint.id)
        },
        onDeleteTube = { id ->
            tubeViewModel.deleteTube(id, controlPoint.id)
        },
        onAddNode = { name, tubeId, type ->
            nodeViewModel.addNode(name, tubeId, type)
        },
        onDeleteNode = { nodeId, tubeId ->
            nodeViewModel.deleteNode(nodeId, tubeId)
        },
        onViewEquipment = { nodeId, nodeName ->
            // Находим узел по ID и передаем его
            val nodes = nodeViewModel.nodes.value
            val node = nodes.find { it.id == nodeId }
            node?.let { onNodeSelected(it) }
        },
        onViewSectionEquipment = { sectionId, sectionName ->
            // Создаем временную секцию или находим реальную
            val section = com.example.kipia.database.SectionEntity(
                id = sectionId,
                name = sectionName,
                pkuId = 0 // Временное значение
            )
            onSectionSelected(section)
        },
        onViewEquipmentPhotos = { equipmentId, photoPaths ->
            onEquipmentPhotosSelected(equipmentId, "Оборудование $equipmentId")
        }
    )
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\model\EquipmentType.kt ---
------------------------------------------------------------

package com.example.kipia.model

enum class EquipmentType(val displayName: String) {
    // Оборудование для узлов (ОД, В)
    FLOOD_DETECTOR("Сигнализатор затопления"),
    OPENING_DETECTOR("Сигнализатор вскрытия"),
    PRESSURE_GAUGE("Манометр давления"),
    PRESSURE_TRANSDUCER("Преобразователь давления"),
    DPS("ДПС"),
    R_K("Распред.коробка"),


    // Оборудование для задвижек
    VALVE("Задвижка"),
    ELECTRIC_DRIVE("Эл.привод"),
    BUR("БУР"),
    BKP("БКП"),

    // Оборудование для инженерного отсека
    SHTM("ШТМ"),
    FIRE_ALARM("Прибор пожаро-охранный"),
    SMOKE_DETECTOR("Извещатель дымовой"),
    MANUAL_DETECTOR("Извещатель ручной"),
    SIREN("Оповещатель свето-звуковой"),
    AIR_CONDITIONER("Кондиционер"),
    CONTROL_PANEL("ЩСУ"),

    // Оборудование для трансформаторного отсека
    // (используем те же извещатели, но с другим контекстом)

    // Дополнительное оборудование
    TEMP_TRANSDUCER("Преобразователь температуры"),
    UZR("УЗР"),
    LEVEL_METER("Уровнемер"),
    DGK("ДГК"),
    BKEP("БКЭП")
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\model\NodeType.kt ---
------------------------------------------------------------

package com.example.kipia.model

enum class NodeType(val displayName: String, val prefix: String) {
    PRESSURE_WELL("Колодец отбора давления", "ОД"),
    VENT_WELL("Вантузный колодец", "В"),
    VALVE("Задвижка", "Задвижка"),
    CUSTOM("Другой", "");

    companion object {
        fun fromString(value: String): NodeType {
            return values().find { it.name == value } ?: CUSTOM
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\model\PKU.kt ---
------------------------------------------------------------

package com.example.kipia.model

data class PKU(
    val id: Long = 0L, // ID для базы данных
    val name: String,   // например, "КП 867 км"
    val description: String = "", // описание, если нужно
    val isCompleted: Boolean = false // флаг, выполнена ли проверка
)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\model\SectionType.kt ---
------------------------------------------------------------

package com.example.kipia.model

enum class SectionType(val displayName: String) {
    ENGINEERING("Инженерный отсек"),
    TRANSFORMER("Трансформаторный отсек")
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\model\Tube.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/model/Tube.kt
package com.example.kipia.model

data class Tube(
    val id: Long = 0L,
    val name: String, // Например, "Сургут-Полоцк" или "Холмогоры-Клин"
    val pkuId: Long // Связь с PKU
)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\SplashActivity.kt ---
------------------------------------------------------------

package com.example.kipia

import android.content.Intent
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import androidx.appcompat.app.AppCompatActivity
import android.widget.VideoView

class SplashActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_splash)

        val videoView = findViewById<VideoView>(R.id.videoView)

        try {
            // Указываем путь к видео
            val videoPath = "android.resource://" + packageName + "/" + R.raw.splash_video
            videoView.setVideoPath(videoPath)

            // Обработчик завершения видео
            videoView.setOnCompletionListener {
                // Плавный переход на MainActivity
                startMainActivity()
            }

            // Обработчик ошибок видео
            videoView.setOnErrorListener { _, what, extra ->
                // Если видео не загружается, сразу переходим на MainActivity
                startMainActivity()
                true // обработали ошибку
            }

            // Запускаем видео
            videoView.start()

        } catch (e: Exception) {
            // Если возникла любая ошибка, переходим на MainActivity
            startMainActivity()
        }

        // Резервный таймер на случай если видео зависнет
        Handler(Looper.getMainLooper()).postDelayed({
            if (!isFinishing) {
                startMainActivity()
            }
        }, 10000) // 10 секунд максимум
    }

    private fun startMainActivity() {
        if (!isFinishing) {
            val intent = Intent(this, MainActivity::class.java)
            startActivity(intent)
            finish()

            // Плавная анимация перехода
            overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        // Очищаем ресурсы видео
        val videoView = findViewById<VideoView>(R.id.videoView)
        videoView.stopPlayback()
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\sync\ConflictResolver.kt ---
------------------------------------------------------------

package com.example.kipia.sync

import android.util.Log

object ConflictResolver {
    private const val TAG = "ConflictResolver"

    /**
     * Правила разрешения конфликтов для разных типов сущностей
     */
    fun <T> resolveConflict(
        local: T,
        remote: T,
        localTimestamp: Long,
        remoteTimestamp: Long
    ): T {
        return when {
            // Если удаленные данные новее - используем их
            remoteTimestamp > localTimestamp -> {
                Log.d(TAG, "Using remote data (newer timestamp)")
                remote
            }
            // Если локальные данные новее - используем их
            localTimestamp > remoteTimestamp -> {
                Log.d(TAG, "Using local data (newer timestamp)")
                local
            }
            // Если временные метки равны - используем более полные данные
            else -> resolveByDataCompleteness(local, remote)
        }
    }

    private fun <T> resolveByDataCompleteness(local: T, remote: T): T {
        val localCompleteness = calculateDataCompleteness(local)
        val remoteCompleteness = calculateDataCompleteness(remote)

        return if (remoteCompleteness > localCompleteness) {
            Log.d(TAG, "Using remote data (more complete)")
            remote
        } else {
            Log.d(TAG, "Using local data (more complete)")
            local
        }
    }

    private fun <T> calculateDataCompleteness(entity: T): Int {
        var completeness = 0

        when (entity) {
            is ControlPointSyncEntity -> {
                if (entity.name.isNotBlank()) completeness += 30
                if (entity.description.isNotBlank()) completeness += 20
            }
            is EquipmentSyncEntity -> {
                if (entity.name.isNotBlank()) completeness += 20
                if (entity.model.isNotBlank()) completeness += 15
                if (entity.serialNumber.isNotBlank()) completeness += 15
                if (entity.photoPaths.isNotBlank()) completeness += 10
            }
            is RemarkSyncEntity -> {
                if (entity.title.isNotBlank()) completeness += 25
                if (entity.description.isNotBlank()) completeness += 15
                if (entity.photos.isNotBlank()) completeness += 10
            }
            // Добавьте правила для других типов сущностей
        }

        return completeness
    }

    /**
     * Специальные правила для критических данных
     */
    fun resolveCriticalDataConflict(local: Any, remote: Any): Any {
        return when {
            // Для замечаний с высоким приоритетом всегда предпочитаем удаленные данные
            local is RemarkSyncEntity && remote is RemarkSyncEntity -> {
                if (remote.priority == "Высокий" && local.priority != "Высокий") {
                    Log.d(TAG, "Using remote remark data (high priority)")
                    remote
                } else if (local.priority == "Высокий" && remote.priority != "Высокий") {
                    Log.d(TAG, "Using local remark data (high priority)")
                    local
                } else {
                    resolveConflict(local, remote, local.lastModified, remote.lastModified)
                }
            }
            // Для завершенных событий предпочитаем данные, которые были завершены
            local is EventSyncEntity && remote is EventSyncEntity -> {
                if (remote.isCompleted && !local.isCompleted) {
                    Log.d(TAG, "Using remote event data (completed)")
                    remote
                } else if (local.isCompleted && !remote.isCompleted) {
                    Log.d(TAG, "Using local event data (completed)")
                    local
                } else {
                    resolveConflict(local, remote, local.lastModified, remote.lastModified)
                }
            }
            else -> resolveConflict(local, remote, 0, 0)
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\sync\DataMerger.kt ---
------------------------------------------------------------

package com.example.kipia.sync

import com.example.kipia.database.AppDatabase
import com.example.kipia.sync.EntityConverters.toEntity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

data class MergeResult(
    val controlPointsAdded: Int = 0,
    val controlPointsUpdated: Int = 0,
    val pkusAdded: Int = 0,
    val pkusUpdated: Int = 0,
    val tubesAdded: Int = 0,
    val tubesUpdated: Int = 0,
    val nodesAdded: Int = 0,
    val nodesUpdated: Int = 0,
    val sectionsAdded: Int = 0,
    val sectionsUpdated: Int = 0,
    val equipmentAdded: Int = 0,
    val equipmentUpdated: Int = 0,
    val detailedEquipmentAdded: Int = 0,
    val detailedEquipmentUpdated: Int = 0,
    val remarksAdded: Int = 0,
    val remarksUpdated: Int = 0,
    val eventsAdded: Int = 0,
    val eventsUpdated: Int = 0
) {
    fun plus(other: MergeResult): MergeResult {
        return MergeResult(
            controlPointsAdded = this.controlPointsAdded + other.controlPointsAdded,
            controlPointsUpdated = this.controlPointsUpdated + other.controlPointsUpdated,
            pkusAdded = this.pkusAdded + other.pkusAdded,
            pkusUpdated = this.pkusUpdated + other.pkusUpdated,
            tubesAdded = this.tubesAdded + other.tubesAdded,
            tubesUpdated = this.tubesUpdated + other.tubesUpdated,
            nodesAdded = this.nodesAdded + other.nodesAdded,
            nodesUpdated = this.nodesUpdated + other.nodesUpdated,
            sectionsAdded = this.sectionsAdded + other.sectionsAdded,
            sectionsUpdated = this.sectionsUpdated + other.sectionsUpdated,
            equipmentAdded = this.equipmentAdded + other.equipmentAdded,
            equipmentUpdated = this.equipmentUpdated + other.equipmentUpdated,
            detailedEquipmentAdded = this.detailedEquipmentAdded + other.detailedEquipmentAdded,
            detailedEquipmentUpdated = this.detailedEquipmentUpdated + other.detailedEquipmentUpdated,
            remarksAdded = this.remarksAdded + other.remarksAdded,
            remarksUpdated = this.remarksUpdated + other.remarksUpdated,
            eventsAdded = this.eventsAdded + other.eventsAdded,
            eventsUpdated = this.eventsUpdated + other.eventsUpdated
        )
    }
}
object DataMerger {

    suspend fun mergeData(database: AppDatabase, incoming: SyncEntities): MergeResult {
        return withContext(Dispatchers.IO) {
            var result = MergeResult()

            try {
                // Слияние ControlPoints (родительская сущность)
                result += mergeControlPoints(database, incoming.controlPoints)

                // Слияние PKUs
                result += mergePKUs(database, incoming.pkus)

                // Слияние Tubes
                result += mergeTubes(database, incoming.tubes)

                // Слияние Sections
                result += mergeSections(database, incoming.sections)

                // Слияние Nodes
                result += mergeNodes(database, incoming.nodes)

                // Слияние Equipment
                result += mergeEquipment(database, incoming.equipment)

                // Слияние DetailedEquipment
                result += mergeDetailedEquipment(database, incoming.detailedEquipment)

                // Слияние Remarks
                result += mergeRemarks(database, incoming.remarks)

                // Слияние Events
                result += mergeEvents(database, incoming.events)

            } catch (e: Exception) {
                throw e
            }

            result
        }
    }

    suspend fun mergeControlPoints(
        database: AppDatabase,
        incoming: List<ControlPointSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existing = database.controlPointDao().getAllControlPoints()
        val existingMap = existing.associateBy { it.id }

        for (incomingEntity in incoming) {
            val existingEntity = existingMap[incomingEntity.id]

            if (existingEntity == null) {
                // Новая сущность - добавляем
                database.controlPointDao().insert(incomingEntity.toEntity())
                added++
            } else {
                // Конфликт - применяем правила слияния
                if (shouldUpdate(existingEntity, incomingEntity)) {
                    database.controlPointDao().update(
                        incomingEntity.id,
                        incomingEntity.name,
                        incomingEntity.description
                    )
                    updated++
                }
            }
        }

        return MergeResult(controlPointsAdded = added, controlPointsUpdated = updated)
    }

    internal suspend fun mergePKUs(
        database: AppDatabase,
        incoming: List<PKUSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existing = database.pkuDao().getAllPKUs()
        val existingMap = existing.associateBy { it.id }

        for (incomingEntity in incoming) {
            val existingEntity = existingMap[incomingEntity.id]

            if (existingEntity == null) {
                database.pkuDao().insert(incomingEntity.toEntity())
                added++
            } else if (shouldUpdate(existingEntity, incomingEntity)) {
                database.pkuDao().update(
                    incomingEntity.id,
                    incomingEntity.name,
                    incomingEntity.description
                )
                updated++
            }
        }

        return MergeResult(pkusAdded = added, pkusUpdated = updated)
    }

    suspend fun mergeTubes(
        database: AppDatabase,
        incoming: List<TubeSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existing = database.tubeDao().getAllTubes()
        val existingMap = existing.associateBy { it.id }

        for (incomingEntity in incoming) {
            val existingEntity = existingMap[incomingEntity.id]

            if (existingEntity == null) {
                database.tubeDao().insert(incomingEntity.toEntity())
                added++
            } else if (shouldUpdate(existingEntity, incomingEntity)) {
                database.tubeDao().update(incomingEntity.id, incomingEntity.name)
                updated++
            }
        }

        return MergeResult(tubesAdded = added, tubesUpdated = updated)
    }

    internal suspend fun mergeNodes(
        database: AppDatabase,
        incoming: List<NodeSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existing = database.nodeDao().getAllNodes()
        val existingMap = existing.associateBy { it.id }

        for (incomingEntity in incoming) {
            val existingEntity = existingMap[incomingEntity.id]

            if (existingEntity == null) {
                database.nodeDao().insert(incomingEntity.toEntity())
                added++
            } else if (shouldUpdate(existingEntity, incomingEntity)) {
                database.nodeDao().update(incomingEntity.id, incomingEntity.name)
                updated++
            }
        }

        return MergeResult(nodesAdded = added, nodesUpdated = updated)
    }

    internal suspend fun mergeSections(
        database: AppDatabase,
        incoming: List<SectionSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existing = database.sectionDao().getAllSections()
        val existingMap = existing.associateBy { it.id }

        for (incomingEntity in incoming) {
            val existingEntity = existingMap[incomingEntity.id]

            if (existingEntity == null) {
                database.sectionDao().insert(incomingEntity.toEntity())
                added++
            } else if (shouldUpdate(existingEntity, incomingEntity)) {
                database.sectionDao().update(incomingEntity.toEntity())
                updated++
            }
        }

        return MergeResult(sectionsAdded = added, sectionsUpdated = updated)
    }

    internal suspend fun mergeEquipment(
        database: AppDatabase,
        incoming: List<EquipmentSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existing = database.equipmentDao().getAllEquipment()
        val existingMap = existing.associateBy { it.id }

        for (incomingEntity in incoming) {
            val existingEntity = existingMap[incomingEntity.id]

            if (existingEntity == null) {
                database.equipmentDao().insert(incomingEntity.toEntity())
                added++
            } else if (shouldUpdate(existingEntity, incomingEntity)) {
                database.equipmentDao().update(incomingEntity.toEntity())
                updated++
            }
        }

        return MergeResult(equipmentAdded = added, equipmentUpdated = updated)
    }

    internal suspend fun mergeDetailedEquipment(
        database: AppDatabase,
        incoming: List<DetailedEquipmentSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existing = database.detailedEquipmentDao().getAllDetailedEquipment()
        val existingMap = existing.associateBy { it.id }

        for (incomingEntity in incoming) {
            val existingEntity = existingMap[incomingEntity.id]

            if (existingEntity == null) {
                database.detailedEquipmentDao().insert(incomingEntity.toEntity())
                added++
            } else if (shouldUpdate(existingEntity, incomingEntity)) {
                database.detailedEquipmentDao().update(incomingEntity.toEntity())
                updated++
            }
        }

        return MergeResult(detailedEquipmentAdded = added, detailedEquipmentUpdated = updated)
    }

    internal suspend fun mergeRemarks(
        database: AppDatabase,
        incoming: List<RemarkSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existing = database.remarkDao().getAllRemarks()
        val existingMap = existing.associateBy { it.id }

        for (incomingEntity in incoming) {
            val existingEntity = existingMap[incomingEntity.id]

            if (existingEntity == null) {
                database.remarkDao().insert(incomingEntity.toEntity())
                added++
            } else if (shouldUpdate(existingEntity, incomingEntity)) {
                database.remarkDao().update(incomingEntity.toEntity())
                updated++
            }
        }

        return MergeResult(remarksAdded = added, remarksUpdated = updated)
    }

    internal suspend fun mergeEvents(
        database: AppDatabase,
        incoming: List<EventSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existing = database.eventDao().getAllEvents()
        val existingMap = existing.associateBy { it.id }

        for (incomingEntity in incoming) {
            val existingEntity = existingMap[incomingEntity.id]

            if (existingEntity == null) {
                database.eventDao().insert(incomingEntity.toEntity())
                added++
            } else if (shouldUpdate(existingEntity, incomingEntity)) {
                database.eventDao().update(incomingEntity.toEntity())
                updated++
            }
        }

        return MergeResult(eventsAdded = added, eventsUpdated = updated)
    }

    // Правила слияния: обновляем если входящие данные новее
    internal fun shouldUpdate(existing: Any, incoming: Any): Boolean {
        return when {
            existing is com.example.kipia.database.ControlPointEntity &&
                    incoming is ControlPointSyncEntity -> {
                // Простая логика - всегда обновляем для демонстрации
                true
            }
            // Добавьте другие типы сущностей по необходимости
            else -> true
        }
    }

    internal operator fun MergeResult.plus(other: MergeResult): MergeResult {
        return MergeResult(
            controlPointsAdded = this.controlPointsAdded + other.controlPointsAdded,
            controlPointsUpdated = this.controlPointsUpdated + other.controlPointsUpdated,
            pkusAdded = this.pkusAdded + other.pkusAdded,
            pkusUpdated = this.pkusUpdated + other.pkusUpdated,
            tubesAdded = this.tubesAdded + other.tubesAdded,
            tubesUpdated = this.tubesUpdated + other.tubesUpdated,
            nodesAdded = this.nodesAdded + other.nodesAdded,
            nodesUpdated = this.nodesUpdated + other.nodesUpdated,
            sectionsAdded = this.sectionsAdded + other.sectionsAdded,
            sectionsUpdated = this.sectionsUpdated + other.sectionsUpdated,
            equipmentAdded = this.equipmentAdded + other.equipmentAdded,
            equipmentUpdated = this.equipmentUpdated + other.equipmentUpdated,
            detailedEquipmentAdded = this.detailedEquipmentAdded + other.detailedEquipmentAdded,
            detailedEquipmentUpdated = this.detailedEquipmentUpdated + other.detailedEquipmentUpdated,
            remarksAdded = this.remarksAdded + other.remarksAdded,
            remarksUpdated = this.remarksUpdated + other.remarksUpdated,
            eventsAdded = this.eventsAdded + other.eventsAdded,
            eventsUpdated = this.eventsUpdated + other.eventsUpdated
        )
    }

}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\sync\EnhancedDataMerger.kt ---
------------------------------------------------------------

package com.example.kipia.sync

import android.util.Log
import com.example.kipia.database.AppDatabase
import com.example.kipia.sync.DataMerger.plus
import com.example.kipia.sync.EntityConverters.toEntity
import com.example.kipia.sync.EntityConverters.toSyncEntity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class EnhancedDataMerger {

    suspend fun mergeWithDependencies(database: AppDatabase, incoming: SyncEntities): MergeResult {
        return withContext(Dispatchers.IO) {
            var result = MergeResult()

            try {
                // Шаг 1: Валидация зависимостей
                validateDependencies(incoming)

                // Шаг 2: Слияние в правильном порядке с учетом зависимостей
                result = result.plus(mergeControlPointsWithDeps(database, incoming.controlPoints))
                result = result.plus(mergePKUsWithDeps(database, incoming.pkus, incoming.controlPoints))
                result = result.plus(mergeTubesWithDeps(database, incoming.tubes, incoming.controlPoints))
                result = result.plus(mergeSectionsWithDeps(database, incoming.sections, incoming.pkus))
                result = result.plus(mergeNodesWithDeps(database, incoming.nodes, incoming.tubes))
                result = result.plus(mergeEquipmentWithDeps(database, incoming.equipment, incoming.nodes, incoming.sections))
                result = result.plus(mergeDetailedEquipmentWithDeps(database, incoming.detailedEquipment, incoming.nodes, incoming.sections))
                result = result.plus(mergeRemarksWithDeps(database, incoming.remarks, incoming.controlPoints))
                result = result.plus(mergeEventsWithDeps(database, incoming.events, incoming.controlPoints))

            } catch (e: DependencyException) {
                Log.e("EnhancedDataMerger", "Dependency error during merge", e)
                throw e
            } catch (e: Exception) {
                Log.e("EnhancedDataMerger", "Unexpected error during merge", e)
                throw e
            }

            result
        }
    }

    private fun validateDependencies(incoming: SyncEntities) {
        // Проверяем, что все внешние ключи существуют
        incoming.pkus.forEach { pku ->
            if (incoming.controlPoints.none { it.id == pku.controlPointId }) {
                throw DependencyException("PKU ${pku.id} references non-existent ControlPoint ${pku.controlPointId}")
            }
        }

        incoming.tubes.forEach { tube ->
            if (incoming.controlPoints.none { it.id == tube.controlPointId }) {
                throw DependencyException("Tube ${tube.id} references non-existent ControlPoint ${tube.controlPointId}")
            }
        }

        incoming.nodes.forEach { node ->
            if (incoming.tubes.none { it.id == node.tubeId }) {
                throw DependencyException("Node ${node.id} references non-existent Tube ${node.tubeId}")
            }
        }

        incoming.sections.forEach { section ->
            if (incoming.pkus.none { it.id == section.pkuId }) {
                throw DependencyException("Section ${section.id} references non-existent PKU ${section.pkuId}")
            }
        }

        incoming.equipment.forEach { equipment ->
            if (equipment.nodeId != null && incoming.nodes.none { it.id == equipment.nodeId }) {
                throw DependencyException("Equipment ${equipment.id} references non-existent Node ${equipment.nodeId}")
            }
            if (equipment.sectionId != null && incoming.sections.none { it.id == equipment.sectionId }) {
                throw DependencyException("Equipment ${equipment.id} references non-existent Section ${equipment.sectionId}")
            }
        }

        incoming.detailedEquipment.forEach { equipment ->
            if (equipment.nodeId != null && incoming.nodes.none { it.id == equipment.nodeId }) {
                throw DependencyException("DetailedEquipment ${equipment.id} references non-existent Node ${equipment.nodeId}")
            }
            if (equipment.sectionId != null && incoming.sections.none { it.id == equipment.sectionId }) {
                throw DependencyException("DetailedEquipment ${equipment.id} references non-existent Section ${equipment.sectionId}")
            }
        }

        incoming.remarks.forEach { remark ->
            if (incoming.controlPoints.none { it.id == remark.controlPointId }) {
                throw DependencyException("Remark ${remark.id} references non-existent ControlPoint ${remark.controlPointId}")
            }
        }

        incoming.events.forEach { event ->
            if (incoming.controlPoints.none { it.id == event.controlPointId }) {
                throw DependencyException("Event ${event.id} references non-existent ControlPoint ${event.controlPointId}")
            }
        }
    }

    private suspend fun mergeControlPointsWithDeps(
        database: AppDatabase,
        incoming: List<ControlPointSyncEntity>
    ): MergeResult {
        // Базовая реализация слияния
        return DataMerger.mergeControlPoints(database, incoming)
    }

    private suspend fun mergePKUsWithDeps(
        database: AppDatabase,
        incomingPKUs: List<PKUSyncEntity>,
        incomingControlPoints: List<ControlPointSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existingPKUs = database.pkuDao().getAllPKUs()
        val existingMap = existingPKUs.associateBy { it.id }

        for (incomingPKU in incomingPKUs) {
            // Проверяем, что ControlPoint существует
            if (incomingControlPoints.any { it.id == incomingPKU.controlPointId }) {
                val existingPKU = existingMap[incomingPKU.id]

                if (existingPKU == null) {
                    database.pkuDao().insert(incomingPKU.toEntity())
                    added++
                } else {
                    val resolvedEntity = ConflictResolver.resolveConflict(
                        existingPKU.toSyncEntity("local"),
                        incomingPKU,
                        System.currentTimeMillis(), // В реальности нужно хранить timestamp
                        incomingPKU.lastModified
                    ).toEntity()

                    database.pkuDao().update(
                        resolvedEntity.id,
                        resolvedEntity.name,
                        resolvedEntity.description
                    )
                    updated++
                }
            } else {
                Log.w("EnhancedDataMerger", "Skipping PKU ${incomingPKU.id} - ControlPoint ${incomingPKU.controlPointId} not found")
            }
        }

        return MergeResult(pkusAdded = added, pkusUpdated = updated)
    }

    private suspend fun mergeTubesWithDeps(
        database: AppDatabase,
        incomingTubes: List<TubeSyncEntity>,
        incomingControlPoints: List<ControlPointSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existingTubes = database.tubeDao().getAllTubes()
        val existingMap = existingTubes.associateBy { it.id }

        for (incomingTube in incomingTubes) {
            // Проверяем, что ControlPoint существует
            if (incomingControlPoints.any { it.id == incomingTube.controlPointId }) {
                val existingTube = existingMap[incomingTube.id]

                if (existingTube == null) {
                    database.tubeDao().insert(incomingTube.toEntity())
                    added++
                } else {
                    val resolvedEntity = ConflictResolver.resolveConflict(
                        existingTube.toSyncEntity("local"),
                        incomingTube,
                        System.currentTimeMillis(),
                        incomingTube.lastModified
                    ).toEntity()

                    database.tubeDao().update(resolvedEntity.id, resolvedEntity.name)
                    updated++
                }
            } else {
                Log.w("EnhancedDataMerger", "Skipping Tube ${incomingTube.id} - ControlPoint ${incomingTube.controlPointId} not found")
            }
        }

        return MergeResult(tubesAdded = added, tubesUpdated = updated)
    }

    private suspend fun mergeSectionsWithDeps(
        database: AppDatabase,
        incomingSections: List<SectionSyncEntity>,
        incomingPKUs: List<PKUSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existingSections = database.sectionDao().getAllSections()
        val existingMap = existingSections.associateBy { it.id }

        for (incomingSection in incomingSections) {
            // Проверяем, что PKU существует
            if (incomingPKUs.any { it.id == incomingSection.pkuId }) {
                val existingSection = existingMap[incomingSection.id]

                if (existingSection == null) {
                    database.sectionDao().insert(incomingSection.toEntity())
                    added++
                } else {
                    val resolvedEntity = ConflictResolver.resolveConflict(
                        existingSection.toSyncEntity("local"),
                        incomingSection,
                        System.currentTimeMillis(),
                        incomingSection.lastModified
                    ).toEntity()

                    database.sectionDao().update(resolvedEntity)
                    updated++
                }
            } else {
                Log.w("EnhancedDataMerger", "Skipping Section ${incomingSection.id} - PKU ${incomingSection.pkuId} not found")
            }
        }

        return MergeResult(sectionsAdded = added, sectionsUpdated = updated)
    }

    private suspend fun mergeNodesWithDeps(
        database: AppDatabase,
        incomingNodes: List<NodeSyncEntity>,
        incomingTubes: List<TubeSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existingNodes = database.nodeDao().getAllNodes()
        val existingMap = existingNodes.associateBy { it.id }

        for (incomingNode in incomingNodes) {
            // Проверяем, что Tube существует
            if (incomingTubes.any { it.id == incomingNode.tubeId }) {
                val existingNode = existingMap[incomingNode.id]

                if (existingNode == null) {
                    database.nodeDao().insert(incomingNode.toEntity())
                    added++
                } else {
                    val resolvedEntity = ConflictResolver.resolveConflict(
                        existingNode.toSyncEntity("local"),
                        incomingNode,
                        System.currentTimeMillis(),
                        incomingNode.lastModified
                    ).toEntity()

                    database.nodeDao().update(resolvedEntity.id, resolvedEntity.name)
                    updated++
                }
            } else {
                Log.w("EnhancedDataMerger", "Skipping Node ${incomingNode.id} - Tube ${incomingNode.tubeId} not found")
            }
        }

        return MergeResult(nodesAdded = added, nodesUpdated = updated)
    }

    private suspend fun mergeEquipmentWithDeps(
        database: AppDatabase,
        incomingEquipment: List<EquipmentSyncEntity>,
        incomingNodes: List<NodeSyncEntity>,
        incomingSections: List<SectionSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existingEquipment = database.equipmentDao().getAllEquipment()
        val existingMap = existingEquipment.associateBy { it.id }

        for (incomingEq in incomingEquipment) {
            // Проверяем зависимости
            val nodeExists = incomingEq.nodeId == null || incomingNodes.any { it.id == incomingEq.nodeId }
            val sectionExists = incomingEq.sectionId == null || incomingSections.any { it.id == incomingEq.sectionId }

            if (nodeExists && sectionExists) {
                val existingEq = existingMap[incomingEq.id]

                if (existingEq == null) {
                    database.equipmentDao().insert(incomingEq.toEntity())
                    added++
                } else {
                    val resolvedEntity = ConflictResolver.resolveConflict(
                        existingEq.toSyncEntity("local"),
                        incomingEq,
                        System.currentTimeMillis(),
                        incomingEq.lastModified
                    ).toEntity()

                    database.equipmentDao().update(resolvedEntity)
                    updated++
                }
            } else {
                Log.w("EnhancedDataMerger", "Skipping Equipment ${incomingEq.id} - dependencies not found")
            }
        }

        return MergeResult(equipmentAdded = added, equipmentUpdated = updated)
    }

    private suspend fun mergeDetailedEquipmentWithDeps(
        database: AppDatabase,
        incomingEquipment: List<DetailedEquipmentSyncEntity>,
        incomingNodes: List<NodeSyncEntity>,
        incomingSections: List<SectionSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existingEquipment = database.detailedEquipmentDao().getAllDetailedEquipment()
        val existingMap = existingEquipment.associateBy { it.id }

        for (incomingEq in incomingEquipment) {
            // Проверяем зависимости
            val nodeExists = incomingEq.nodeId == null || incomingNodes.any { it.id == incomingEq.nodeId }
            val sectionExists = incomingEq.sectionId == null || incomingSections.any { it.id == incomingEq.sectionId }

            if (nodeExists && sectionExists) {
                val existingEq = existingMap[incomingEq.id]

                if (existingEq == null) {
                    database.detailedEquipmentDao().insert(incomingEq.toEntity())
                    added++
                } else {
                    val resolvedEntity = ConflictResolver.resolveConflict(
                        existingEq.toSyncEntity("local"),
                        incomingEq,
                        System.currentTimeMillis(),
                        incomingEq.lastModified
                    ).toEntity()

                    database.detailedEquipmentDao().update(resolvedEntity)
                    updated++
                }
            } else {
                Log.w("EnhancedDataMerger", "Skipping DetailedEquipment ${incomingEq.id} - dependencies not found")
            }
        }

        return MergeResult(detailedEquipmentAdded = added, detailedEquipmentUpdated = updated)
    }

    private suspend fun mergeRemarksWithDeps(
        database: AppDatabase,
        incomingRemarks: List<RemarkSyncEntity>,
        incomingControlPoints: List<ControlPointSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existingRemarks = database.remarkDao().getAllRemarks()
        val existingMap = existingRemarks.associateBy { it.id }

        for (incomingRemark in incomingRemarks) {
            // Проверяем, что ControlPoint существует
            if (incomingControlPoints.any { it.id == incomingRemark.controlPointId }) {
                val existingRemark = existingMap[incomingRemark.id]

                if (existingRemark == null) {
                    database.remarkDao().insert(incomingRemark.toEntity())
                    added++
                } else {
                    val resolvedEntity = when {
                        existingRemark is com.example.kipia.database.RemarkEntity &&
                                incomingRemark is RemarkSyncEntity -> {
                            val localSync = existingRemark.toSyncEntity("local")
                            ConflictResolver.resolveCriticalDataConflict(localSync, incomingRemark) as RemarkSyncEntity
                        }
                        else -> incomingRemark
                    }.toEntity()

                    database.remarkDao().update(resolvedEntity)
                    updated++
                }
            } else {
                Log.w("EnhancedDataMerger", "Skipping Remark ${incomingRemark.id} - ControlPoint ${incomingRemark.controlPointId} not found")
            }
        }

        return MergeResult(remarksAdded = added, remarksUpdated = updated)
    }

    private suspend fun mergeEventsWithDeps(
        database: AppDatabase,
        incomingEvents: List<EventSyncEntity>,
        incomingControlPoints: List<ControlPointSyncEntity>
    ): MergeResult {
        var added = 0
        var updated = 0

        val existingEvents = database.eventDao().getAllEvents()
        val existingMap = existingEvents.associateBy { it.id }

        for (incomingEvent in incomingEvents) {
            // Проверяем, что ControlPoint существует
            if (incomingControlPoints.any { it.id == incomingEvent.controlPointId }) {
                val existingEvent = existingMap[incomingEvent.id]

                if (existingEvent == null) {
                    database.eventDao().insert(incomingEvent.toEntity())
                    added++
                } else {
                    val resolvedEntity = when {
                        existingEvent is com.example.kipia.database.EventEntity &&
                                incomingEvent is EventSyncEntity -> {
                            val localSync = existingEvent.toSyncEntity("local")
                            ConflictResolver.resolveCriticalDataConflict(localSync, incomingEvent) as EventSyncEntity
                        }
                        else -> incomingEvent
                    }.toEntity()
                    database.eventDao().update(resolvedEntity)
                    updated++
                }
            } else {
                Log.w("EnhancedDataMerger", "Skipping Event ${incomingEvent.id} - ControlPoint ${incomingEvent.controlPointId} not found")
            }
        }

        return MergeResult(eventsAdded = added, eventsUpdated = updated)
    }
}

class DependencyException(message: String) : Exception(message)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\sync\EnhancedSyncManager.kt ---
------------------------------------------------------------

package com.example.kipia.sync

import android.content.Context
import android.util.Log
import com.example.kipia.data.PreferencesManager
import com.example.kipia.database.AppDatabase
import com.example.kipia.sync.EntityConverters.toSyncEntity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import java.io.File

object EnhancedSyncManager {
    private const val TAG = "EnhancedSyncManager"
    private val json = Json { ignoreUnknownKeys = true }

    suspend fun prepareCompleteSyncPackage(context: Context): SyncPackage {
        return withContext(Dispatchers.IO) {
            try {
                val database = AppDatabase.getInstance(context)
                val prefs = PreferencesManager(context)
                val deviceId = prefs.deviceId.first()

                // Собираем все сущности
                val controlPoints = database.controlPointDao().getAllControlPoints()
                    .map { it.toSyncEntity(deviceId) }

                val pkus = database.pkuDao().getAllPKUs()
                    .map { it.toSyncEntity(deviceId) }

                val tubes = database.tubeDao().getAllTubes()
                    .map { it.toSyncEntity(deviceId) }

                val nodes = database.nodeDao().getAllNodes()
                    .map { it.toSyncEntity(deviceId) }

                val sections = database.sectionDao().getAllSections()
                    .map { it.toSyncEntity(deviceId) }

                val equipment = database.equipmentDao().getAllEquipment()
                    .map { it.toSyncEntity(deviceId) }

                val detailedEquipment = database.detailedEquipmentDao().getAllDetailedEquipment()
                    .map { it.toSyncEntity(deviceId) }

                val remarks = database.remarkDao().getAllRemarks()
                    .map { it.toSyncEntity(deviceId) }

                val events = database.eventDao().getAllEvents()
                    .map { it.toSyncEntity(deviceId) }

                val syncEntities = SyncEntities(
                    controlPoints = controlPoints,
                    pkus = pkus,
                    tubes = tubes,
                    nodes = nodes,
                    sections = sections,
                    equipment = equipment,
                    detailedEquipment = detailedEquipment,
                    remarks = remarks,
                    events = events
                )

                // Собираем вложения (фотографии)
                val fileAttachments = buildList<FileAttachment> { // Явно указываем тип
                    addAll(equipment.flatMap { PhotoSyncUtils.extractPhotosFromEntity(context, it) })
                    addAll(detailedEquipment.flatMap { PhotoSyncUtils.extractPhotosFromEntity(context, it) })
                    addAll(remarks.flatMap { PhotoSyncUtils.extractPhotosFromEntity(context, it) })
                }

                SyncPackage(
                    deviceId = deviceId,
                    timestamp = System.currentTimeMillis(),
                    entities = syncEntities,
                    fileAttachments = fileAttachments
                )

            } catch (e: Exception) {
                Log.e(TAG, "Error preparing complete sync package", e)
                throw e
            }
        }
    }

    suspend fun processCompleteSyncPackage(context: Context, syncPackage: SyncPackage) {
        withContext(Dispatchers.IO) {
            try {
                Log.d(TAG, "Processing complete sync package from device: ${syncPackage.deviceId}")

                // Восстанавливаем фотографии
                val restoredPhotos = PhotoSyncUtils.restorePhotosFromAttachments(
                    context,
                    syncPackage.fileAttachments
                )

                // Обновляем сущности с восстановленными путями к фотографиям
                val updatedEntities = PhotoSyncUtils.updateEntitiesWithRestoredPhotos(
                    syncPackage.entities,
                    restoredPhotos
                )

                // Выполняем слияние с улучшенным менеджером
                val database = AppDatabase.getInstance(context)
                val merger = EnhancedDataMerger()
                val mergeResult = merger.mergeWithDependencies(database, updatedEntities)

                // Обновляем timestamp последней синхронизации
                PreferencesManager(context).setLastSyncTimestamp(System.currentTimeMillis())

                Log.d(TAG, "Enhanced sync completed. Results: $mergeResult")
                Log.d(TAG, "Restored ${restoredPhotos.size} photo sets")

            } catch (e: Exception) {
                Log.e(TAG, "Error processing complete sync package", e)
                throw e
            }
        }
    }

    suspend fun exportSyncDataToFile(context: Context, filePath: String): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val syncPackage = prepareCompleteSyncPackage(context)
                val jsonData = json.encodeToString(syncPackage)

                File(filePath).writeText(jsonData)
                Log.d(TAG, "Sync data exported to: $filePath")
                true
            } catch (e: Exception) {
                Log.e(TAG, "Error exporting sync data", e)
                false
            }
        }
    }

    suspend fun importSyncDataFromFile(context: Context, filePath: String): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val jsonData = File(filePath).readText()
                val syncPackage = json.decodeFromString<SyncPackage>(jsonData)

                processCompleteSyncPackage(context, syncPackage)
                Log.d(TAG, "Sync data imported from: $filePath")
                true
            } catch (e: Exception) {
                Log.e(TAG, "Error importing sync data", e)
                false
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\sync\NearbySyncService.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/sync/NearbySyncService.kt
package com.example.kipia.sync

import android.app.Service
import android.content.Intent
import android.os.IBinder
import android.util.Log
import com.google.android.gms.nearby.Nearby
import com.google.android.gms.nearby.connection.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.json.JSONObject
import java.util.logging.Handler

class NearbySyncService : Service() {
    private val TAG = "NearbySyncService"

    private lateinit var connectionsClient: ConnectionsClient
    private var currentEndpointId: String? = null
    private val coroutineScope = CoroutineScope(Dispatchers.IO)

    companion object {
        const val SERVICE_ID = "com.example.kipia.sync"
        const val MESSAGE_TYPE_SYNC_REQUEST = "sync_request"
        const val MESSAGE_TYPE_SYNC_DATA = "sync_data"
        const val ACTION_SYNC_UPDATE = "com.example.kipia.SYNC_UPDATE"
        const val EXTRA_SYNC_STATE = "sync_state"
        const val EXTRA_CONNECTED_DEVICES = "connected_devices"
        const val EXTRA_ERROR = "error"
    }



    private var connectionTimeoutHandler = android.os.Handler()
    private val CONNECTION_TIMEOUT = 30000L // 30 секунд

    private fun startConnectionTimeout() {
        connectionTimeoutHandler.removeCallbacksAndMessages(null)
        connectionTimeoutHandler.postDelayed({
            if (currentEndpointId == null) {
                Log.w(TAG, "⏰ Таймаут соединения - перезапускаем поиск")
                restartDiscovery()
            }
        }, CONNECTION_TIMEOUT)
    }

    private fun restartDiscovery() {
        Log.d(TAG, "🔄 Перезапуск discovery...")
        connectionsClient.stopDiscovery()
        connectionsClient.stopAdvertising()

        android.os.Handler(mainLooper).postDelayed({
            startAdvertising()
            startDiscovery()
        }, 2000)
    }

// Вызывайте startConnectionTimeout() после начала discovery

    // Добавьте в NearbySyncService.kt
    private fun checkGooglePlayServices(): Boolean {
        return try {
            val availability = com.google.android.gms.common.GoogleApiAvailability.getInstance()
                .isGooglePlayServicesAvailable(this)
            if (availability == com.google.android.gms.common.ConnectionResult.SUCCESS) {
                Log.d(TAG, "✅ Google Play Services доступны")
                true
            } else {
                Log.e(TAG, "❌ Google Play Services недоступны: $availability")
                false
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Ошибка проверки Google Play Services", e)
            false
        }
    }

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "🟡 NearbySyncService создан")

        if (!checkGooglePlayServices()) {
            updateSyncState(error = "Google Play Services недоступны")
            return
        }

        connectionsClient = Nearby.getConnectionsClient(this)
        startAdvertising()
        startDiscovery()
    }
    override fun onBind(intent: Intent?): IBinder? = null

    private fun startAdvertising() {
        Log.d(TAG, "🟡 Начинаем advertising...")

        val advertisingOptions = AdvertisingOptions.Builder()
            .setStrategy(Strategy.P2P_CLUSTER)
            .build()

        connectionsClient.startAdvertising(
            "KIPiA_${System.currentTimeMillis()}",
            SERVICE_ID,
            connectionLifecycleCallback,
            advertisingOptions
        ).addOnSuccessListener {
            Log.d(TAG, "✅ Advertising запущен успешно")
            updateSyncState(isAdvertising = true)
        }.addOnFailureListener { exception ->
            Log.e(TAG, "❌ Ошибка запуска advertising", exception)
            // Пробуем еще раз через 5 секунд
            android.os.Handler(mainLooper).postDelayed({
                startAdvertising()
            }, 5000)
        }
    }

    private fun startDiscovery() {
        Log.d(TAG, "🟡 Начинаем discovery...")

        val discoveryOptions = DiscoveryOptions.Builder()
            .setStrategy(Strategy.P2P_CLUSTER)
            .build()

        connectionsClient.startDiscovery(
            SERVICE_ID,
            endpointDiscoveryCallback,
            discoveryOptions
        ).addOnSuccessListener {
            Log.d(TAG, "✅ Discovery запущен успешно")
            updateSyncState(isDiscovering = true)
        }.addOnFailureListener { exception ->
            Log.e(TAG, "❌ Ошибка запуска discovery", exception)
            // Пробуем еще раз через 5 секунд
            android.os.Handler(mainLooper).postDelayed({
                startDiscovery()
            }, 5000)
        }
    }
    private val connectionLifecycleCallback = object : ConnectionLifecycleCallback() {
        override fun onConnectionInitiated(endpointId: String, connectionInfo: ConnectionInfo) {
            Log.d(TAG, "🟡 Соединение инициировано с: ${connectionInfo.endpointName}")
            Log.d(TAG, "🟡 Authentication Token: ${connectionInfo.authenticationToken}")
            Log.d(TAG, "🟡 Is Incoming: ${connectionInfo.isIncomingConnection}")

            // Всегда принимаем входящие соединения
            connectionsClient.acceptConnection(endpointId, payloadCallback)
            Log.d(TAG, "✅ Соединение принято")
        }

        override fun onConnectionResult(endpointId: String, result: ConnectionResolution) {
            Log.d(TAG, "🟡 Результат соединения: ${result.status.statusCode}")

            when (result.status.statusCode) {
                ConnectionsStatusCodes.STATUS_OK -> {
                    Log.d(TAG, "✅ Соединение установлено с: $endpointId")
                    currentEndpointId = endpointId
                    updateSyncState(connectedDevices = listOf(endpointId))

                    // Ждем немного перед отправкой запроса
                    coroutineScope.launch {
                        kotlinx.coroutines.delay(1000)
                        sendSyncRequest(endpointId)
                    }
                }
                ConnectionsStatusCodes.STATUS_CONNECTION_REJECTED -> {
                    Log.w(TAG, "⚠️ Соединение отклонено: $endpointId")
                    currentEndpointId = null
                }
                ConnectionsStatusCodes.STATUS_ERROR -> {
                    Log.e(TAG, "❌ Ошибка соединения: $endpointId")
                    currentEndpointId = null
                }
                else -> {
                    Log.w(TAG, "❓ Неизвестный статус: ${result.status.statusCode}")
                }
            }
        }

        override fun onDisconnected(endpointId: String) {
            Log.d(TAG, "🔴 Отключено от: $endpointId")
            currentEndpointId = null
            updateSyncState(connectedDevices = emptyList())
        }
    }
    private val endpointDiscoveryCallback = object : EndpointDiscoveryCallback() {
        override fun onEndpointFound(endpointId: String, info: DiscoveredEndpointInfo) {
            Log.d(TAG, "🔍 Найдено устройство: ${info.endpointName} (ID: $endpointId)")

            // Проверяем, не пытаемся ли мы уже подключиться к этому устройству
            if (currentEndpointId == endpointId) {
                Log.d(TAG, "⚠️ Уже подключаемся к этому устройству")
                return
            }

            // Автоматически подключаемся к найденному устройству
            connectionsClient.requestConnection(
                "KIPiA_${System.currentTimeMillis()}",
                endpointId,
                connectionLifecycleCallback
            ).addOnSuccessListener {
                Log.d(TAG, "✅ Запрос на подключение отправлен к: ${info.endpointName}")
            }.addOnFailureListener { exception ->
                Log.e(TAG, "❌ Ошибка запроса подключения", exception)
            }
        }

        override fun onEndpointLost(endpointId: String) {
            Log.d(TAG, "🔍 Устройство потеряно: $endpointId")
        }
    }
    private val payloadCallback = object : PayloadCallback() {
        override fun onPayloadReceived(endpointId: String, payload: Payload) {
            when (payload.type) {
                Payload.Type.BYTES -> {
                    val message = String(payload.asBytes()!!)
                    Log.d(TAG, "📨 Получено сообщение: $message")
                    handleMessage(endpointId, message)
                }
                Payload.Type.FILE -> {
                    Log.d(TAG, "📁 Получен файл")
                    handleFilePayload(endpointId, payload)
                }
                else -> {
                    Log.d(TAG, "❓ Неизвестный тип payload: ${payload.type}")
                }
            }
        }

        override fun onPayloadTransferUpdate(endpointId: String, update: PayloadTransferUpdate) {
            when (update.status) {
                PayloadTransferUpdate.Status.SUCCESS -> {
                    Log.d(TAG, "✅ Передача данных успешна")
                }
                PayloadTransferUpdate.Status.FAILURE -> {
                    Log.e(TAG, "❌ Ошибка передачи данных")
                }
                PayloadTransferUpdate.Status.IN_PROGRESS -> {
                    Log.d(TAG, "📊 Передача в процессе: ${update.bytesTransferred}/${update.totalBytes}")
                }
            }
        }
    }



    private fun handleMessage(endpointId: String, message: String) {
        try {
            val json = JSONObject(message)
            val type = json.getString("type")

            when (type) {
                MESSAGE_TYPE_SYNC_REQUEST -> {
                    Log.d(TAG, "🔄 Получен запрос синхронизации")
                    coroutineScope.launch {
                        sendSyncData(endpointId)
                    }
                }
                MESSAGE_TYPE_SYNC_DATA -> {
                    Log.d(TAG, "📦 Получены данные синхронизации")
                    val data = json.getString("data")
                    coroutineScope.launch {
                        SyncManager.processIncomingSyncData(this@NearbySyncService, data)
                    }
                }
                else -> {
                    Log.w(TAG, "❓ Неизвестный тип сообщения: $type")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Ошибка обработки сообщения", e)
        }
    }

    private fun handleFilePayload(endpointId: String, payload: Payload) {
        Log.d(TAG, "📁 Обработка файлового payload")
        // Пока просто логируем
    }

    private fun sendSyncRequest(endpointId: String) {
        try {
            val message = JSONObject().apply {
                put("type", MESSAGE_TYPE_SYNC_REQUEST)
                put("timestamp", System.currentTimeMillis())
                put("deviceName", "KIPiA Device")
            }.toString()

            val payload = Payload.fromBytes(message.toByteArray())
            connectionsClient.sendPayload(endpointId, payload)
            Log.d(TAG, "📤 Отправлен запрос синхронизации")
        } catch (e: Exception) {
            Log.e(TAG, "❌ Ошибка отправки запроса", e)
        }
    }

    private suspend fun sendSyncData(endpointId: String) {
        try {
            val syncData = SyncManager.prepareSyncData(this)
            val message = JSONObject().apply {
                put("type", MESSAGE_TYPE_SYNC_DATA)
                put("data", syncData)
                put("timestamp", System.currentTimeMillis())
            }.toString()

            val payload = Payload.fromBytes(message.toByteArray())
            connectionsClient.sendPayload(endpointId, payload)
            Log.d(TAG, "📤 Отправлены данные синхронизации")
        } catch (e: Exception) {
            Log.e(TAG, "❌ Ошибка отправки данных", e)
        }
    }


    // В NearbySyncService.kt обновите метод updateSyncState:
    private fun updateSyncState(
        isAdvertising: Boolean? = null,
        isDiscovering: Boolean? = null,
        connectedDevices: List<String>? = null,
        error: String? = null
    ) {
        android.util.Log.d(TAG, "🔄 Обновление состояния: advertising=$isAdvertising, discovering=$isDiscovering, devices=${connectedDevices?.size}, error=$error")

        val intent = Intent(ACTION_SYNC_UPDATE).apply {
            isAdvertising?.let { putExtra("is_advertising", it) }
            isDiscovering?.let { putExtra("is_discovering", it) }
            connectedDevices?.let { putExtra("connected_devices", it.toTypedArray()) }
            error?.let { putExtra("error", it) }
        }

        try {
            sendBroadcast(intent)
        } catch (e: Exception) {
            android.util.Log.e(TAG, "❌ Ошибка отправки broadcast", e)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        connectionsClient.stopAllEndpoints()
        Log.d(TAG, "🔴 NearbySyncService уничтожен")
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\sync\PhotoSyncUtils.kt ---
------------------------------------------------------------

package com.example.kipia.sync

import android.content.Context
import android.net.Uri
import android.util.Base64
import android.util.Log
import com.example.kipia.utils.PhotoStorageUtils
import java.io.File
import java.io.FileOutputStream

object PhotoSyncUtils {
    private const val TAG = "PhotoSyncUtils"

    /**
     * Извлекает фотографии из сущности и подготавливает их для синхронизации
     */
    suspend fun extractPhotosFromEntity(
        context: Context,
        entity: Any
    ): List<FileAttachment> {
        return when (entity) {
            is EquipmentSyncEntity -> extractEquipmentPhotos(context, entity)
            is DetailedEquipmentSyncEntity -> extractDetailedEquipmentPhotos(context, entity)
            is RemarkSyncEntity -> extractRemarkPhotos(context, entity)
            else -> emptyList()
        }
    }

    private suspend fun extractEquipmentPhotos(
        context: Context,
        equipment: EquipmentSyncEntity
    ): List<FileAttachment> {
        return extractPhotosFromPaths(
            context,
            equipment.photoPaths,
            "Equipment",
            equipment.id,
            "photoPaths"
        )
    }

    private suspend fun extractDetailedEquipmentPhotos(
        context: Context,
        equipment: DetailedEquipmentSyncEntity
    ): List<FileAttachment> {
        return extractPhotosFromPaths(
            context,
            equipment.photoPaths,
            "DetailedEquipment",
            equipment.id,
            "photoPaths"
        )
    }

    private suspend fun extractRemarkPhotos(
        context: Context,
        remark: RemarkSyncEntity
    ): List<FileAttachment> {
        return extractPhotosFromPaths(
            context,
            remark.photos,
            "Remark",
            remark.id,
            "photos"
        )
    }

    private suspend fun extractPhotosFromPaths(
        context: Context,
        photoPaths: String,
        entityType: String,
        entityId: Long,
        fieldName: String
    ): List<FileAttachment> {
        if (photoPaths.isBlank()) return emptyList()

        val attachments = mutableListOf<FileAttachment>()
        val paths = photoPaths.split(",").filter { it.isNotBlank() }

        paths.forEachIndexed { index, path ->
            try {
                val file = File(path)
                if (file.exists()) {
                    val fileData = file.readBytes()
                    val base64Data = Base64.encodeToString(fileData, Base64.DEFAULT)

                    val attachment = FileAttachment(
                        entityType = entityType,
                        entityId = entityId,
                        fieldName = fieldName,
                        fileName = "${entityType}_${entityId}_photo_$index.jpg",
                        fileData = base64Data
                    )

                    attachments.add(attachment)
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error extracting photo from path: $path", e)
            }
        }

        return attachments
    }

    /**
     * Восстанавливает фотографии из FileAttachment и сохраняет их
     */
    suspend fun restorePhotosFromAttachments(
        context: Context,
        attachments: List<FileAttachment>
    ): Map<String, String> {
        val results = mutableMapOf<String, String>()

        attachments.groupBy { "${it.entityType}_${it.entityId}_${it.fieldName}" }
            .forEach { (key, groupAttachments) ->
                val photoPaths = groupAttachments.mapNotNull { attachment ->
                    try {
                        val fileData = Base64.decode(attachment.fileData, Base64.DEFAULT)
                        val tempFile = File.createTempFile("sync_photo_", ".jpg", context.cacheDir)

                        FileOutputStream(tempFile).use { fos ->
                            fos.write(fileData)
                        }

                        // Копируем в постоянное хранилище
                        val permanentPath = PhotoStorageUtils.copyPhotoToAppStorage(
                            context,
                            Uri.fromFile(tempFile)
                        )

                        // Удаляем временный файл
                        tempFile.delete()

                        permanentPath
                    } catch (e: Exception) {
                        Log.e(TAG, "Error restoring photo from attachment", e)
                        null
                    }
                }

                if (photoPaths.isNotEmpty()) {
                    results[key] = photoPaths.joinToString(",")
                }
            }

        return results
    }

    /**
     * Обновляет сущности с восстановленными путями к фотографиям
     */
    fun updateEntitiesWithRestoredPhotos(
        entities: SyncEntities,
        restoredPhotos: Map<String, String>
    ): SyncEntities {
        return entities.copy(
            equipment = entities.equipment.map { equipment ->
                val key = "Equipment_${equipment.id}_photoPaths"
                restoredPhotos[key]?.let { newPhotoPaths ->
                    equipment.copy(photoPaths = newPhotoPaths)
                } ?: equipment
            },
            detailedEquipment = entities.detailedEquipment.map { equipment ->
                val key = "DetailedEquipment_${equipment.id}_photoPaths"
                restoredPhotos[key]?.let { newPhotoPaths ->
                    equipment.copy(photoPaths = newPhotoPaths)
                } ?: equipment
            },
            remarks = entities.remarks.map { remark ->
                val key = "Remark_${remark.id}_photos"
                restoredPhotos[key]?.let { newPhotos ->
                    remark.copy(photos = newPhotos)
                } ?: remark
            }
        )
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\sync\SyncManager.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/sync/SyncManager.kt
package com.example.kipia.sync

import android.content.Context
import android.util.Log
import com.example.kipia.data.PreferencesManager
import com.example.kipia.database.AppDatabase
import com.example.kipia.sync.EntityConverters.toSyncEntity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json

object SyncManager {
    private const val TAG = "SyncManager"
    private val json = Json { ignoreUnknownKeys = true }

    suspend fun prepareSyncData(context: Context): String {
        return withContext(Dispatchers.IO) {
            try {
                Log.d(TAG, "🔄 Подготовка данных для синхронизации...")

                val database = AppDatabase.getInstance(context)
                val prefs = PreferencesManager(context)
                val deviceId = prefs.deviceId.first()

                // Собираем ВСЕ данные из всех таблиц
                val controlPoints = database.controlPointDao().getAllControlPoints()
                val pkus = database.pkuDao().getAllPKUs()
                val tubes = database.tubeDao().getAllTubes()
                val nodes = database.nodeDao().getAllNodes()
                val sections = database.sectionDao().getAllSections()
                val equipment = database.equipmentDao().getAllEquipment()
                val detailedEquipment = database.detailedEquipmentDao().getAllDetailedEquipment()
                val remarks = database.remarkDao().getAllRemarks()
                val events = database.eventDao().getAllEvents()

                Log.d(TAG, "📊 Статистика данных:")
                Log.d(TAG, "  • Контрольные точки: ${controlPoints.size}")
                Log.d(TAG, "  • ПКУ: ${pkus.size}")
                Log.d(TAG, "  • Трубы: ${tubes.size}")
                Log.d(TAG, "  • Узлы: ${nodes.size}")
                Log.d(TAG, "  • Отсеки: ${sections.size}")
                Log.d(TAG, "  • Оборудование: ${equipment.size}")
                Log.d(TAG, "  • Детальное оборудование: ${detailedEquipment.size}")
                Log.d(TAG, "  • Замечания: ${remarks.size}")
                Log.d(TAG, "  • События: ${events.size}")

                val syncEntities = SyncEntities(
                    controlPoints = controlPoints.map { it.toSyncEntity(deviceId) },
                    pkus = pkus.map { it.toSyncEntity(deviceId) },
                    tubes = tubes.map { it.toSyncEntity(deviceId) },
                    nodes = nodes.map { it.toSyncEntity(deviceId) },
                    sections = sections.map { it.toSyncEntity(deviceId) },
                    equipment = equipment.map { it.toSyncEntity(deviceId) },
                    detailedEquipment = detailedEquipment.map { it.toSyncEntity(deviceId) },
                    remarks = remarks.map { it.toSyncEntity(deviceId) },
                    events = events.map { it.toSyncEntity(deviceId) }
                )

                val syncPackage = SyncPackage(
                    deviceId = deviceId,
                    timestamp = System.currentTimeMillis(),
                    entities = syncEntities
                )

                val result = json.encodeToString(syncPackage)
                Log.d(TAG, "✅ Данные подготовлены, размер: ${result.length} символов")
                result
            } catch (e: Exception) {
                Log.e(TAG, "❌ Ошибка подготовки данных", e)
                // Возвращаем минимальный валидный JSON вместо пустого
                "{\"deviceId\":\"error\",\"timestamp\":0,\"entities\":{}}"
            }
        }
    }

    suspend fun processIncomingSyncData(context: Context, data: String) {
        withContext(Dispatchers.IO) {
            try {
                Log.d(TAG, "🔄 Обработка входящих данных...")

                val syncPackage = json.decodeFromString<SyncPackage>(data)
                Log.d(TAG, "📦 Получен пакет от устройства: ${syncPackage.deviceId}")
                Log.d(TAG, "📊 Статистика полученных данных:")
                Log.d(TAG, "  • Контрольные точки: ${syncPackage.entities.controlPoints.size}")
                Log.d(TAG, "  • ПКУ: ${syncPackage.entities.pkus.size}")
                Log.d(TAG, "  • Трубы: ${syncPackage.entities.tubes.size}")
                Log.d(TAG, "  • Узлы: ${syncPackage.entities.nodes.size}")
                Log.d(TAG, "  • Отсеки: ${syncPackage.entities.sections.size}")
                Log.d(TAG, "  • Оборудование: ${syncPackage.entities.equipment.size}")
                Log.d(TAG, "  • Детальное оборудование: ${syncPackage.entities.detailedEquipment.size}")
                Log.d(TAG, "  • Замечания: ${syncPackage.entities.remarks.size}")
                Log.d(TAG, "  • События: ${syncPackage.entities.events.size}")

                // Выполняем слияние данных
                val database = AppDatabase.getInstance(context)
                val merger = EnhancedDataMerger()
                val mergeResult = merger.mergeWithDependencies(database, syncPackage.entities)

                // Обновляем timestamp
                PreferencesManager(context).setLastSyncTimestamp(System.currentTimeMillis())

                Log.d(TAG, "✅ Синхронизация завершена:")
                Log.d(TAG, "  • Новых КП: ${mergeResult.controlPointsAdded}")
                Log.d(TAG, "  • Новых ПКУ: ${mergeResult.pkusAdded}")
                Log.d(TAG, "  • Новых труб: ${mergeResult.tubesAdded}")
                Log.d(TAG, "  • Новых узлов: ${mergeResult.nodesAdded}")
                Log.d(TAG, "  • Новых отсеков: ${mergeResult.sectionsAdded}")
                Log.d(TAG, "  • Нового оборудования: ${mergeResult.equipmentAdded}")
                Log.d(TAG, "  • Нового детального оборудования: ${mergeResult.detailedEquipmentAdded}")
                Log.d(TAG, "  • Новых замечаний: ${mergeResult.remarksAdded}")
                Log.d(TAG, "  • Новых событий: ${mergeResult.eventsAdded}")

            } catch (e: Exception) {
                Log.e(TAG, "❌ Ошибка обработки данных", e)
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\sync\SyncModels.kt ---
------------------------------------------------------------

package com.example.kipia.sync

import android.R.attr.name
import android.util.Log
import kotlinx.serialization.Serializable
import java.util.Date

@Serializable
data class SyncPackage(
    val deviceId: String,
    val timestamp: Long,
    val entities: SyncEntities,
    val fileAttachments: List<FileAttachment> = emptyList()
)

@Serializable
data class SyncEntities(
    val controlPoints: List<ControlPointSyncEntity> = emptyList(),
    val pkus: List<PKUSyncEntity> = emptyList(),
    val tubes: List<TubeSyncEntity> = emptyList(),
    val nodes: List<NodeSyncEntity> = emptyList(),
    val sections: List<SectionSyncEntity> = emptyList(),
    val equipment: List<EquipmentSyncEntity> = emptyList(),
    val detailedEquipment: List<DetailedEquipmentSyncEntity> = emptyList(),
    val remarks: List<RemarkSyncEntity> = emptyList(),
    val events: List<EventSyncEntity> = emptyList()
)

@Serializable
data class FileAttachment(
    val entityType: String,
    val entityId: Long,
    val fieldName: String,
    val fileName: String,
    val fileData: String // base64 encoded
)

// Sync Entity классы для всех сущностей
@Serializable
data class ControlPointSyncEntity(
    val id: Long,
    val name: String,
    val description: String,
    val lastModified: Long,
    val deviceId: String
)

@Serializable
data class PKUSyncEntity(
    val id: Long,
    val name: String,
    val description: String,
    val isCompleted: Boolean,
    val controlPointId: Long,
    val lastModified: Long,
    val deviceId: String
)

@Serializable
data class TubeSyncEntity(
    val id: Long,
    val name: String,
    val controlPointId: Long,
    val lastModified: Long,
    val deviceId: String
)

@Serializable
data class NodeSyncEntity(
    val id: Long,
    val name: String,
    val tubeId: Long,
    val nodeType: String,
    val orderIndex: Int,
    val lastModified: Long,
    val deviceId: String
)

@Serializable
data class SectionSyncEntity(
    val id: Long,
    val name: String,
    val pkuId: Long,
    val lastModified: Long,
    val deviceId: String
)

@Serializable
data class EquipmentSyncEntity(
    val id: Long,
    val name: String,
    val nodeId: Long?,
    val sectionId: Long?,
    val model: String,
    val manufacturer: String,
    val serialNumber: String,
    val nominal: String,
    val verificationYear: String,
    val photoPaths: String,
    val lastModified: Long,
    val deviceId: String
)

@Serializable
data class DetailedEquipmentSyncEntity(
    val id: Long,
    val equipmentType: String,
    val name: String,
    val nodeId: Long?,
    val sectionId: Long?,
    val model: String,
    val manufacturer: String,
    val serialNumber: String,
    val productionYear: String,
    val verificationYear: String,
    val nominal: String,
    val pressureLimit: String,
    val softwareVersion: String,
    val mo: String,
    val mz: String,
    val mto: String,
    val mtz: String,
    val muo: String,
    val muz: String,
    val outputContacts: String,
    val photoPaths: String,
    val lastModified: Long,
    val deviceId: String
)

@Serializable
data class RemarkSyncEntity(
    val id: Long,
    val controlPointId: Long,
    val title: String,
    val description: String,
    val category: String,
    val priority: String,
    val status: String,
    val createdDate: String,
    val deadline: String,
    val completedDate: String,
    val photos: String,
    val isArchived: Boolean,
    val lastModified: Long,
    val deviceId: String
)

@Serializable
data class EventSyncEntity(
    val id: Long,
    val controlPointId: Long,
    val title: String,
    val description: String,
    val type: String,
    val date: String,
    val time: String,
    val isCompleted: Boolean,
    val participants: String,
    val lastModified: Long,
    val deviceId: String
)

// Конвертеры Entity <-> SyncEntity
object EntityConverters {

    // ControlPoint конвертеры
    fun ControlPointSyncEntity.toEntity() = com.example.kipia.database.ControlPointEntity(
        id = id,
        name = name,
        description = description
    ).also {
        Log.d("EntityConverters", "🔄 Конвертация ControlPoint: $id - $name")
    }

    fun com.example.kipia.database.ControlPointEntity.toSyncEntity(deviceId: String) = ControlPointSyncEntity(
        id = id,
        name = name,
        description = description,
        lastModified = System.currentTimeMillis(),
        deviceId = deviceId
    )

    // PKU конвертеры
    fun PKUSyncEntity.toEntity() = com.example.kipia.database.PKUEntity(
        id = id,
        name = name,
        description = description,
        isCompleted = isCompleted,
        controlPointId = controlPointId
    ).also {
        Log.d("EntityConverters", "🔄 Конвертация PKU: $id - $name")
    }

    fun com.example.kipia.database.PKUEntity.toSyncEntity(deviceId: String) = PKUSyncEntity(
        id = id,
        name = name,
        description = description,
        isCompleted = isCompleted,
        controlPointId = controlPointId,
        lastModified = System.currentTimeMillis(),
        deviceId = deviceId
    )

    // Tube конвертеры
    fun TubeSyncEntity.toEntity() = com.example.kipia.database.TubeEntity(
        id = id,
        name = name,
        controlPointId = controlPointId
    ).also {
        Log.d("EntityConverters", "🔄 Конвертация Трубы: $id - $name")
    }

    fun com.example.kipia.database.TubeEntity.toSyncEntity(deviceId: String) = TubeSyncEntity(
        id = id,
        name = name,
        controlPointId = controlPointId,
        lastModified = System.currentTimeMillis(),
        deviceId = deviceId
    )

    // Node конвертеры
    fun NodeSyncEntity.toEntity() = com.example.kipia.database.NodeEntity(
        id = id,
        name = name,
        tubeId = tubeId,
        nodeType = nodeType,
        orderIndex = orderIndex
    ).also {
        Log.d("EntityConverters", "🔄 Конвертация Узла: $id - $name")
    }

    fun com.example.kipia.database.NodeEntity.toSyncEntity(deviceId: String) = NodeSyncEntity(
        id = id,
        name = name,
        tubeId = tubeId,
        nodeType = nodeType,
        orderIndex = orderIndex,
        lastModified = System.currentTimeMillis(),
        deviceId = deviceId
    )

    // Section конвертеры
    fun SectionSyncEntity.toEntity() = com.example.kipia.database.SectionEntity(
        id = id,
        name = name,
        pkuId = pkuId
    ).also {
        Log.d("EntityConverters", "🔄 Конвертация PKU секции: $id - $name")
    }

    fun com.example.kipia.database.SectionEntity.toSyncEntity(deviceId: String) = SectionSyncEntity(
        id = id,
        name = name,
        pkuId = pkuId,
        lastModified = System.currentTimeMillis(),
        deviceId = deviceId
    )

    // Equipment конвертеры
    fun EquipmentSyncEntity.toEntity() = com.example.kipia.database.EquipmentEntity(
        id = id,
        name = name,
        nodeId = nodeId,
        sectionId = sectionId,
        model = model,
        manufacturer = manufacturer,
        serialNumber = serialNumber,
        nominal = nominal,
        verificationYear = verificationYear,
        photoPaths = photoPaths
    ).also {
        Log.d("EntityConverters", "🔄 Конвертация оборудования: $id - $name")
    }

    fun com.example.kipia.database.EquipmentEntity.toSyncEntity(deviceId: String) = EquipmentSyncEntity(
        id = id,
        name = name,
        nodeId = nodeId,
        sectionId = sectionId,
        model = model,
        manufacturer = manufacturer,
        serialNumber = serialNumber,
        nominal = nominal,
        verificationYear = verificationYear,
        photoPaths = photoPaths,
        lastModified = System.currentTimeMillis(),
        deviceId = deviceId
    )

    // DetailedEquipment конвертеры
    fun DetailedEquipmentSyncEntity.toEntity() = com.example.kipia.database.DetailedEquipmentEntity(
        id = id,
        equipmentType = equipmentType,
        name = name,
        nodeId = nodeId,
        sectionId = sectionId,
        model = model,
        manufacturer = manufacturer,
        serialNumber = serialNumber,
        productionYear = productionYear,
        verificationYear = verificationYear,
        nominal = nominal,
        pressureLimit = pressureLimit,
        softwareVersion = softwareVersion,
        mo = mo,
        mz = mz,
        mto = mto,
        mtz = mtz,
        muo = muo,
        muz = muz,
        outputContacts = outputContacts,
        photoPaths = photoPaths
    ).also {
        Log.d("EntityConverters", "🔄 Конвертация детализации оборудования: $id - $name")
    }

    fun com.example.kipia.database.DetailedEquipmentEntity.toSyncEntity(deviceId: String) = DetailedEquipmentSyncEntity(
        id = id,
        equipmentType = equipmentType,
        name = name,
        nodeId = nodeId,
        sectionId = sectionId,
        model = model,
        manufacturer = manufacturer,
        serialNumber = serialNumber,
        productionYear = productionYear,
        verificationYear = verificationYear,
        nominal = nominal,
        pressureLimit = pressureLimit,
        softwareVersion = softwareVersion,
        mo = mo,
        mz = mz,
        mto = mto,
        mtz = mtz,
        muo = muo,
        muz = muz,
        outputContacts = outputContacts,
        photoPaths = photoPaths,
        lastModified = System.currentTimeMillis(),
        deviceId = deviceId
    )

    // Remark конвертеры
    fun RemarkSyncEntity.toEntity() = com.example.kipia.database.RemarkEntity(
        id = id,
        controlPointId = controlPointId,
        title = title,
        description = description,
        category = category,
        priority = priority,
        status = status,
        createdDate = createdDate,
        deadline = deadline,
        completedDate = completedDate,
        photos = photos,
        isArchived = isArchived
    ).also {
        Log.d("EntityConverters", "🔄 Конвертация Замечаний: $id - $name")
    }
    fun com.example.kipia.database.RemarkEntity.toSyncEntity(deviceId: String) = RemarkSyncEntity(
        id = id,
        controlPointId = controlPointId,
        title = title,
        description = description,
        category = category,
        priority = priority,
        status = status,
        createdDate = createdDate,
        deadline = deadline,
        completedDate = completedDate,
        photos = photos,
        isArchived = isArchived,
        lastModified = System.currentTimeMillis(),
        deviceId = deviceId
    )

    // Event конвертеры
    fun EventSyncEntity.toEntity() = com.example.kipia.database.EventEntity(
        id = id,
        controlPointId = controlPointId,
        title = title,
        description = description,
        type = type,
        date = date,
        time = time,
        isCompleted = isCompleted,
        participants = participants
    ).also {
        Log.d("EntityConverters", "🔄 Конвертация События: $id - $name")
    }
    fun com.example.kipia.database.EventEntity.toSyncEntity(deviceId: String) = EventSyncEntity(
        id = id,
        controlPointId = controlPointId,
        title = title,
        description = description,
        type = type,
        date = date,
        time = time,
        isCompleted = isCompleted,
        participants = participants,
        lastModified = System.currentTimeMillis(),
        deviceId = deviceId
    )
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\AddEquipmentDialog.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/AddEquipmentDialog.kt
package com.example.kipia.ui

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import com.example.kipia.model.EquipmentType

@Composable
fun AddEquipmentDialog(
    nodeId: Long? = null,
    sectionId: Long? = null,
    nodeName: String = "",
    onDismiss: () -> Unit,
    onConfirm: (EquipmentType) -> Unit
) {
    var selectedType by remember { mutableStateOf<EquipmentType?>(null) }

    // Определяем доступные типы оборудования в зависимости от контекста
    val availableEquipmentTypes = remember(nodeName) {
        when {
            nodeName.contains("Задвижка", ignoreCase = true) -> {
                // Только оборудование для задвижек
                listOf(
                    EquipmentType.VALVE,
                    EquipmentType.ELECTRIC_DRIVE,
                    EquipmentType.BUR,
                    EquipmentType.BKP
                )
            }
            nodeName.contains("ОД", ignoreCase = true) -> {
                // Оборудование для отбора давления
                listOf(
                    EquipmentType.FLOOD_DETECTOR,
                    EquipmentType.OPENING_DETECTOR,
                    EquipmentType.PRESSURE_GAUGE,
                    EquipmentType.PRESSURE_TRANSDUCER,
                    EquipmentType.DPS,
                    EquipmentType.R_K
                )
            }
            nodeName.contains("В", ignoreCase = true) -> {
                // Оборудование для вантузных колодцев
                listOf(
                    EquipmentType.FLOOD_DETECTOR,
                    EquipmentType.OPENING_DETECTOR
                )
            }
            else -> EquipmentType.values().toList()
        }
    }

    // Устанавливаем первый элемент по умолчанию
    LaunchedEffect(availableEquipmentTypes) {
        if (availableEquipmentTypes.isNotEmpty() && selectedType == null) {
            selectedType = availableEquipmentTypes.first()
        }
    }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            elevation = 8.dp
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = "Добавить оборудование",
                    style = MaterialTheme.typography.h6
                )

                Spacer(modifier = Modifier.height(16.dp))

                // Выбор типа оборудования
                Text("Выберите тип оборудования:")
                LazyColumn(
                    modifier = Modifier.height(200.dp)
                ) {
                    items(availableEquipmentTypes) { type ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable { selectedType = type }
                                .padding(8.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            RadioButton(
                                selected = selectedType == type,
                                onClick = { selectedType = type }
                            )
                            Text(
                                text = type.displayName,
                                modifier = Modifier.padding(start = 8.dp)
                            )
                        }
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Кнопки
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    Button(onClick = onDismiss) {
                        Text("Отмена")
                    }

                    Spacer(modifier = Modifier.width(8.dp))

                    Button(
                        onClick = {
                            selectedType?.let { onConfirm(it) }
                            onDismiss()
                        },
                        enabled = selectedType != null
                    ) {
                        Text("Добавить")
                    }
                }
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\AddNodeDialog.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import com.example.kipia.model.NodeType
import com.example.kipia.utils.NameUtils

@Composable
fun AddNodeDialog(
    tubeName: String = "",
    onDismiss: () -> Unit,
    onConfirm: (String, NodeType) -> Unit
) {
    var nodeName by remember { mutableStateOf("") }
    var selectedType by remember { mutableStateOf(NodeType.PRESSURE_WELL) }

    // Получаем номер участка МН
    val tubeNumber = NameUtils.getNodeNumberFromTube(tubeName)

    // Автоматически определяем тип по названию участка МН
    LaunchedEffect(tubeName) {
        val (prefix, _) = NameUtils.getNodePrefixFromTube(tubeName)
        selectedType = when (prefix) {
            "ОД" -> NodeType.PRESSURE_WELL
            "В" -> NodeType.VENT_WELL
            "Задвижка" -> NodeType.VALVE
            else -> NodeType.PRESSURE_WELL
        }

        // Автозаполнение номера
        if (tubeNumber.isNotEmpty() && nodeName.isEmpty()) {
            nodeName = "/1" // Начальный номер
        }
    }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            elevation = 8.dp
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = "Добавить объект",
                    style = MaterialTheme.typography.h6
                )

                Spacer(modifier = Modifier.height(16.dp))

                // Выбор типа узла
                Text("Тип объекта:")
                LazyColumn(
                    modifier = Modifier.height(160.dp)
                ) {
                    items(NodeType.values()) { type ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable { selectedType = type }
                                .padding(8.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            RadioButton(
                                selected = selectedType == type,
                                onClick = { selectedType = type }
                            )
                            Text(
                                text = type.displayName,
                                modifier = Modifier.padding(start = 8.dp)
                            )
                        }
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Поле для ввода названия
                OutlinedTextField(
                    value = nodeName,
                    onValueChange = { nodeName = it },
                    label = {
                        Text(
                            when (selectedType) {
                                NodeType.PRESSURE_WELL -> "Номер ОД (например: /1)"
                                NodeType.VENT_WELL -> "Номер В (например: /2)"
                                NodeType.VALVE -> "Номер задвижки (например: 878)"
                                NodeType.CUSTOM -> "Название объекта"
                            }
                        )
                    },
                    modifier = Modifier.fillMaxWidth(),
                    placeholder = {
                        Text(
                            when (selectedType) {
                                NodeType.PRESSURE_WELL -> "Введите номер ОД"
                                NodeType.VENT_WELL -> "Введите номер В"
                                NodeType.VALVE -> "Введите номер задвижки"
                                NodeType.CUSTOM -> "Введите название"
                            }
                        )
                    }
                )

                Spacer(modifier = Modifier.height(16.dp))

                // Предпросмотр полного имени
                if (nodeName.isNotBlank()) {
                    val fullName = when (selectedType) {
                        NodeType.CUSTOM -> nodeName
                        NodeType.VALVE -> "${selectedType.prefix} $nodeName"
                        else -> "${selectedType.prefix} $tubeNumber$nodeName"
                    }
                    Text(
                        text = "Полное имя: $fullName",
                        style = MaterialTheme.typography.caption,
                        color = MaterialTheme.colors.primary
                    )
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Кнопки
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    Button(onClick = onDismiss) {
                        Text("Отмена")
                    }

                    Spacer(modifier = Modifier.width(8.dp))

                    Button(
                        onClick = {
                            if (nodeName.isNotBlank()) {
                                // Формируем полное имя для сохранения
                                val fullNameToSave = when (selectedType) {
                                    NodeType.CUSTOM -> nodeName
                                    NodeType.VALVE -> "${selectedType.prefix} $nodeName"
                                    else -> "${selectedType.prefix} $tubeNumber$nodeName"
                                }
                                onConfirm(fullNameToSave, selectedType)
                                onDismiss()
                            }
                        },
                        enabled = nodeName.isNotBlank()
                    ) {
                        Text("Добавить")
                    }
                }
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\AddPKUDialog.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import com.example.kipia.utils.NameUtils

@Composable
fun AddPKUDialog(
    kpName: String = "",
    onDismiss: () -> Unit,
    onConfirm: (String, String) -> Unit
) {
    var name by remember { mutableStateOf("") }
    var description by remember { mutableStateOf("") }

    // Автозаполнение при изменении kpName
    LaunchedEffect(kpName) {
        if (kpName.isNotEmpty() && name.isEmpty()) {
            name = NameUtils.getPKUNameFromKP(kpName)
        }
    }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            elevation = 8.dp
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text("Добавить ПКУ", style = MaterialTheme.typography.h6)
                Spacer(modifier = Modifier.height(16.dp))

                OutlinedTextField(
                    value = name,
                    onValueChange = { name = it },
                    label = { Text("Название ПКУ") },
                    modifier = Modifier.fillMaxWidth(),
                    placeholder = { Text("Например: ПКУ 878 км") }
                )

                Spacer(modifier = Modifier.height(8.dp))

                OutlinedTextField(
                    value = description,
                    onValueChange = { description = it },
                    label = { Text("Описание") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = false,
                    maxLines = 3
                )

                Spacer(modifier = Modifier.height(16.dp))

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    Button(onClick = onDismiss) {
                        Text("Отмена")
                    }
                    Spacer(modifier = Modifier.width(8.dp))
                    Button(
                        onClick = {
                            if (name.isNotBlank()) {
                                onConfirm(name, description)
                            }
                        },
                        enabled = name.isNotBlank()
                    ) {
                        Text("Добавить")
                    }
                }
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\AddRemarkDialog.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import android.util.Log
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import com.example.kipia.utils.rememberPhotoPickerLauncher
import com.example.kipia.utils.PhotoStorageUtils

@Composable
fun AddRemarkDialog(
    controlPointName: String,
    onDismiss: () -> Unit,
    onConfirm: (String, String, String, String, String, List<String>) -> Unit
) {
    var title by remember { mutableStateOf("") }
    var description by remember { mutableStateOf("") }
    var category by remember { mutableStateOf("Оборудование") }
    var priority by remember { mutableStateOf("Средний") }
    var deadline by remember { mutableStateOf(getNextWeekDate()) }
    var photoPaths by remember { mutableStateOf<List<String>>(emptyList()) }

    val context = LocalContext.current

    // РЕАЛЬНЫЙ ПИКЕР ФОТО
    val photoPickerLauncher = rememberPhotoPickerLauncher { uris ->
        try {
            if (uris.isNotEmpty()) {
                // КОПИРУЕМ ФОТО В ПОСТОЯННОЕ ХРАНИЛИЩЕ
                val persistentPaths = PhotoStorageUtils.convertUrisToPersistentPaths(context, uris)
                if (persistentPaths.isNotEmpty()) {
                    photoPaths = photoPaths + persistentPaths
                    Log.d("PhotoPicker", "Added ${persistentPaths.size} persistent photos, total: ${photoPaths.size}")
                }
            }
        } catch (e: Exception) {
            Log.e("PhotoPicker", "Error adding photos", e)
        }
    }


    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .heightIn(max = 600.dp),
            elevation = 8.dp
        ) {
            Column(
                modifier = Modifier
                    .padding(16.dp)
                    .verticalScroll(rememberScrollState())
            ) {
                Text(
                    text = "Новое замечание",
                    style = MaterialTheme.typography.h6
                )

                Spacer(modifier = Modifier.height(8.dp))

                Text(
                    text = "Для: $controlPointName",
                    style = MaterialTheme.typography.caption,
                    color = MaterialTheme.colors.primary
                )

                Spacer(modifier = Modifier.height(16.dp))

                // Поля формы
                OutlinedTextField(
                    value = title,
                    onValueChange = { title = it },
                    label = { Text("Заголовок*") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                Spacer(modifier = Modifier.height(8.dp))

                OutlinedTextField(
                    value = description,
                    onValueChange = { description = it },
                    label = { Text("Описание") },
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(80.dp),
                    singleLine = false,
                    maxLines = 3
                )

                Spacer(modifier = Modifier.height(12.dp))

                // Категория и приоритет
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Column(modifier = Modifier.weight(1f)) {
                        Text("Категория", style = MaterialTheme.typography.caption)
                        SimpleCategoryDropdown(
                            category = category,
                            onCategoryChange = { newCategory -> category = newCategory }
                        )
                    }

                    Column(modifier = Modifier.weight(1f)) {
                        Text("Приоритет", style = MaterialTheme.typography.caption)
                        SimplePriorityDropdown(
                            priority = priority,
                            onPriorityChange = { newPriority -> priority = newPriority }
                        )
                    }
                }

                Spacer(modifier = Modifier.height(12.dp))

                // СЕКЦИЯ ФОТО - РЕАЛЬНАЯ ВЕРСИЯ
                Column(modifier = Modifier.fillMaxWidth()) {
                    Text(
                        text = "Прикрепленные фото",
                        style = MaterialTheme.typography.subtitle2
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Фото: ${photoPaths.size}",
                            style = MaterialTheme.typography.body2
                        )

                        Button(
                            onClick = {
                                try {
                                    Log.d("PhotoPicker", "Launching real photo picker")
                                    photoPickerLauncher.launch(
                                        PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly)
                                    )
                                } catch (e: Exception) {
                                    Log.e("PhotoPicker", "Cannot launch photo picker", e)
                                }
                            },
                            modifier = Modifier.height(36.dp)
                        ) {
                            Text("Добавить фото")
                        }
                    }

                    if (photoPaths.isNotEmpty()) {
                        Spacer(modifier = Modifier.height(8.dp))
                        Column {
                            photoPaths.forEachIndexed { index, path ->
                                Row(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .padding(vertical = 4.dp),
                                    horizontalArrangement = Arrangement.SpaceBetween,
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    Text(
                                        text = "Фото ${index + 1}",
                                        style = MaterialTheme.typography.caption,
                                        maxLines = 1,
                                        modifier = Modifier.weight(1f)
                                    )

                                    TextButton(
                                        onClick = {
                                            photoPaths = photoPaths.toMutableList().apply {
                                                removeAt(index)
                                            }
                                        }
                                    ) {
                                        Text("Удалить")
                                    }
                                }
                            }
                        }
                    }
                }
                Spacer(modifier = Modifier.height(8.dp))

                Text(
                    text = "Срок устранения: $deadline",
                    style = MaterialTheme.typography.caption,
                    color = MaterialTheme.colors.primary
                )

                Spacer(modifier = Modifier.height(16.dp))

                // Кнопки
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    TextButton(onClick = onDismiss) {
                        Text("Отмена")
                    }

                    Spacer(modifier = Modifier.width(8.dp))

                    Button(
                        onClick = {
                            Log.d("PhotoPicker", "Creating remark with ${photoPaths.size} photos")
                            onConfirm(title, description, category, priority, deadline, photoPaths)
                        },
                        enabled = title.isNotBlank()
                    ) {
                        Text("Создать")
                    }
                }
            }
        }
    }
}

// ИСПРАВЛЕННЫЕ ФУНКЦИИ БЕЗ ERROR
@Composable
fun SimplePriorityDropdown(priority: String, onPriorityChange: (String) -> Unit) {
    var expanded by remember { mutableStateOf(false) }
    val priorities = listOf("Высокий", "Средний", "Низкий")

    Box {
        OutlinedButton(
            onClick = { expanded = true },
            modifier = Modifier.fillMaxWidth(),
            contentPadding = PaddingValues(horizontal = 12.dp)
        ) {
            Text(
                text = priority,
                modifier = Modifier.weight(1f),
                style = MaterialTheme.typography.body2
            )
            Icon(
                Icons.Default.ArrowDropDown,
                contentDescription = "Выбрать приоритет"
            )
        }

        DropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false }
        ) {
            priorities.forEach { prio ->
                DropdownMenuItem(onClick = {
                    onPriorityChange(prio)
                    expanded = false
                }) {
                    Text(prio)
                }
            }
        }
    }
}

@Composable
fun SimpleCategoryDropdown(category: String, onCategoryChange: (String) -> Unit) {
    var expanded by remember { mutableStateOf(false) }
    val categories = listOf("Оборудование", "Безопасность", "Документация", "Прочее")

    Box {
        OutlinedButton(
            onClick = { expanded = true },
            modifier = Modifier.fillMaxWidth(),
            contentPadding = PaddingValues(horizontal = 12.dp)
        ) {
            Text(
                text = category,
                modifier = Modifier.weight(1f),
                style = MaterialTheme.typography.body2
            )
            Icon(
                imageVector = Icons.Default.ArrowDropDown,
                contentDescription = "Выбрать категорию"
            )
        }

        DropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false }
        ) {
            categories.forEach { cat ->
                DropdownMenuItem(onClick = {
                    onCategoryChange(cat)
                    expanded = false
                }) {
                    Text(cat)
                }
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\AddSectionDialog.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/AddSectionDialog.kt
package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog

@Composable
fun AddSectionDialog(
    pkuName: String = "",
    onDismiss: () -> Unit,
    onConfirm: (String) -> Unit
) {
    var sectionName by remember { mutableStateOf("") }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            elevation = 8.dp
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text("Добавить секцию", style = MaterialTheme.typography.h6)
                Spacer(modifier = Modifier.height(16.dp))

                OutlinedTextField(
                    value = sectionName,
                    onValueChange = { sectionName = it },
                    label = { Text("Название секции") },
                    modifier = Modifier.fillMaxWidth(),
                    placeholder = { Text("Например: Секция 1") }
                )

                Spacer(modifier = Modifier.height(16.dp))

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    Button(onClick = onDismiss) {
                        Text("Отмена")
                    }
                    Spacer(modifier = Modifier.width(8.dp))
                    Button(
                        onClick = {
                            if (sectionName.isNotBlank()) {
                                onConfirm(sectionName)
                            }
                        },
                        enabled = sectionName.isNotBlank()
                    ) {
                        Text("Добавить")
                    }
                }
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\AddSectionEquipmentDialog.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import com.example.kipia.model.EquipmentType

@Composable
fun AddSectionEquipmentDialog(
    sectionName: String,
    onDismiss: () -> Unit,
    onConfirm: (EquipmentType) -> Unit
) {
    var selectedType by remember { mutableStateOf<EquipmentType?>(null) }

    // Определяем доступные типы оборудования в зависимости от типа отсека
    val availableEquipmentTypes = remember(sectionName) {
        when {
            sectionName.contains("Инженерный", ignoreCase = true) -> {
                // Оборудование для инженерного отсека
                listOf(
                    EquipmentType.SHTM,
                    EquipmentType.FIRE_ALARM,
                    EquipmentType.SMOKE_DETECTOR,
                    EquipmentType.MANUAL_DETECTOR,
                    EquipmentType.SIREN,
                    EquipmentType.AIR_CONDITIONER,
                    EquipmentType.CONTROL_PANEL,
                    EquipmentType.FLOOD_DETECTOR,
                    EquipmentType.OPENING_DETECTOR,
                    EquipmentType.BKEP
                )
            }
            sectionName.contains("Трансформаторный", ignoreCase = true) -> {
                // Оборудование для трансформаторного отсека
                listOf(
                    EquipmentType.SMOKE_DETECTOR,
                    EquipmentType.MANUAL_DETECTOR,
                    EquipmentType.FLOOD_DETECTOR,
                    EquipmentType.OPENING_DETECTOR
                )
            }
            else -> {
                // Общее оборудование для любых секций
                listOf(
                    EquipmentType.FLOOD_DETECTOR,
                    EquipmentType.OPENING_DETECTOR,
                    EquipmentType.PRESSURE_GAUGE,
                    EquipmentType.PRESSURE_TRANSDUCER
                )
            }
        }
    }

    // Устанавливаем первый элемент по умолчанию
    LaunchedEffect(availableEquipmentTypes) {
        if (availableEquipmentTypes.isNotEmpty() && selectedType == null) {
            selectedType = availableEquipmentTypes.first()
        }
    }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            elevation = 8.dp
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = "Добавить оборудование в $sectionName",
                    style = MaterialTheme.typography.h6
                )

                Spacer(modifier = Modifier.height(16.dp))

                Text("Выберите тип оборудования:")
                LazyColumn(
                    modifier = Modifier.height(300.dp)
                ) {
                    items(availableEquipmentTypes) { type ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable { selectedType = type }
                                .padding(8.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            RadioButton(
                                selected = selectedType == type,
                                onClick = { selectedType = type }
                            )
                            Text(
                                text = type.displayName,
                                modifier = Modifier.padding(start = 8.dp)
                            )
                        }
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Кнопки
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    Button(onClick = onDismiss) {
                        Text("Отмена")
                    }

                    Spacer(modifier = Modifier.width(8.dp))

                    Button(
                        onClick = {
                            selectedType?.let { onConfirm(it) }
                            onDismiss()
                        },
                        enabled = selectedType != null
                    ) {
                        Text("Добавить")
                    }
                }
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\AddTubeDialog.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment.Companion.CenterVertically
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import com.example.kipia.utils.NameUtils

@Composable
fun AddTubeDialog(
    kpName: String = "",
    onDismiss: () -> Unit,
    onConfirm: (String) -> Unit
) {
    var selectedOption by remember { mutableStateOf("") }
    var customName by remember { mutableStateOf("") }

    val tubeOptions = remember(kpName) {
        NameUtils.getTubeNameOptionsFromKP(kpName)
    }

    // Выбираем первый вариант по умолчанию
    LaunchedEffect(tubeOptions) {
        if (tubeOptions.isNotEmpty() && selectedOption.isEmpty()) {
            selectedOption = tubeOptions.first()
        }
    }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            elevation = 8.dp
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text("Добавить участок МН", style = MaterialTheme.typography.h6)
                Spacer(modifier = Modifier.height(16.dp))

                Text("Выберите вариант:", style = MaterialTheme.typography.subtitle1)
                Spacer(modifier = Modifier.height(8.dp))

                // Список вариантов
                LazyColumn(
                    modifier = Modifier.height(120.dp)
                ) {
                    items(tubeOptions) { option ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable { selectedOption = option }
                                .padding(8.dp),
                            verticalAlignment = CenterVertically
                        ) {
                            RadioButton(
                                selected = selectedOption == option,
                                onClick = { selectedOption = option }
                            )
                            Text(
                                text = option,
                                modifier = Modifier.padding(start = 8.dp)
                            )
                        }
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Поле для своего варианта
                OutlinedTextField(
                    value = customName,
                    onValueChange = {
                        customName = it
                        selectedOption = it
                    },
                    label = { Text("Свой вариант") },
                    modifier = Modifier.fillMaxWidth(),
                    placeholder = { Text("Введите свое название") }
                )

                Spacer(modifier = Modifier.height(16.dp))

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    Button(onClick = onDismiss) {
                        Text("Отмена")
                    }
                    Spacer(modifier = Modifier.width(8.dp))
                    Button(
                        onClick = {
                            if (selectedOption.isNotBlank()) {
                                onConfirm(selectedOption)
                            }
                        },
                        enabled = selectedOption.isNotBlank()
                    ) {
                        Text("Добавить")
                    }
                }
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\AdvancedSyncScreen.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import kotlinx.coroutines.launch
import com.example.kipia.ui.SyncState // ДОБАВЬТЕ ЭТУ СТРОКУ

@Composable
fun AdvancedSyncScreen(
    onBackClick: () -> Unit
) {
    val context = LocalContext.current
    val syncViewModel: SyncViewModel = viewModel(
        factory = SyncViewModelFactory(context)
    )
    val syncState by syncViewModel.syncState.collectAsState()
    val coroutineScope = rememberCoroutineScope()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Расширенная синхронизация") },
                navigationIcon = {
                    IconButton(onClick = onBackClick) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Назад")
                    }
                }
            )
        }
    ) { padding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                SyncStatusCard(syncState, syncViewModel)
            }

            item {
                QuickActionsCard(syncViewModel, coroutineScope, context)
            }

            item {
                DataManagementCard(syncViewModel, coroutineScope, context)
            }

            item {
                SyncHistoryCard(syncState)
            }

            item {
                TechnicalInfoCard(syncState)
            }
        }
    }
}

@Composable
private fun QuickActionsCard(
    viewModel: SyncViewModel,
    coroutineScope: kotlinx.coroutines.CoroutineScope, // Исправлено
    context: android.content.Context
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        elevation = 4.dp
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Быстрые действия",
                style = MaterialTheme.typography.h6
            )

            Spacer(modifier = Modifier.height(16.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Button(
                    onClick = { viewModel.startSync() },
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.buttonColors(backgroundColor = MaterialTheme.colors.primary)
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Icon(Icons.Default.Sync, contentDescription = null)
                        Text("Синхронизировать")
                    }
                }

                Button(
                    onClick = {
                        coroutineScope.launch {
                            // Экспорт данных
                            // EnhancedSyncManager.exportSyncDataToFile(context, "path/to/file")
                        }
                    },
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.buttonColors(backgroundColor = MaterialTheme.colors.secondary)
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Icon(Icons.Default.FileDownload, contentDescription = null)
                        Text("Экспорт")
                    }
                }
            }

            Spacer(modifier = Modifier.height(8.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Button(
                    onClick = {
                        coroutineScope.launch {
                            // Импорт данных
                            // EnhancedSyncManager.importSyncDataFromFile(context, "path/to/file")
                        }
                    },
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.buttonColors(backgroundColor = MaterialTheme.colors.secondaryVariant)
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Icon(Icons.Default.FileUpload, contentDescription = null)
                        Text("Импорт")
                    }
                }

                Button(
                    onClick = { viewModel.stopSync() },
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.buttonColors(backgroundColor = MaterialTheme.colors.error)
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Icon(Icons.Default.Stop, contentDescription = null)
                        Text("Стоп")
                    }
                }
            }
        }
    }
}

@Composable
private fun DataManagementCard(
    viewModel: SyncViewModel,
    coroutineScope: kotlinx.coroutines.CoroutineScope, // Исправлено
    context: android.content.Context
) {
    var showExportDialog by remember { mutableStateOf(false) }
    var showImportDialog by remember { mutableStateOf(false) }

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        elevation = 4.dp
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Управление данными",
                style = MaterialTheme.typography.h6
            )

            Spacer(modifier = Modifier.height(16.dp))

            // Статистика данных
            DataStatisticsRow()

            Spacer(modifier = Modifier.height(16.dp))

            // Действия с данными
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                OutlinedButton(
                    onClick = { showExportDialog = true },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Icon(Icons.Default.Backup, contentDescription = null)
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("Создать резервную копию")
                }

                OutlinedButton(
                    onClick = { showImportDialog = true },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Icon(Icons.Default.Restore, contentDescription = null)
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("Восстановить из копии")
                }

                OutlinedButton(
                    onClick = {
                        coroutineScope.launch {
                            // Очистка кэша синхронизации
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Icon(Icons.Default.Clear, contentDescription = null)
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("Очистить кэш синхронизации")
                }
            }
        }
    }

    // Диалоги
    if (showExportDialog) {
        ExportDataDialog(
            onDismiss = { showExportDialog = false },
            onExport = { filePath ->
                coroutineScope.launch {
                    // EnhancedSyncManager.exportSyncDataToFile(context, filePath)
                    showExportDialog = false
                }
            }
        )
    }

    if (showImportDialog) {
        ImportDataDialog(
            onDismiss = { showImportDialog = false },
            onImport = { filePath ->
                coroutineScope.launch {
                    // EnhancedSyncManager.importSyncDataFromFile(context, filePath)
                    showImportDialog = false
                }
            }
        )
    }
}

@Composable
private fun DataStatisticsRow() {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly
    ) {
        DataStatItem(
            label = "КП",
            value = "12",
            icon = Icons.Default.Place
        )
        DataStatItem(
            label = "Оборудование",
            value = "45",
            icon = Icons.Default.Build
        )
        DataStatItem(
            label = "Замечания",
            value = "8",
            icon = Icons.Default.Warning
        )
    }
}

@Composable
private fun DataStatItem(label: String, value: String, icon: androidx.compose.ui.graphics.vector.ImageVector) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Icon(icon, contentDescription = null, tint = MaterialTheme.colors.primary)
        Spacer(modifier = Modifier.height(4.dp))
        Text(value, style = MaterialTheme.typography.h6)
        Text(label, style = MaterialTheme.typography.caption)
    }
}

@Composable
private fun SyncHistoryCard(state: SyncState) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        elevation = 4.dp
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "История синхронизации",
                style = MaterialTheme.typography.h6
            )

            Spacer(modifier = Modifier.height(8.dp))

            // Здесь можно отображать историю синхронизаций
            Text("Последняя синхронизация: ${if (state.lastSyncTime > 0) "Выполнена" else "Не выполнена"}")
            Text("Статус: ${if (state.isSyncing) "В процессе" else "Готово"}")
            Text("Устройств найдено: ${state.connectedDevices.size}")
        }
    }
}

@Composable
private fun TechnicalInfoCard(state: SyncState) {
    var expanded by remember { mutableStateOf(false) }

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        elevation = 4.dp
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Техническая информация",
                    style = MaterialTheme.typography.h6
                )
                IconButton(onClick = { expanded = !expanded }) {
                    Icon(
                        if (expanded) Icons.Default.ExpandLess else Icons.Default.ExpandMore,
                        contentDescription = if (expanded) "Свернуть" else "Развернуть"
                    )
                }
            }

            if (expanded) {
                Spacer(modifier = Modifier.height(8.dp))
                Text("Advertising: ${if (state.isAdvertising) "Включено" else "Выключено"}")
                Text("Discovering: ${if (state.isDiscovering) "Включено" else "Выключено"}")
                Text("Connected devices: ${state.connectedDevices.joinToString()}")
                Text("Sync progress: ${state.syncProgress}%")
            }
        }
    }
}

@Composable
private fun ExportDataDialog(
    onDismiss: () -> Unit,
    onExport: (String) -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Экспорт данных") },
        text = { Text("Выберите место для сохранения резервной копии данных") },
        confirmButton = {
            Button(onClick = { onExport("/path/to/backup.json") }) {
                Text("Экспорт")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Отмена")
            }
        }
    )
}

@Composable
private fun ImportDataDialog(
    onDismiss: () -> Unit,
    onImport: (String) -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Импорт данных") },
        text = { Text("Выберите файл для восстановления данных") },
        confirmButton = {
            Button(onClick = { onImport("/path/to/backup.json") }) {
                Text("Импорт")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Отмена")
            }
        }
    )
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\ControlPointDetailScreen.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import coil.compose.AsyncImage
import android.net.Uri
import com.example.kipia.database.AppDatabase
import com.example.kipia.database.ControlPointEntity
import com.example.kipia.database.PKUEntity
import com.example.kipia.database.TubeEntity
import com.example.kipia.database.SectionEntity
import com.example.kipia.database.NodeEntity
import com.example.kipia.model.NodeType
import kotlinx.coroutines.launch

@Composable
fun ControlPointDetailScreen(
    controlPoint: ControlPointEntity,
    pkuViewModel: PKUViewModel,
    tubeViewModel: TubeViewModel,
    nodeViewModel: NodeViewModel,
    equipmentViewModel: EquipmentViewModel,
    onBackClick: () -> Unit,
    onAddPKU: (String, String) -> Unit,
    onDeletePKU: (Long) -> Unit,
    onAddTube: (String) -> Unit,
    onDeleteTube: (Long) -> Unit,
    onAddNode: (String, Long, NodeType) -> Unit,
    onDeleteNode: (Long, Long) -> Unit,
    onViewEquipment: (Long, String) -> Unit = { _, _ -> },
    onViewSectionEquipment: (Long, String) -> Unit = { _, _ -> },
    onViewEquipmentPhotos: (Long, List<String>) -> Unit = { _, _ -> }
) {
    val context = LocalContext.current
    val controlPointViewModel: ControlPointViewModel = viewModel(
        factory = ControlPointViewModelFactory(AppDatabase.getInstance(context))
    )

    val sectionViewModel: SectionViewModel = viewModel(
        factory = SectionViewModelFactory(AppDatabase.getInstance(context))
    )

    val remarkViewModel: RemarkViewModel = viewModel(
        factory = RemarkViewModelFactory(AppDatabase.getInstance(context))
    )
    val eventViewModel: EventViewModel = viewModel(
        factory = EventViewModelFactory(AppDatabase.getInstance(context))
    )

    // ДОБАВЛЯЕМ СОСТОЯНИЯ ДЛЯ ВКЛАДОК
    var selectedTabIndex by remember { mutableStateOf(0) }
    val tabs = listOf("ПКУ/Участки", "Замечания", "События")

    val pkus by pkuViewModel.pkus.collectAsState()
    val tubes by tubeViewModel.tubes.collectAsState()
    val coroutineScope = rememberCoroutineScope()
    val remarks by remarkViewModel.remarks.collectAsState()

    var showAddPKUDialog by remember { mutableStateOf(false) }
    var showAddTubeDialog by remember { mutableStateOf(false) }
    var showEditControlPointDialog by remember { mutableStateOf(false) }
    var showAddRemarkDialog by remember { mutableStateOf(false) }

    // Состояния для редактирования
    var editingPKU by remember { mutableStateOf<PKUEntity?>(null) }
    var editingTube by remember { mutableStateOf<TubeEntity?>(null) }
    var editingNode by remember { mutableStateOf<NodeEntity?>(null) }
    var selectedEquipmentForEditing by remember { mutableStateOf<Long?>(null) }

    // Состояния для навигации
    var selectedNodeForEquipment by remember { mutableStateOf<NodeEntity?>(null) }
    var selectedSectionForEquipment by remember { mutableStateOf<SectionEntity?>(null) }
    var selectedEquipmentForView by remember { mutableStateOf<Long?>(null) }
    var selectedEquipmentForEdit by remember { mutableStateOf<Long?>(null) }

    // Загружаем данные при изменении controlPoint
    LaunchedEffect(controlPoint.id) {
        pkuViewModel.loadPKUsByControlPointId(controlPoint.id)
        tubeViewModel.loadTubesByControlPointId(controlPoint.id)
        remarkViewModel.loadAllRemarksByControlPointId(controlPoint.id)
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(controlPoint.name) },
                navigationIcon = {
                    IconButton(onClick = onBackClick) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Назад")
                    }
                },
                actions = {
                    IconButton(onClick = { showEditControlPointDialog = true }) {
                        Icon(Icons.Default.Edit, contentDescription = "Редактировать КП")
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .padding(innerPadding)
                .fillMaxSize()
        ) {
            // ВКЛАДКИ
            TabRow(selectedTabIndex = selectedTabIndex) {
                tabs.forEachIndexed { index, title ->
                    Tab(
                        text = { Text(title) },
                        selected = selectedTabIndex == index,
                        onClick = { selectedTabIndex = index }
                    )
                }
            }

            // СОДЕРЖИМОЕ ВКЛАДОК
            when (selectedTabIndex) {
                0 -> { // ВКЛАДКА ПКУ/УЧАСТКИ МН
                    Column(
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(16.dp)
                    ) {
                        if (controlPoint.description.isNotEmpty()) {
                            Text(
                                text = controlPoint.description,
                                style = MaterialTheme.typography.body2,
                                color = MaterialTheme.colors.onSurface.copy(alpha = 0.7f),
                                modifier = Modifier.padding(bottom = 8.dp)
                            )
                        }

                        // Секция ПКУ с кнопкой добавления в одной строке
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text("ПКУ", style = MaterialTheme.typography.h6)
                            Row {
                                IconButton(
                                    onClick = { showAddPKUDialog = true },
                                    modifier = Modifier.size(40.dp)
                                ) {
                                    Icon(Icons.Default.Add, contentDescription = "Добавить ПКУ")
                                }
                            }
                        }

                        Spacer(modifier = Modifier.height(2.dp))

                        // Список ПКУ с фиксированной высотой
                        if (pkus.isNotEmpty()) {
                            LazyColumn(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .heightIn(max = 150.dp)
                            ) {
                                items(pkus) { pku ->
                                    PKUItem(
                                        pku = pku,
                                        sectionViewModel = sectionViewModel,
                                        onEdit = { editingPKU = pku },
                                        onDelete = { onDeletePKU(pku.id) },
                                        onAddSection = { sectionName, pkuId ->
                                            sectionViewModel.addSection(sectionName, pkuId)
                                        },
                                        onViewSectionEquipment = { sectionId ->
                                            val sections = sectionViewModel.sections.value
                                            val section = sections.find { it.id == sectionId }
                                            selectedSectionForEquipment = section ?: SectionEntity(
                                                id = sectionId,
                                                name = "Отсек $sectionId",
                                                pkuId = pku.id
                                            )
                                        }
                                    )
                                }
                            }
                        } else {
                            Text(
                                text = "Нет ПКУ",
                                style = MaterialTheme.typography.caption,
                                color = MaterialTheme.colors.onSurface.copy(alpha = 0.5f),
                                modifier = Modifier.padding(vertical = 8.dp)
                            )
                        }

                        Spacer(modifier = Modifier.height(8.dp))

                        // Секция Участков МН с кнопкой добавления в одной строке
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text("Участки МН", style = MaterialTheme.typography.h6)
                            IconButton(
                                onClick = { showAddTubeDialog = true },
                                modifier = Modifier.size(40.dp)
                            ) {
                                Icon(Icons.Default.Add, contentDescription = "Добавить участок МН")
                            }
                        }

                        Spacer(modifier = Modifier.height(2.dp))

                        // Список участков МН занимает оставшееся пространство
                        Column(
                            modifier = Modifier
                                .fillMaxWidth()
                                .weight(1f)
                                .verticalScroll(rememberScrollState())
                        ) {
                            tubes.forEach { tube ->
                                TubeItem(
                                    tube = tube,
                                    nodeViewModel = nodeViewModel,
                                    onEdit = { editingTube = tube },
                                    onDelete = {
                                        onDeleteTube(tube.id)
                                        coroutineScope.launch {
                                            tubeViewModel.loadTubesByControlPointId(controlPoint.id)
                                        }
                                    },
                                    onAddNode = { name, type ->
                                        onAddNode(name, tube.id, type)
                                        coroutineScope.launch {
                                            nodeViewModel.loadNodesByTubeId(tube.id)
                                        }
                                    },
                                    onDeleteNode = { nodeId ->
                                        onDeleteNode(nodeId, tube.id)
                                        coroutineScope.launch {
                                            nodeViewModel.loadNodesByTubeId(tube.id)
                                        }
                                    },
                                    onEditNode = { node -> editingNode = node },
                                    onViewEquipment = { node ->
                                        selectedNodeForEquipment = node
                                    }
                                )
                            }
                        }
                    }
                }

                1 -> { // ВКЛАДКА ЗАМЕЧАНИЙ
                    RemarksTabWithArchive(
                        activeRemarks = remarkViewModel.activeRemarks.collectAsState().value,
                        archivedRemarks = remarkViewModel.archivedRemarks.collectAsState().value,
                        onAddRemarkWithPhotos = { title, description, category, priority, deadline, photoPaths ->
                            remarkViewModel.addRemarkWithPhotos(
                                title,
                                description,
                                category,
                                priority,
                                deadline,
                                photoPaths
                            )
                        },
                        onEditRemark = { updatedRemark ->
                            remarkViewModel.updateRemark(updatedRemark)
                        },
                        onUpdateStatus = { id, status ->
                            remarkViewModel.updateRemarkStatus(id, status)
                        },
                        onArchiveRemark = { remarkId ->
                            remarkViewModel.archiveRemark(remarkId)
                        },
                        onUnarchiveRemark = { remarkId ->
                            remarkViewModel.unarchiveRemark(remarkId)
                        },
                        onDeleteRemark = { context, remark ->
                            remarkViewModel.deleteRemark(context, remark)
                        },
                        controlPointName = controlPoint.name
                    )
                }

                2 -> { // ВКЛАДКА СОБЫТИЙ
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        Text("Раздел событий в разработке")
                    }
                }
            }
        }
    }

    // Диалоги
    if (showAddPKUDialog) {
        AddPKUDialog(
            kpName = controlPoint.name,
            onDismiss = { showAddPKUDialog = false },
            onConfirm = { name, description ->
                onAddPKU(name, description)
                showAddPKUDialog = false
            }
        )
    }

    if (showAddTubeDialog) {
        AddTubeDialog(
            kpName = controlPoint.name,
            onDismiss = { showAddTubeDialog = false },
            onConfirm = { name ->
                onAddTube(name)
                showAddTubeDialog = false
            }
        )
    }

    if (showEditControlPointDialog) {
        EditNameDialog(
            currentName = controlPoint.name,
            currentDescription = controlPoint.description,
            title = "Редактировать КП",
            nameHint = "Название КП",
            descriptionHint = "Описание КП",
            onDismiss = { showEditControlPointDialog = false },
            onConfirm = { newName, newDescription ->
                controlPointViewModel.updateControlPoint(controlPoint.id, newName, newDescription)
                showEditControlPointDialog = false
            }
        )
    }

    if (editingPKU != null) {
        EditNameDialog(
            currentName = editingPKU!!.name,
            currentDescription = editingPKU!!.description,
            title = "Редактировать ПКУ",
            nameHint = "Название ПКУ",
            descriptionHint = "Описание ПКУ",
            onDismiss = { editingPKU = null },
            onConfirm = { newName, newDescription ->
                pkuViewModel.updatePKU(editingPKU!!.id, newName, newDescription)
                editingPKU = null
            }
        )
    }

    if (editingTube != null) {
        EditNameDialog(
            currentName = editingTube!!.name,
            currentDescription = "",
            title = "Редактировать участок МН",
            nameHint = "Название участка МН",
            showDescription = false,
            onDismiss = { editingTube = null },
            onConfirm = { newName, _ ->
                tubeViewModel.updateTube(editingTube!!.id, newName)
                editingTube = null
            }
        )
    }

    if (editingNode != null) {
        EditNameDialog(
            currentName = editingNode!!.name,
            currentDescription = "",
            title = "Редактировать объект",
            nameHint = "Название объекта",
            showDescription = false,
            onDismiss = { editingNode = null },
            onConfirm = { newName, _ ->
                nodeViewModel.updateNode(editingNode!!.id, newName, editingNode!!.tubeId)
                editingNode = null
            }
        )
    }

    // В КОНЦЕ ControlPointDetailScreen.kt ЗАМЕНИТЕ весь блок навигации на:

// Навигация к оборудованию - передаем через колбэки
    if (selectedNodeForEquipment != null) {
        // Передаем узел через колбэк
        onViewEquipment(selectedNodeForEquipment!!.id, selectedNodeForEquipment!!.name)
        // Сбрасываем состояние
        selectedNodeForEquipment = null
        return
    }

    if (selectedSectionForEquipment != null) {
        // Передаем секцию через колбэк
        onViewSectionEquipment(selectedSectionForEquipment!!.id, selectedSectionForEquipment!!.name)
        // Сбрасываем состояние
        selectedSectionForEquipment = null
        return
    }

// Остальные случаи навигации (если нужны)
    if (selectedEquipmentForView != null) {
        // Обработка просмотра оборудования
        selectedEquipmentForView = null
    }

    if (selectedEquipmentForEdit != null) {
        // Обработка редактирования оборудования
        selectedEquipmentForEdit = null
    }

    if (selectedEquipmentForEditing != null) {
        // Обработка редактирования оборудования
        selectedEquipmentForEditing = null
    }
}

----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\ControlPointListScreen.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.example.kipia.database.ControlPointEntity

@Composable
fun ControlPointListScreen(
    controlPoints: List<ControlPointEntity>,
    onControlPointClick: (ControlPointEntity) -> Unit,
    onAddControlPoint: (String, String) -> Unit,
    onDeleteControlPoint: (Long) -> Unit,
    onEditControlPoint: (Long, String, String) -> Unit
) {
    var showAddDialog by remember { mutableStateOf(false) }
    var showEditDialog by remember { mutableStateOf(false) }
    var editingControlPoint by remember { mutableStateOf<ControlPointEntity?>(null) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Заголовок и кнопка добавления в одной строке
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(text = "Список КП", style = MaterialTheme.typography.h5)
            IconButton(
                onClick = { showAddDialog = true },
                modifier = Modifier.size(48.dp)
            ) {
                Icon(Icons.Default.Add, contentDescription = "Добавить КП")
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        LazyColumn(modifier = Modifier.weight(1f)) {
            items(controlPoints) { cp ->
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 4.dp),
                    elevation = 4.dp
                ) {
                    Row(
                        modifier = Modifier.padding(12.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        // Название КП - клик для перехода к деталям
                        Column(
                            modifier = Modifier
                                .weight(1f)
                                .clickable { onControlPointClick(cp) }
                        ) {
                            Text(text = cp.name, style = MaterialTheme.typography.body1)
                            if (cp.description.isNotEmpty()) {
                                Text(
                                    text = cp.description,
                                    style = MaterialTheme.typography.body2,
                                    color = MaterialTheme.colors.onSurface.copy(alpha = 0.7f)
                                )
                            }
                        }

                        // Кнопка редактирования
                        IconButton(
                            onClick = {
                                editingControlPoint = cp
                                showEditDialog = true
                            }
                        ) {
                            Icon(Icons.Default.Edit, contentDescription = "Редактировать КП")
                        }

                        // Кнопка удаления
                        IconButton(onClick = { onDeleteControlPoint(cp.id) }) {
                            Icon(Icons.Default.Delete, contentDescription = "Удалить КП")
                        }
                    }
                }
            }
        }
    }

    // Диалог добавления КП
    if (showAddDialog) {
        EditNameDialog(
            currentName = "",
            currentDescription = "",
            title = "Добавить КП",
            nameHint = "Название КП",
            descriptionHint = "Описание КП",
            onDismiss = { showAddDialog = false },
            onConfirm = { name, description ->
                onAddControlPoint(name, description)
                showAddDialog = false
            }
        )
    }

    // Диалог редактирования КП
    if (showEditDialog && editingControlPoint != null) {
        EditNameDialog(
            currentName = editingControlPoint!!.name,
            currentDescription = editingControlPoint!!.description,
            title = "Редактировать КП",
            nameHint = "Название КП",
            descriptionHint = "Описание КП",
            onDismiss = {
                showEditDialog = false
                editingControlPoint = null
            },
            onConfirm = { newName, newDescription ->
                editingControlPoint?.let { cp ->
                    onEditControlPoint(cp.id, newName, newDescription)
                }
                showEditDialog = false
                editingControlPoint = null
            }
        )
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\ControlPointViewModel.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.example.kipia.database.AppDatabase
import com.example.kipia.database.ControlPointEntity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class ControlPointViewModel(private val database: AppDatabase) : ViewModel() {

    private val _controlPoints = MutableStateFlow<List<ControlPointEntity>>(emptyList())
    val controlPoints: StateFlow<List<ControlPointEntity>> = _controlPoints



    init {
        loadControlPoints()
    }

    private fun loadControlPoints() {
        viewModelScope.launch {
            val result = withContext(Dispatchers.IO) {
                database.controlPointDao().getAllControlPoints()
            }
            _controlPoints.value = result
        }
    }

    fun addControlPoint(name: String, description: String = "") {
        viewModelScope.launch {
            val cp = ControlPointEntity(name = name, description = description)
            withContext(Dispatchers.IO) {
                database.controlPointDao().insert(cp)
            }
            loadControlPoints() // обновляем список
        }
    }

    fun deleteControlPoint(id: Long) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.controlPointDao().deleteById(id)
            }
            loadControlPoints()
        }
    }

    fun updateControlPoint(id: Long, newName: String, newDescription: String = "") {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.controlPointDao().update(id, newName, newDescription)
            }
            loadControlPoints()
        }
    }


}


----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\ControlPointViewModelFactory.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.example.kipia.database.AppDatabase

class ControlPointViewModelFactory(private val database: AppDatabase) : ViewModelProvider.Factory {
    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(ControlPointViewModel::class.java)) {
            return ControlPointViewModel(database) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\EditEquipmentScreen.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/EditEquipmentScreen.kt
package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Check
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.example.kipia.database.AppDatabase
import com.example.kipia.database.DetailedEquipmentEntity
import com.example.kipia.model.EquipmentType

@Composable
fun EditEquipmentScreen(
    equipmentId: Long,
    onBackClick: () -> Unit,
    onSaveClick: () -> Unit
) {
    val context = LocalContext.current
    val equipmentViewModel: EquipmentViewModel = viewModel(
        factory = EquipmentViewModelFactory(AppDatabase.getInstance(context))
    )

    var currentEquipment by remember { mutableStateOf<DetailedEquipmentEntity?>(null) }

    // Загружаем оборудование при открытии
    LaunchedEffect(equipmentId) {
        val equipment = equipmentViewModel.getEquipmentById(equipmentId)
        currentEquipment = equipment
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Редактирование оборудования") },
                navigationIcon = {
                    IconButton(onClick = onBackClick) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Назад")
                    }
                },
                actions = {
                    IconButton(
                        onClick = {
                            currentEquipment?.let {
                                equipmentViewModel.updateEquipment(it)
                                onSaveClick()
                            }
                        },
                        enabled = currentEquipment != null
                    ) {
                        Icon(Icons.Default.Check, contentDescription = "Сохранить")
                    }
                }
            )
        }
    ) { innerPadding ->
        currentEquipment?.let { equipment ->
            EquipmentForm(
                equipment = equipment,
                onEquipmentUpdate = { updatedEquipment ->
                    currentEquipment = updatedEquipment
                },
                modifier = Modifier
                    .padding(innerPadding)
                    .fillMaxSize()
                    .verticalScroll(rememberScrollState())
                    .padding(16.dp)
            )
        } ?: run {
            // Показываем загрузку, если оборудование еще не загружено
            Box(
                modifier = Modifier
                    .padding(innerPadding)
                    .fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        }
    }
}

@Composable
fun EquipmentForm(
    equipment: DetailedEquipmentEntity,
    onEquipmentUpdate: (DetailedEquipmentEntity) -> Unit,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier) {
        // Основная информация
        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = 4.dp
        ) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(
                    text = "Основная информация",
                    style = MaterialTheme.typography.h6,
                    modifier = Modifier.padding(bottom = 8.dp)
                )

                // Название оборудования
                OutlinedTextField(
                    value = equipment.name,
                    onValueChange = { newName ->
                        onEquipmentUpdate(equipment.copy(name = newName))
                    },
                    label = { Text("Название оборудования") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                Spacer(modifier = Modifier.height(8.dp))

                // Тип оборудования (только для чтения)
                OutlinedTextField(
                    value = EquipmentType.valueOf(equipment.equipmentType).displayName,
                    onValueChange = { },
                    label = { Text("Тип оборудования") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    readOnly = true
                )
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        // Общие характеристики
        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = 4.dp
        ) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(
                    text = "Общие характеристики",
                    style = MaterialTheme.typography.h6,
                    modifier = Modifier.padding(bottom = 8.dp)
                )

                OutlinedTextField(
                    value = equipment.model,
                    onValueChange = { newModel ->
                        onEquipmentUpdate(equipment.copy(model = newModel))
                    },
                    label = { Text("Модель") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                Spacer(modifier = Modifier.height(8.dp))

                OutlinedTextField(
                    value = equipment.manufacturer,
                    onValueChange = { newManufacturer ->
                        onEquipmentUpdate(equipment.copy(manufacturer = newManufacturer))
                    },
                    label = { Text("Производитель") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                Spacer(modifier = Modifier.height(8.dp))

                OutlinedTextField(
                    value = equipment.serialNumber,
                    onValueChange = { newSerial ->
                        onEquipmentUpdate(equipment.copy(serialNumber = newSerial))
                    },
                    label = { Text("Заводской номер") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                Spacer(modifier = Modifier.height(8.dp))

                OutlinedTextField(
                    value = equipment.productionYear,
                    onValueChange = { newYear ->
                        onEquipmentUpdate(equipment.copy(productionYear = newYear))
                    },
                    label = { Text("Год выпуска") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                Spacer(modifier = Modifier.height(8.dp))

                OutlinedTextField(
                    value = equipment.verificationYear,
                    onValueChange = { newVerification ->
                        onEquipmentUpdate(equipment.copy(verificationYear = newVerification))
                    },
                    label = { Text("Год поверки") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

// В функции EquipmentForm в EditEquipmentScreen.kt обновляем блок специфических характеристик:

// Специфические характеристики
        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = 4.dp
        ) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(
                    text = "Специфические характеристики",
                    style = MaterialTheme.typography.h6,
                    modifier = Modifier.padding(bottom = 8.dp)
                )

                OutlinedTextField(
                    value = equipment.nominal,
                    onValueChange = { newNominal ->
                        onEquipmentUpdate(equipment.copy(nominal = newNominal))
                    },
                    label = { Text("Номинал") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                Spacer(modifier = Modifier.height(8.dp))

                OutlinedTextField(
                    value = equipment.pressureLimit,
                    onValueChange = { newPressure ->
                        onEquipmentUpdate(equipment.copy(pressureLimit = newPressure))
                    },
                    label = { Text("Граница давления") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                Spacer(modifier = Modifier.height(8.dp))

                OutlinedTextField(
                    value = equipment.softwareVersion,
                    onValueChange = { newSoftware ->
                        onEquipmentUpdate(equipment.copy(softwareVersion = newSoftware))
                    },
                    label = { Text("Версия ПО") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                // Дополнительные характеристики для БУР, БКЭП и других релейных защит
                if (equipment.equipmentType in listOf("BUR", "BKEP", "DPS", "BKP", "UZR")) {
                    Spacer(modifier = Modifier.height(8.dp))
                    OutlinedTextField(
                        value = equipment.mo,
                        onValueChange = { newMo ->
                            onEquipmentUpdate(equipment.copy(mo = newMo))
                        },
                        label = { Text("МО") },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )

                    Spacer(modifier = Modifier.height(4.dp))
                    OutlinedTextField(
                        value = equipment.mz,
                        onValueChange = { newMz ->
                            onEquipmentUpdate(equipment.copy(mz = newMz))
                        },
                        label = { Text("МЗ") },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )

                    Spacer(modifier = Modifier.height(4.dp))
                    OutlinedTextField(
                        value = equipment.mto,
                        onValueChange = { newMto ->
                            onEquipmentUpdate(equipment.copy(mto = newMto))
                        },
                        label = { Text("МТО") },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )

                    Spacer(modifier = Modifier.height(4.dp))
                    OutlinedTextField(
                        value = equipment.mtz,
                        onValueChange = { newMtz ->
                            onEquipmentUpdate(equipment.copy(mtz = newMtz))
                        },
                        label = { Text("МТЗ") },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )

                    Spacer(modifier = Modifier.height(4.dp))
                    OutlinedTextField(
                        value = equipment.muo,
                        onValueChange = { newMuo ->
                            onEquipmentUpdate(equipment.copy(muo = newMuo))
                        },
                        label = { Text("МУО") },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )

                    Spacer(modifier = Modifier.height(4.dp))
                    OutlinedTextField(
                        value = equipment.muz,
                        onValueChange = { newMuz ->
                            onEquipmentUpdate(equipment.copy(muz = newMuz))
                        },
                        label = { Text("МУЗ") },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )

                    Spacer(modifier = Modifier.height(4.dp))
                    OutlinedTextField(
                        value = equipment.outputContacts,
                        onValueChange = { newContacts ->
                            onEquipmentUpdate(equipment.copy(outputContacts = newContacts))
                        },
                        label = { Text("Кол.об.вых.зв") },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )
                }
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\EditNameDialog.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog

@Composable
fun EditNameDialog(
    currentName: String,
    currentDescription: String = "",
    title: String,
    nameHint: String = "Введите название",
    descriptionHint: String = "Введите описание",
    showDescription: Boolean = true,
    onDismiss: () -> Unit,
    onConfirm: (String, String) -> Unit
) {
    var newName by remember { mutableStateOf(currentName) }
    var newDescription by remember { mutableStateOf(currentDescription) }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            elevation = 8.dp
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = title,
                    style = MaterialTheme.typography.h6
                )

                Spacer(modifier = Modifier.height(16.dp))

                // Поле для названия
                OutlinedTextField(
                    value = newName,
                    onValueChange = { newName = it },
                    label = { Text(nameHint) },
                    modifier = Modifier.fillMaxWidth()
                )

                Spacer(modifier = Modifier.height(8.dp))

                // Поле для описания (если нужно)
                if (showDescription) {
                    OutlinedTextField(
                        value = newDescription,
                        onValueChange = { newDescription = it },
                        label = { Text(descriptionHint) },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = false,
                        maxLines = 3
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                }

                // Кнопки
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    Button(onClick = onDismiss) {
                        Text("Отмена")
                    }

                    Spacer(modifier = Modifier.width(8.dp))

                    Button(
                        onClick = {
                            if (newName.isNotBlank()) {
                                onConfirm(newName, newDescription)
                            }
                        },
                        enabled = newName.isNotBlank()
                    ) {
                        Text("Сохранить")
                    }
                }
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\EditRemarkDialog.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import com.example.kipia.database.RemarkEntity
import android.util.Log
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import com.example.kipia.utils.rememberPhotoPickerLauncher
import com.example.kipia.utils.PhotoStorageUtils

@Composable
fun EditRemarkDialog(
    remark: RemarkEntity,
    onDismiss: () -> Unit,
    onConfirm: (String, String, String, String, String, List<String>) -> Unit
) {
    var title by remember { mutableStateOf(remark.title) }
    var description by remember { mutableStateOf(remark.description) }
    var category by remember { mutableStateOf(remark.category) }
    var priority by remember { mutableStateOf(remark.priority) }
    var deadline by remember { mutableStateOf(remark.deadline) }
    var photoPaths by remember { mutableStateOf(remark.getPhotoList()) }

    val context = LocalContext.current

    // РЕАЛЬНЫЙ ПИКЕР ФОТО
    val photoPickerLauncher = rememberPhotoPickerLauncher { uris ->
        try {
            // ИСПОЛЬЗУЕМ PhotoStorageUtils вместо getFilePathsFromUris
            val persistentPaths = PhotoStorageUtils.convertUrisToPersistentPaths(context, uris)
            if (persistentPaths.isNotEmpty()) {
                photoPaths = photoPaths + persistentPaths
                Log.d("PhotoPicker", "Added ${persistentPaths.size} persistent photos in edit, total: ${photoPaths.size}")
            }
        } catch (e: Exception) {
            Log.e("PhotoPicker", "Error adding photos in edit", e)
        }
    }

    val onAddRealPhoto = {
        try {
            Log.d("PhotoPicker", "Launching real photo picker in edit")
            photoPickerLauncher.launch(
                PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly)
            )
        } catch (e: Exception) {
            Log.e("PhotoPicker", "Cannot launch photo picker in edit", e)
            // Временно добавляем тестовые фото при ошибке
            val testPhotos = listOf(
                "content://media/external/images/media/1000000001",
                "content://media/external/images/media/1000000002"
            )
            photoPaths = photoPaths + testPhotos
        }
    }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .heightIn(max = 600.dp),
            elevation = 8.dp
        ) {
            Column(
                modifier = Modifier
                    .padding(16.dp)
                    .verticalScroll(rememberScrollState())
            ) {
                Text(
                    text = "Редактировать замечание",
                    style = MaterialTheme.typography.h6
                )

                Spacer(modifier = Modifier.height(16.dp))

                // Поля формы
                OutlinedTextField(
                    value = title,
                    onValueChange = { title = it },
                    label = { Text("Заголовок*") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                Spacer(modifier = Modifier.height(8.dp))

                OutlinedTextField(
                    value = description,
                    onValueChange = { description = it },
                    label = { Text("Описание") },
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(80.dp),
                    singleLine = false,
                    maxLines = 3
                )

                Spacer(modifier = Modifier.height(12.dp))

                // Категория и приоритет
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Column(modifier = Modifier.weight(1f)) {
                        Text("Категория", style = MaterialTheme.typography.caption)
                        SimpleCategoryDropdown(
                            category = category,
                            onCategoryChange = { newCategory -> category = newCategory }
                        )
                    }

                    Column(modifier = Modifier.weight(1f)) {
                        Text("Приоритет", style = MaterialTheme.typography.caption)
                        SimplePriorityDropdown(
                            priority = priority,
                            onPriorityChange = { newPriority -> priority = newPriority }
                        )
                    }
                }

                Spacer(modifier = Modifier.height(12.dp))

                // СЕКЦИЯ ФОТО - РЕАЛЬНАЯ ВЕРСИЯ
                Column(modifier = Modifier.fillMaxWidth()) {
                    Text(
                        text = "Прикрепленные фото",
                        style = MaterialTheme.typography.subtitle2
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    // Простой индикатор количества фото
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Фото: ${photoPaths.size}",
                            style = MaterialTheme.typography.body2
                        )

                        Button(
                            onClick = onAddRealPhoto,
                            modifier = Modifier.height(36.dp)
                        ) {
                            Text("Добавить фото")
                        }
                    }

                    // Простой список фото
                    if (photoPaths.isNotEmpty()) {
                        Spacer(modifier = Modifier.height(8.dp))
                        Column {
                            photoPaths.forEachIndexed { index, path ->
                                Row(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .padding(vertical = 4.dp),
                                    horizontalArrangement = Arrangement.SpaceBetween,
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    Text(
                                        text = "Фото ${index + 1}",
                                        style = MaterialTheme.typography.caption,
                                        maxLines = 1,
                                        modifier = Modifier.weight(1f)
                                    )

                                    TextButton(
                                        onClick = {
                                            photoPaths = photoPaths.toMutableList().apply {
                                                removeAt(index)
                                            }
                                        }
                                    ) {
                                        Text("Удалить")
                                    }
                                }
                            }
                        }
                    }
                }

                Spacer(modifier = Modifier.height(8.dp))

                Text(
                    text = "Срок устранения: $deadline",
                    style = MaterialTheme.typography.caption,
                    color = MaterialTheme.colors.primary
                )

                Spacer(modifier = Modifier.height(16.dp))

                // Кнопки
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    TextButton(onClick = onDismiss) {
                        Text("Отмена")
                    }

                    Spacer(modifier = Modifier.width(8.dp))

                    Button(
                        onClick = {
                            onConfirm(title, description, category, priority, deadline, photoPaths)
                        },
                        enabled = title.isNotBlank()
                    ) {
                        Text("Сохранить")
                    }
                }
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\EquipmentDetailScreen.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/EquipmentDetailScreen.kt
package com.example.kipia.ui

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.example.kipia.database.AppDatabase
import com.example.kipia.model.EquipmentType
import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import coil.compose.AsyncImage

@Composable
fun EquipmentDetailScreen(
    nodeName: String? = null,
    sectionName: String? = null,
    nodeId: Long? = null,
    sectionId: Long? = null,
    onBackClick: () -> Unit,
    onViewEquipment: (Long) -> Unit = {},
    onViewEquipmentPhotos: (Long, List<String>) -> Unit = { _, _ -> },
    onAddPhotosToEquipment: (Long, String) -> Unit = { _, _ -> }
) {
    val context = LocalContext.current
    val equipmentViewModel: EquipmentViewModel = viewModel(
        factory = EquipmentViewModelFactory(AppDatabase.getInstance(context))
    )

    val equipment by equipmentViewModel.equipment.collectAsState()

    var showAddEquipmentDialog by remember { mutableStateOf(false) }
    var showAddSectionEquipmentDialog by remember { mutableStateOf(false) }
    var currentSelectedEquipment by remember { mutableStateOf<Pair<Long, String>?>(null) }

    // Лаунчер для выбора фото
    val photoPickerLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.PickMultipleVisualMedia()
    ) { uris ->
        currentSelectedEquipment?.let { (equipmentId, _) ->
            if (uris.isNotEmpty()) {
                val photoPaths = com.example.kipia.utils.EquipmentPhotoUtils.saveEquipmentPhotos(context, uris)
                equipmentViewModel.addPhotosToEquipment(equipmentId, photoPaths)
            }
        }
        currentSelectedEquipment = null
    }

    // Формируем правильное название для заголовка
    val screenTitle = when {
        nodeName != null -> "Оборудование: $nodeName"
        sectionName != null -> "Оборудование: $sectionName"
        else -> "Оборудование"
    }

    // Загружаем оборудование при открытии экрана
    LaunchedEffect(nodeId, sectionId) {
        when {
            nodeId != null -> equipmentViewModel.loadEquipmentByNodeId(nodeId)
            sectionId != null -> equipmentViewModel.loadEquipmentBySectionId(sectionId)
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        text = screenTitle,
                        maxLines = 1,
                        overflow = TextOverflow.Ellipsis
                    )
                },
                navigationIcon = {
                    IconButton(onClick = onBackClick) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Назад")
                    }
                }
            )
        },
        floatingActionButton = {
            // Только один FAB для добавления оборудования
            FloatingActionButton(
                onClick = {
                    if (sectionId != null) {
                        showAddSectionEquipmentDialog = true
                    } else {
                        showAddEquipmentDialog = true
                    }
                }
            ) {
                Icon(Icons.Default.Add, contentDescription = "Добавить оборудование")
            }
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .padding(innerPadding)
                .fillMaxSize()
                .padding(16.dp)
        ) {
            if (equipment.isEmpty()) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Text(
                            text = "Оборудование не добавлено",
                            style = MaterialTheme.typography.body1,
                            color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f)
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                        Text(
                            text = "Нажмите + чтобы добавить оборудование",
                            style = MaterialTheme.typography.body2,
                            color = MaterialTheme.colors.onSurface.copy(alpha = 0.4f)
                        )
                    }
                }
            } else {
                LazyColumn(
                    modifier = Modifier.fillMaxSize()
                ) {
                    items(equipment) { item ->
                        EquipmentItemCard(
                            equipment = item,
                            onView = {
                                println("DEBUG: View equipment ${item.id}")
                                onViewEquipment(item.id)
                            },
                            onDelete = { equipmentViewModel.deleteEquipment(item) },
                            onViewPhotos = {
                                val photoPaths = com.example.kipia.utils.EquipmentPhotoUtils.getPhotoPathsFromJson(item.photoPaths)
                                if (photoPaths.isNotEmpty()) {
                                    println("DEBUG: View photos for equipment ${item.id}")
                                    onViewEquipmentPhotos(item.id, photoPaths)
                                } else {
                                    println("DEBUG: No photos for equipment ${item.id}")
                                }
                            },
                            onAddPhotos = {
                                println("DEBUG: Add photos to equipment ${item.id}")
                                currentSelectedEquipment = Pair(item.id, item.name)
                                photoPickerLauncher.launch(
                                    PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly)
                                )
                            }
                        )
                    }
                }
            }
        }
    }

    if (showAddEquipmentDialog) {
        AddEquipmentDialog(
            nodeId = nodeId,
            sectionId = sectionId,
            nodeName = nodeName ?: "",
            onDismiss = { showAddEquipmentDialog = false },
            onConfirm = { type ->
                val newEquipment = com.example.kipia.database.DetailedEquipmentEntity(
                    equipmentType = type.name,
                    name = type.displayName,
                    nodeId = nodeId,
                    sectionId = sectionId
                )
                equipmentViewModel.addEquipment(newEquipment)
            }
        )
    }

    if (showAddSectionEquipmentDialog) {
        AddSectionEquipmentDialog(
            sectionName = sectionName ?: "секцию",
            onDismiss = { showAddSectionEquipmentDialog = false },
            onConfirm = { type ->
                val newEquipment = com.example.kipia.database.DetailedEquipmentEntity(
                    equipmentType = type.name,
                    name = type.displayName,
                    sectionId = sectionId
                )
                equipmentViewModel.addEquipment(newEquipment)
            }
        )
    }
}

@Composable
fun EquipmentItemCard(
    equipment: com.example.kipia.database.DetailedEquipmentEntity,
    onView: () -> Unit,
    onDelete: () -> Unit,
    onViewPhotos: () -> Unit,
    onAddPhotos: () -> Unit
) {
    val photoPaths = com.example.kipia.utils.EquipmentPhotoUtils.getPhotoPathsFromJson(equipment.photoPaths)

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp)
            .clickable {
                println("DEBUG: Equipment card clicked: ${equipment.name}")
                onView()
            },
        elevation = 2.dp
    ) {
        Column(
            modifier = Modifier.padding(12.dp)
        ) {
            // ВЕРХНЯЯ ЧАСТЬ: Название и характеристики в одной строке с кнопкой удаления
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                // Левая часть: название и характеристики
                Column(
                    modifier = Modifier.weight(1f)
                ) {
                    Text(
                        text = equipment.name,
                        style = MaterialTheme.typography.h6,
                        modifier = Modifier.padding(bottom = 2.dp)
                    )

                    // Характеристики в компактном виде
                    if (equipment.model.isNotEmpty() || equipment.serialNumber.isNotEmpty()) {
                        Row(
                            horizontalArrangement = Arrangement.spacedBy(12.dp)
                        ) {
                            if (equipment.model.isNotEmpty()) {
                                Text(
                                    text = "Модель: ${equipment.model}",
                                    style = MaterialTheme.typography.caption,
                                    color = MaterialTheme.colors.onSurface.copy(alpha = 0.7f)
                                )
                            }
                            if (equipment.serialNumber.isNotEmpty()) {
                                Text(
                                    text = "№: ${equipment.serialNumber}",
                                    style = MaterialTheme.typography.caption,
                                    color = MaterialTheme.colors.onSurface.copy(alpha = 0.7f)
                                )
                            }
                        }
                    }
                }

                // Правая часть: кнопка удаления
                TextButton(
                    onClick = onDelete,
                    modifier = Modifier.padding(start = 8.dp)
                ) {
                    Text(
                        "Удалить",
                        color = MaterialTheme.colors.error,
                        style = MaterialTheme.typography.caption
                    )
                }
            }

            // НИЖНЯЯ ЧАСТЬ: Превью фото и кнопка добавления фото на одном уровне
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 8.dp),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                // Левая часть: превью фото (если есть)
                if (photoPaths.isNotEmpty()) {
                    CompactPhotoPreviewRow(
                        photoPaths = photoPaths,
                        onPhotoClick = onViewPhotos,
                        modifier = Modifier.weight(1f)
                    )
                } else {
                    // Если нет фото - занимаем пространство
                    Spacer(modifier = Modifier.weight(1f))
                }

                // Правая часть: кнопка добавления фото
                CompactAddPhotoButton(
                    onClick = onAddPhotos,
                    hasPhotos = photoPaths.isNotEmpty(),
                    modifier = Modifier.padding(start = 8.dp)
                )
            }
        }
    }
}

// Компактное превью фото
@Composable
fun CompactPhotoPreviewRow(
    photoPaths: List<String>,
    onPhotoClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = "Фото:",
            style = MaterialTheme.typography.caption,
            color = MaterialTheme.colors.onSurface.copy(alpha = 0.7f),
            modifier = Modifier.padding(end = 8.dp)
        )

        LazyRow(
            horizontalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            items(photoPaths.take(3)) { path ->
                AsyncImage(
                    model = Uri.parse("file://$path"),
                    contentDescription = "Превью фото",
                    modifier = Modifier
                        .size(40.dp) // Уменьшенный размер
                        .clip(RoundedCornerShape(6.dp))
                        .clickable { onPhotoClick() },
                    contentScale = ContentScale.Crop
                )
            }

            // Показываем количество фото если их больше 3
            if (photoPaths.size > 3) {
                item {
                    Box(
                        modifier = Modifier
                            .size(40.dp)
                            .clip(RoundedCornerShape(6.dp))
                            .background(MaterialTheme.colors.primary.copy(alpha = 0.1f)),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = "+${photoPaths.size - 3}",
                            style = MaterialTheme.typography.caption,
                            color = MaterialTheme.colors.primary
                        )
                    }
                }
            }
        }
    }
}

// Компактная кнопка добавления фото
@Composable
fun CompactAddPhotoButton(
    onClick: () -> Unit,
    hasPhotos: Boolean = false,
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier
            .size(40.dp)
            .clickable { onClick() }
            .background(
                color = if (hasPhotos) MaterialTheme.colors.primary.copy(alpha = 0.1f)
                else MaterialTheme.colors.secondary.copy(alpha = 0.1f),
                shape = RoundedCornerShape(6.dp)
            ),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = "+",
            style = MaterialTheme.typography.h6,
            color = if (hasPhotos) MaterialTheme.colors.primary else MaterialTheme.colors.secondary
        )
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\EquipmentPhotoComponents.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/EquipmentPhotoComponents.kt
package com.example.kipia.ui

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.MaterialTheme
import androidx.compose.material.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImage
import android.net.Uri

@Composable
fun PhotoPreviewRow(
    photoPaths: List<String>,
    onPhotoClick: () -> Unit,
    modifier: Modifier = Modifier // ДОБАВЛЕНО: параметр modifier
) {
    Column(modifier = modifier) {
        Text(
            text = "Фото:",
            style = MaterialTheme.typography.caption
        )
        LazyRow(
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            items(photoPaths.take(3)) { path ->
                AsyncImage(
                    model = Uri.parse("file://$path"),
                    contentDescription = "Превью фото",
                    modifier = Modifier
                        .size(60.dp)
                        .clip(RoundedCornerShape(8.dp))
                        .clickable { onPhotoClick() },
                    contentScale = ContentScale.Crop
                )
            }

            if (photoPaths.size > 3) {
                item {
                    Box(
                        modifier = Modifier
                            .size(60.dp)
                            .clip(RoundedCornerShape(8.dp))
                            .background(MaterialTheme.colors.primary.copy(alpha = 0.1F)),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = "+${photoPaths.size - 3}",
                            style = MaterialTheme.typography.caption
                        )
                    }
                }
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\EquipmentPhotoScreen.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/EquipmentPhotoScreen.kt
package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import coil.compose.AsyncImage
import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.clickable
import androidx.compose.ui.Alignment
import androidx.compose.ui.layout.ContentScale
import com.example.kipia.database.AppDatabase

@Composable
fun EquipmentPhotoScreen(
    equipmentId: Long,
    equipmentName: String, // ДОБАВЛЕНО: имя оборудования
    onBackClick: () -> Unit,
    onViewFullScreen: (Uri) -> Unit
) {
    val context = LocalContext.current
    val equipmentViewModel: EquipmentViewModel = viewModel(
        factory = EquipmentViewModelFactory(AppDatabase.getInstance(context))
    )

    var showDeleteDialog by remember { mutableStateOf<String?>(null) }

    // Лаунчер для добавления фото
    val photoPickerLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.PickMultipleVisualMedia()
    ) { uris ->
        if (uris.isNotEmpty()) {
            val photoPaths = com.example.kipia.utils.EquipmentPhotoUtils.saveEquipmentPhotos(context, uris)
            equipmentViewModel.addPhotosToEquipment(equipmentId, photoPaths)
        }
    }

    // Загружаем оборудование для получения актуальных фото
    val equipment by equipmentViewModel.equipment.collectAsState()
    val currentEquipment = equipment.find { it.id == equipmentId }

    // Обновляем заголовок при изменении оборудования
    val actualEquipmentName = currentEquipment?.name ?: equipmentName

    val photoPaths = currentEquipment?.let {
        com.example.kipia.utils.EquipmentPhotoUtils.getPhotoPathsFromJson(it.photoPaths)
    } ?: emptyList()

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Column {
                        Text("Фото оборудования")
                        Text(
                            text = actualEquipmentName,
                            style = MaterialTheme.typography.caption,
                            color = MaterialTheme.colors.onSurface.copy(alpha = 0.7f)
                        )
                    }
                },
                navigationIcon = {
                    IconButton(onClick = onBackClick) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Назад")
                    }
                },
                actions = {
                    IconButton(
                        onClick = {
                            photoPickerLauncher.launch(
                                PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly)
                            )
                        }
                    ) {
                        Icon(Icons.Default.Add, contentDescription = "Добавить фото")
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .padding(innerPadding)
                .fillMaxSize()
        ) {
            if (photoPaths.isEmpty()) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Text(
                            text = "Фото не добавлены",
                            style = MaterialTheme.typography.h6,
                            color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f)
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = "Оборудование: $actualEquipmentName",
                            style = MaterialTheme.typography.body2,
                            color = MaterialTheme.colors.onSurface.copy(alpha = 0.5f)
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                        Button(
                            onClick = {
                                photoPickerLauncher.launch(
                                    PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly)
                                )
                            }
                        ) {
                            Icon(Icons.Default.Add, contentDescription = null)
                            Spacer(modifier = Modifier.width(8.dp))
                            Text("Добавить первое фото")
                        }
                    }
                }
            } else {
                LazyColumn(
                    modifier = Modifier.fillMaxSize()
                ) {
                    item {
                        // Информация об оборудовании вверху
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            elevation = 2.dp
                        ) {
                            Column(
                                modifier = Modifier.padding(16.dp)
                            ) {
                                Text(
                                    text = "Оборудование:",
                                    style = MaterialTheme.typography.caption,
                                    color = MaterialTheme.colors.onSurface.copy(alpha = 0.7f)
                                )
                                Text(
                                    text = actualEquipmentName,
                                    style = MaterialTheme.typography.body1
                                )
                                if (currentEquipment?.model?.isNotEmpty() == true) {
                                    Text(
                                        text = "Модель: ${currentEquipment.model}",
                                        style = MaterialTheme.typography.body2,
                                        color = MaterialTheme.colors.onSurface.copy(alpha = 0.7f)
                                    )
                                }
                            }
                        }
                    }

                    items(photoPaths) { path ->
                        PhotoItem(
                            photoPath = path,
                            onViewFullScreen = { onViewFullScreen(Uri.parse("file://$path")) },
                            onDelete = { showDeleteDialog = path }
                        )
                    }
                }
            }
        }
    }

    // Диалог подтверждения удаления
    showDeleteDialog?.let { pathToDelete ->
        AlertDialog(
            onDismissRequest = { showDeleteDialog = null },
            title = { Text("Удалить фото?") },
            text = { Text("Это действие нельзя отменить") },
            confirmButton = {
                TextButton(
                    onClick = {
                        equipmentViewModel.removePhotoFromEquipment(equipmentId, pathToDelete)
                        showDeleteDialog = null
                    }
                ) {
                    Text("Удалить", color = MaterialTheme.colors.error)
                }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteDialog = null }) {
                    Text("Отмена")
                }
            }
        )
    }
}

@Composable
fun PhotoItem(
    photoPath: String,
    onViewFullScreen: () -> Unit,
    onDelete: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        elevation = 4.dp
    ) {
        Column {
            AsyncImage(
                model = Uri.parse("file://$photoPath"),
                contentDescription = "Фото оборудования",
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp)
                    .clickable { onViewFullScreen() },
                contentScale = ContentScale.Crop
            )
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(8.dp),
                horizontalArrangement = Arrangement.End
            ) {
                IconButton(onClick = onDelete) {
                    Icon(
                        Icons.Default.Delete,
                        contentDescription = "Удалить фото",
                        tint = MaterialTheme.colors.error
                    )
                }
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\EquipmentViewModel.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/EquipmentViewModel.kt
package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.kipia.database.AppDatabase
import com.example.kipia.database.DetailedEquipmentEntity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.serialization.encodeToString
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.json.Json

class EquipmentViewModel(private val database: AppDatabase) : ViewModel() {

    private val _equipment = MutableStateFlow<List<DetailedEquipmentEntity>>(emptyList())
    val equipment: StateFlow<List<DetailedEquipmentEntity>> = _equipment

    private val _currentNodeId = MutableStateFlow<Long?>(null)
    private val _currentSectionId = MutableStateFlow<Long?>(null)

    fun loadEquipmentByNodeId(nodeId: Long) {
        _currentNodeId.value = nodeId
        _currentSectionId.value = null

        viewModelScope.launch {
            val result = withContext(Dispatchers.IO) {
                database.detailedEquipmentDao().getEquipmentByNodeId(nodeId)
            }
            _equipment.value = result
        }
    }

    fun loadEquipmentBySectionId(sectionId: Long) {
        _currentSectionId.value = sectionId
        _currentNodeId.value = null

        viewModelScope.launch {
            val result = withContext(Dispatchers.IO) {
                database.detailedEquipmentDao().getEquipmentBySectionId(sectionId)
            }
            _equipment.value = result
        }
    }

    fun addEquipment(equipment: DetailedEquipmentEntity) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.detailedEquipmentDao().insert(equipment)
            }
            _currentNodeId.value?.let { loadEquipmentByNodeId(it) }
            _currentSectionId.value?.let { loadEquipmentBySectionId(it) }
        }
    }

    fun updateEquipment(equipment: DetailedEquipmentEntity) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.detailedEquipmentDao().update(equipment)
            }
            _currentNodeId.value?.let { loadEquipmentByNodeId(it) }
            _currentSectionId.value?.let { loadEquipmentBySectionId(it) }
        }
    }

    fun deleteEquipment(equipment: DetailedEquipmentEntity) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.detailedEquipmentDao().delete(equipment)
            }
            _currentNodeId.value?.let { loadEquipmentByNodeId(it) }
            _currentSectionId.value?.let { loadEquipmentBySectionId(it) }
        }
    }

    suspend fun getEquipmentById(equipmentId: Long): DetailedEquipmentEntity? {
        return withContext(Dispatchers.IO) {
            database.detailedEquipmentDao().getEquipmentById(equipmentId)
        }
    }

    // ДОБАВЛЕНО: Методы для работы с фото
    fun addPhotosToEquipment(equipmentId: Long, photoPaths: List<String>) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                val equipment = database.detailedEquipmentDao().getEquipmentById(equipmentId)
                equipment?.let {
                    val currentPaths = if (it.photoPaths.isNotEmpty()) {
                        try {
                            Json.decodeFromString<List<String>>(it.photoPaths) // ИСПРАВЛЕНО: правильный синтаксис
                        } catch (e: Exception) {
                            emptyList()
                        }
                    } else {
                        emptyList()
                    }
                    val updatedPaths = currentPaths + photoPaths
                    val updatedPathsJson = Json.encodeToString(updatedPaths) // ИСПРАВЛЕНО: правильный синтаксис

                    database.detailedEquipmentDao().updatePhotoPaths(equipmentId, updatedPathsJson)
                }
            }
            _currentNodeId.value?.let { loadEquipmentByNodeId(it) }
            _currentSectionId.value?.let { loadEquipmentBySectionId(it) }
        }
    }

    fun removePhotoFromEquipment(equipmentId: Long, photoPath: String) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                val equipment = database.detailedEquipmentDao().getEquipmentById(equipmentId)
                equipment?.let {
                    val currentPaths = if (it.photoPaths.isNotEmpty()) {
                        try {
                            Json.decodeFromString<List<String>>(it.photoPaths) // ИСПРАВЛЕНО: правильный синтаксис
                        } catch (e: Exception) {
                            emptyList()
                        }
                    } else {
                        emptyList()
                    }
                    val updatedPaths = currentPaths.toMutableList().apply { remove(photoPath) }
                    val updatedPathsJson = Json.encodeToString(updatedPaths) // ИСПРАВЛЕНО: правильный синтаксис

                    database.detailedEquipmentDao().updatePhotoPaths(equipmentId, updatedPathsJson)
                }
            }
            _currentNodeId.value?.let { loadEquipmentByNodeId(it) }
            _currentSectionId.value?.let { loadEquipmentBySectionId(it) }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\EquipmentViewModelFactory.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.example.kipia.database.AppDatabase

class EquipmentViewModelFactory(private val database: AppDatabase) : ViewModelProvider.Factory {
    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(EquipmentViewModel::class.java)) {
            return EquipmentViewModel(database) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\EventViewModel.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.kipia.database.AppDatabase
import com.example.kipia.database.EventEntity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.text.SimpleDateFormat
import java.util.*

class EventViewModel(private val database: AppDatabase) : ViewModel() {

    private val _events = MutableStateFlow<List<EventEntity>>(emptyList())
    val events: StateFlow<List<EventEntity>> = _events

    private var _currentControlPointId: Long = 0L

    fun loadEventsByControlPointId(controlPointId: Long) {
        _currentControlPointId = controlPointId
        viewModelScope.launch {
            val result = withContext(Dispatchers.IO) {
                database.eventDao().getEventsByControlPointId(controlPointId)
            }
            _events.value = result
        }
    }

    fun addEvent(
        title: String,
        description: String = "",
        type: String = "Проверка",
        date: String = getCurrentDate(),
        time: String = ""
    ) {
        viewModelScope.launch {
            val event = EventEntity(
                controlPointId = _currentControlPointId,
                title = title,
                description = description,
                type = type,
                date = date,
                time = time,
                isCompleted = false
            )
            withContext(Dispatchers.IO) {
                database.eventDao().insert(event)
            }
            loadEventsByControlPointId(_currentControlPointId)
        }
    }

    fun updateEventCompletion(eventId: Long, isCompleted: Boolean) {
        viewModelScope.launch {
            val event = withContext(Dispatchers.IO) {
                database.eventDao().getEventById(eventId)
            }
            event?.let {
                val updatedEvent = it.copy(isCompleted = isCompleted)
                withContext(Dispatchers.IO) {
                    database.eventDao().update(updatedEvent)
                }
                loadEventsByControlPointId(_currentControlPointId)
            }
        }
    }

    fun updateEvent(event: EventEntity) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.eventDao().update(event)
            }
            loadEventsByControlPointId(_currentControlPointId)
        }
    }

    fun deleteEvent(event: EventEntity) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.eventDao().delete(event)
            }
            loadEventsByControlPointId(_currentControlPointId)
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\EventViewModelFactory.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.example.kipia.database.AppDatabase

class EventViewModelFactory(private val database: AppDatabase) : ViewModelProvider.Factory {
    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(EventViewModel::class.java)) {
            return EventViewModel(database) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\FullScreenPhotoView.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.gestures.rememberTransformableState
import androidx.compose.foundation.gestures.transformable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.Icon
import androidx.compose.material.IconButton
import androidx.compose.material.MaterialTheme
import androidx.compose.material.Text
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Download
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import coil.compose.rememberImagePainter
import android.net.Uri
import android.widget.Toast
import androidx.compose.foundation.clickable
import android.content.ContentValues
import android.content.pm.PackageManager
import android.os.Build
import android.os.Environment
import android.provider.MediaStore
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.content.ContextCompat
import java.io.File
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import android.util.Log

@Composable
fun FullScreenPhotoView(
    photoUri: Uri,
    onDismiss: () -> Unit
) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(androidx.compose.ui.geometry.Offset.Zero) }
    val context = LocalContext.current

    // ДОБАВЛЕНО: Проверка и коррекция URI
    val validUri = remember(photoUri) {
        try {
            Log.d("FullScreenPhotoView", "Original URI: $photoUri")
            Log.d("FullScreenPhotoView", "URI scheme: ${photoUri.scheme}")
            Log.d("FullScreenPhotoView", "URI path: ${photoUri.path}")

            // Пробуем открыть поток для проверки доступности
            context.contentResolver.openInputStream(photoUri)?.use {
                Log.d("FullScreenPhotoView", "URI is accessible")
                photoUri
            } ?: run {
                Log.w("FullScreenPhotoView", "URI not accessible, trying to fix...")

                // Если URI недоступен, пробуем создать из пути
                if (photoUri.scheme == "file" || photoUri.scheme == null) {
                    val filePath = photoUri.path ?: ""
                    val file = File(filePath)
                    if (file.exists()) {
                        Log.d("FullScreenPhotoView", "File exists, creating URI from file")
                        Uri.fromFile(file)
                    } else {
                        Log.e("FullScreenPhotoView", "File does not exist: $filePath")
                        photoUri
                    }
                } else {
                    // Для content URI пробуем альтернативный подход
                    try {
                        // Пробуем использовать URI как есть
                        val tempUri = photoUri
                        context.contentResolver.openInputStream(tempUri)?.use {
                            Log.d("FullScreenPhotoView", "Content URI is accessible on retry")
                            tempUri
                        } ?: photoUri
                    } catch (e: Exception) {
                        Log.e("FullScreenPhotoView", "Error on retry: ${e.message}")
                        photoUri
                    }
                }
            }
        } catch (e: Exception) {
            Log.e("FullScreenPhotoView", "Error checking URI: ${e.message}")
            // В случае ошибки возвращаем исходный URI
            photoUri
        }
    }

    Log.d("FullScreenPhotoView", "Using URI: $validUri")

    val state = rememberTransformableState { zoomChange, offsetChange, _ ->
        scale *= zoomChange
        offset += offsetChange
    }

    // Для управления разрешениями - правильная логика для Android 13
    val permissionLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { isGranted ->
        if (isGranted) {
            downloadImage(context, validUri)
        } else {
            Toast.makeText(
                context,
                "Разрешение необходимо для сохранения фото",
                Toast.LENGTH_LONG
            ).show()
        }
    }

    Dialog(onDismissRequest = onDismiss) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black.copy(alpha = 0.9f))
                .pointerInput(Unit) {
                    detectTapGestures(
                        onDoubleTap = { tapOffset ->
                            if (scale > 1f) {
                                // Сброс масштаба
                                scale = 1f
                                offset = androidx.compose.ui.geometry.Offset.Zero
                            } else {
                                // Увеличение в 3 раза в точке тапа
                                val newOffset = calculateZoomOffset(
                                    tapOffset,
                                    size.width.toFloat(),
                                    size.height.toFloat(),
                                    3f
                                )
                                scale = 3f
                                offset = newOffset
                            }
                        }
                    )
                }
        ) {
            // Верхняя панель с кнопками
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
                    .align(Alignment.TopEnd),
                horizontalArrangement = Arrangement.End
            ) {
                // Кнопка скачивания
                IconButton(
                    onClick = {
                        handleDownload(context, validUri, permissionLauncher)
                    },
                    modifier = Modifier
                        .size(48.dp)
                        .background(Color.Black.copy(alpha = 0.5f), CircleShape)
                ) {
                    Icon(
                        Icons.Filled.Download,
                        contentDescription = "Скачать фото",
                        tint = Color.White,
                        modifier = Modifier.size(24.dp)
                    )
                }

                Spacer(modifier = Modifier.width(8.dp))

                // Кнопка закрытия
                IconButton(
                    onClick = onDismiss,
                    modifier = Modifier
                        .size(48.dp)
                        .background(Color.Black.copy(alpha = 0.5f), CircleShape)
                ) {
                    Icon(
                        Icons.Filled.Close,
                        contentDescription = "Закрыть",
                        tint = Color.White,
                        modifier = Modifier.size(24.dp)
                    )
                }
            }

            // Изображение с жестами масштабирования - ИСПОЛЬЗУЕМ validUri
            Image(
                painter = rememberImagePainter(validUri),
                contentDescription = "Фото в полный размер",
                modifier = Modifier
                    .fillMaxSize()
                    .graphicsLayer(
                        scaleX = scale,
                        scaleY = scale,
                        translationX = offset.x,
                        translationY = offset.y
                    )
                    .transformable(state)
                    .pointerInput(Unit) {
                        detectTransformGestures { _, pan, zoom, _ ->
                            scale *= zoom
                            offset += pan

                            // Ограничение масштаба
                            scale = scale.coerceIn(0.5f, 5f)

                            // Ограничение смещения
                            val maxOffset = 500f
                            offset = androidx.compose.ui.geometry.Offset(
                                offset.x.coerceIn(-maxOffset, maxOffset),
                                offset.y.coerceIn(-maxOffset, maxOffset)
                            )
                        }
                    }
                    .clickable { } // Пустой обработчик для предотвращения закрытия при клике на фото
                    .align(Alignment.Center),
                contentScale = ContentScale.Fit
            )

            // Подсказки внизу
            Column(
                modifier = Modifier
                    .align(Alignment.BottomCenter)
                    .padding(bottom = 32.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "• Двойной тап - увеличение/сброс",
                    color = Color.White.copy(alpha = 0.8f),
                    style = MaterialTheme.typography.caption
                )
                Text(
                    text = "• Два пальца - масштабирование и перемещение",
                    color = Color.White.copy(alpha = 0.8f),
                    style = MaterialTheme.typography.caption
                )
                Text(
                    text = "• Нажмите вне фото для закрытия",
                    color = Color.White.copy(alpha = 0.8f),
                    style = MaterialTheme.typography.caption
                )
            }
        }
    }
}

// Вспомогательная функция для расчета смещения при зуме
private fun calculateZoomOffset(
    tapOffset: androidx.compose.ui.geometry.Offset,
    containerWidth: Float,
    containerHeight: Float,
    targetScale: Float
): androidx.compose.ui.geometry.Offset {
    val scaleFactor = targetScale - 1f
    val offsetX = (containerWidth / 2 - tapOffset.x) * scaleFactor
    val offsetY = (containerHeight / 2 - tapOffset.y) * scaleFactor
    return androidx.compose.ui.geometry.Offset(offsetX, offsetY)
}

// Функция для обработки скачивания с проверкой разрешений
// ... весь предыдущий код до функции handleDownload ...

// Функция для обработки скачивания с проверкой разрешений
private fun handleDownload(
    context: android.content.Context,
    uri: Uri,
    permissionLauncher: androidx.activity.result.ActivityResultLauncher<String>
) {
    // Для Android 10+ (API 29+) не нужно разрешение WRITE_EXTERNAL_STORAGE
    // MediaStore сам управляет файлами в Downloads
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
        // Android 10+ - используем MediaStore, разрешение не требуется
        downloadImage(context, uri)
    } else {
        // Для Android 9 и ниже проверяем WRITE_EXTERNAL_STORAGE
        val permission = android.Manifest.permission.WRITE_EXTERNAL_STORAGE
        when {
            ContextCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED -> {
                downloadImage(context, uri)
            }
            else -> {
                permissionLauncher.launch(permission)
            }
        }
    }
}

// ПЕРЕМЕСТИТЕ ЭТИ ФУНКЦИИ СЮДА, ПЕРЕД downloadImage:

// Скачивание для Android 10+ (API 29+)
// Замените функцию downloadImageUsingMediaStore на эту:
private fun downloadImageUsingMediaStore(
    context: android.content.Context,
    uri: Uri,
    fileName: String
): Boolean {
    return try {
        Log.d("DownloadDebug", "Using MediaStore to save: $fileName")

        // Используем Pictures вместо Download для изображений
        val contentValues = ContentValues().apply {
            put(MediaStore.Images.Media.DISPLAY_NAME, fileName)
            put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
            put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES + "/KIPiA")
        }

        val resolver = context.contentResolver
        val imageUri = resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)

        if (imageUri != null) {
            Log.d("DownloadDebug", "MediaStore URI created: $imageUri")

            var bytesCopied = 0L
            var copySuccessful = false

            resolver.openInputStream(uri)?.use { inputStream ->
                resolver.openOutputStream(imageUri)?.use { outputStream ->
                    bytesCopied = inputStream.copyTo(outputStream)
                    outputStream.flush()
                    copySuccessful = true
                }
            }

            Log.d("DownloadDebug", "Bytes copied: $bytesCopied, successful: $copySuccessful")

            if (copySuccessful && bytesCopied > 0) {
                // Вместо проверки размера через MediaStore, просто считаем что файл сохранен
                // MediaStore может не сразу обновить метаданные

                // Даем системе время на обработку
                Thread.sleep(500)

                // Проверяем доступность файла другим способом
                try {
                    resolver.openInputStream(imageUri)?.use {
                        Log.d("DownloadDebug", "File is accessible after save")
                        Toast.makeText(context, "Фото сохранено в папку Изображения/KIPiA", Toast.LENGTH_LONG).show()
                        return true
                    }
                } catch (e: Exception) {
                    Log.e("DownloadDebug", "File not accessible after save: ${e.message}")
                }

                // Если проверка не удалась, но копирование прошло успешно, считаем что файл сохранен
                if (copySuccessful) {
                    Toast.makeText(context, "Фото сохранено в папку Изображения/KIPiA", Toast.LENGTH_LONG).show()
                    return true
                }
            }
        } else {
            Log.e("DownloadDebug", "Failed to create MediaStore URI")
        }

        Toast.makeText(context, "Не удалось сохранить фото", Toast.LENGTH_LONG).show()
        false
    } catch (e: Exception) {
        Log.e("DownloadDebug", "Error in MediaStore download: ${e.message}")
        e.printStackTrace()
        Toast.makeText(context, "Ошибка: ${e.localizedMessage}", Toast.LENGTH_LONG).show()
        false
    }
}
// Основная функция скачивания
private fun downloadImage(context: android.content.Context, uri: Uri) {
    try {
        Log.d("DownloadDebug", "Starting download from URI: $uri")
        Log.d("DownloadDebug", "URI scheme: ${uri.scheme}")
        Log.d("DownloadDebug", "URI path: ${uri.path}")

        // Для файлов из внутреннего хранилища приложения нужно создать временную копию
        val tempUri = if (uri.scheme == "file" && uri.path?.contains(context.filesDir.absolutePath) == true) {
            Log.d("DownloadDebug", "URI is from app internal storage, creating temp copy")
            createTempCopyFromInternalStorage(context, uri)
        } else {
            uri
        }

        if (tempUri == null) {
            Toast.makeText(context, "Ошибка: не удалось подготовить файл для скачивания", Toast.LENGTH_LONG).show()
            return
        }

        val fileName = generateFileName()
        val success = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            // Для Android 10+ используем MediaStore
            downloadImageUsingMediaStore(context, tempUri, fileName)
        } else {
            // Для старых версий используем прямой доступ к файлам
            downloadImageLegacy(context, tempUri, fileName)
        }

        if (success) {
            // Сообщение теперь в самой функции downloadImageUsingMediaStore
        } else {
            Toast.makeText(
                context,
                "Ошибка при сохранении фото",
                Toast.LENGTH_LONG
            ).show()
        }

        // Удаляем временный файл если он был создан
        if (tempUri != uri) {
            deleteTempFile(context, tempUri)
        }

    } catch (e: Exception) {
        e.printStackTrace()
        Toast.makeText(
            context,
            "Ошибка: ${e.message}",
            Toast.LENGTH_LONG
        ).show()
    }
}

// ОСТАЛЬНЫЕ ФУНКЦИИ ОСТАВЬТЕ НА МЕСТЕ:
// Генерация имени файла с timestamp
private fun generateFileName(): String {
    val timeStamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
    return "KIPiA_$timeStamp.jpg"
}

// Скачивание для старых версий Android
private fun downloadImageLegacy(
    context: android.content.Context,
    uri: Uri,
    fileName: String
): Boolean {
    return try {
        val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
        if (!downloadsDir.exists()) {
            downloadsDir.mkdirs()
        }

        val file = File(downloadsDir, fileName)

        context.contentResolver.openInputStream(uri)?.use { inputStream ->
            file.outputStream().use { outputStream ->
                inputStream.copyTo(outputStream)
            }
        }

        // Уведомляем систему о новом файле
        val mediaScanIntent = android.content.Intent(android.content.Intent.ACTION_MEDIA_SCANNER_SCAN_FILE)
        mediaScanIntent.data = Uri.fromFile(file)
        context.sendBroadcast(mediaScanIntent)

        true
    } catch (e: Exception) {
        e.printStackTrace()
        false
    }
}

/**
 * Создает временную копию файла из внутреннего хранилища приложения
 */
private fun createTempCopyFromInternalStorage(context: android.content.Context, internalUri: Uri): Uri? {
    return try {
        val tempFile = File.createTempFile("KIPiA_temp_", ".jpg", context.cacheDir)

        context.contentResolver.openInputStream(internalUri)?.use { inputStream ->
            tempFile.outputStream().use { outputStream ->
                inputStream.copyTo(outputStream)
            }
        }

        Log.d("DownloadDebug", "Created temp file: ${tempFile.absolutePath}")
        Uri.fromFile(tempFile)
    } catch (e: Exception) {
        Log.e("DownloadDebug", "Error creating temp copy: ${e.message}")
        null
    }
}

/**
 * Удаляет временный файл
 */
private fun deleteTempFile(context: android.content.Context, tempUri: Uri) {
    try {
        if (tempUri.scheme == "file") {
            val file = File(tempUri.path ?: "")
            if (file.exists()) {
                file.delete()
                Log.d("DownloadDebug", "Temp file deleted: ${file.absolutePath}")
            }
        }
    } catch (e: Exception) {
        Log.e("DownloadDebug", "Error deleting temp file: ${e.message}")
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\HelpScreen.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/HelpScreen.kt
package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign

@Composable
fun HelpScreen(
    onBackClick: () -> Unit
) {
    val scrollState = rememberScrollState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Справка и описание") },
                navigationIcon = {
                    IconButton(onClick = onBackClick) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Назад")
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .padding(innerPadding)
                .fillMaxSize()
                .padding(16.dp)
                .verticalScroll(scrollState)
        ) {
            Text(
                text = "Приложение КИПиА",
                style = MaterialTheme.typography.h5,
                fontWeight = FontWeight.Bold,
                textAlign = TextAlign.Center,
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(16.dp))

            Text(
                text = "Назначение:",
                style = MaterialTheme.typography.h6,
                fontWeight = FontWeight.SemiBold
            )
            Text(
                text = "Приложение предназначено для фиксации данных обследования оборудования КИПиА, " +
                        "включая добавление фото и комментариев, а также управления замечаниями и мероприятиями по ним. " +
                        "Оно позволяет структурировать информацию о контрольных пунктах (КП), пунктах контроля и управления (ПКУ), " +
                        "участках магистральных нефтепроводов (МН), объектах (ОД, В, Задвижки) и установленном оборудовании.",
                style = MaterialTheme.typography.body1
            )
            Spacer(modifier = Modifier.height(16.dp))

            Text(
                text = "Возможности:",
                style = MaterialTheme.typography.h6,
                fontWeight = FontWeight.SemiBold
            )
            Text(
                text = "• Создание иерархии: КП -> ПКУ/Участки МН -> Объекты -> Оборудование\n" +
                        "• Добавление, редактирование и удаление элементов структуры\n" +
                        "• Добавление замечаний с приоритетами, сроками и фото\n" +
                        "• Архивирование выполненных замечаний\n" +
                        "• Просмотр и редактирование характеристик оборудования\n" +
                        "• Просмотр фото в полноэкранном режиме\n" +
                        "• Справочник типов оборудования\n" +
                        "• Локальное хранение данных",
                style = MaterialTheme.typography.body1
            )
            Spacer(modifier = Modifier.height(16.dp))

            Text(
                text = "Использование:",
                style = MaterialTheme.typography.h6,
                fontWeight = FontWeight.SemiBold
            )
            Text(
                text = "1. Начните с создания Контрольного Пункта (КП).\n" +
                        "2. Добавьте ПКУ или Участки МН к КП.\n" +
                        "3. Внутри ПКУ создайте отсеки (Инженерный, Трансформаторный).\n" +
                        "4. На Участке МН добавляйте объекты (ОД, В, Задвижки).\n" +
                        "5. К объектам и отсекам привязывайте оборудование.\n" +
                        "6. Используйте вкладку 'Замечания' для фиксации и отслеживания проблем.",
                style = MaterialTheme.typography.body1
            )
            Spacer(modifier = Modifier.height(16.dp))

            Text(
                text = "Версия: 1.0",
                style = MaterialTheme.typography.caption,
                textAlign = TextAlign.End,
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\NodeItem.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.material.Card
import androidx.compose.material.Icon
import androidx.compose.material.IconButton
import androidx.compose.material.MaterialTheme
import androidx.compose.material.Text
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun NodeItem(
    node: com.example.kipia.database.NodeEntity,
    onEdit: (com.example.kipia.database.NodeEntity) -> Unit,
    onDelete: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(start = 12.dp, top = 2.dp, bottom = 2.dp),
        elevation = 1.dp,
        backgroundColor = MaterialTheme.colors.surface // Используем цвет поверхности темы
    ) {
        Row(
            modifier = Modifier.padding(6.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = node.name,
                style = MaterialTheme.typography.body2,
                modifier = Modifier.weight(1f),
                color = MaterialTheme.colors.onSurface // Используем цвет текста темы
            )
            IconButton(
                onClick = { onEdit(node) },
                modifier = Modifier.size(20.dp)
            ) {
                Icon(
                    Icons.Default.Edit,
                    contentDescription = "Редактировать объект",
                    modifier = Modifier.size(14.dp),
                    tint = MaterialTheme.colors.onSurface // Цвет иконки по теме
                )
            }
            IconButton(
                onClick = onDelete,
                modifier = Modifier.size(20.dp)
            ) {
                Icon(
                    Icons.Default.Delete,
                    contentDescription = "Удалить объект",
                    modifier = Modifier.size(14.dp),
                    tint = MaterialTheme.colors.onSurface // Цвет иконки по теме
                )
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\NodeItemWithEquipment.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/NodeItemWithEquipment.kt
package com.example.kipia.ui

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.material.Card
import androidx.compose.material.Icon
import androidx.compose.material.IconButton
import androidx.compose.material.MaterialTheme
import androidx.compose.material.Text
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun NodeItemWithEquipment(
    node: com.example.kipia.database.NodeEntity,
    onEdit: (com.example.kipia.database.NodeEntity) -> Unit,
    onDelete: () -> Unit,
    onViewEquipment: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(start = 12.dp, top = 2.dp, bottom = 2.dp)
            .clickable { onViewEquipment() }, // Весь элемент кликабелен для просмотра оборудования
        elevation = 1.dp,
        backgroundColor = MaterialTheme.colors.surface
    ) {
        Row(
            modifier = Modifier.padding(6.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = node.name,
                style = MaterialTheme.typography.body2,
                modifier = Modifier.weight(1f),
                color = MaterialTheme.colors.onSurface
            )

            // Убрали шестеренку - оставили только редактирование и удаление

            // Кнопка редактирования объекта
            IconButton(
                onClick = { onEdit(node) },
                modifier = Modifier.size(20.dp)
            ) {
                Icon(
                    Icons.Default.Edit,
                    contentDescription = "Редактировать объект",
                    modifier = Modifier.size(14.dp),
                    tint = MaterialTheme.colors.onSurface
                )
            }

            // Кнопка удаления объекта
            IconButton(
                onClick = onDelete,
                modifier = Modifier.size(20.dp)
            ) {
                Icon(
                    Icons.Default.Delete,
                    contentDescription = "Удалить объект",
                    modifier = Modifier.size(14.dp),
                    tint = MaterialTheme.colors.onSurface
                )
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\NodeViewModel.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/NodeViewModel.kt
package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.kipia.database.AppDatabase
import com.example.kipia.database.NodeEntity
import com.example.kipia.model.NodeType
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class NodeViewModel(private val database: AppDatabase) : ViewModel() {

    // Основной поток для текущего отображения
    private val _currentNodes = MutableStateFlow<List<NodeEntity>>(emptyList())
    val nodes: StateFlow<List<NodeEntity>> = _currentNodes

    // Отдельные потоки для каждой трубы
    private val _nodesByTubeId = mutableMapOf<Long, MutableStateFlow<List<NodeEntity>>>()

    // Получить Flow для конкретной трубы
    fun getNodesFlowForTube(tubeId: Long): StateFlow<List<NodeEntity>> {
        if (!_nodesByTubeId.containsKey(tubeId)) {
            _nodesByTubeId[tubeId] = MutableStateFlow(emptyList())
        }
        return _nodesByTubeId[tubeId]!!
    }

    // Загрузка узлов для конкретной трубы
    fun loadNodesByTubeId(tubeId: Long) {
        viewModelScope.launch {
            val result = withContext(Dispatchers.IO) {
                database.nodeDao().getNodesByTubeId(tubeId)
            }
            println("DEBUG: Loaded nodes for tube $tubeId: $result")

            // Обновляем хранилище для этой трубы
            if (!_nodesByTubeId.containsKey(tubeId)) {
                _nodesByTubeId[tubeId] = MutableStateFlow(emptyList())
            }
            _nodesByTubeId[tubeId]?.value = result

            // Устанавливаем текущие узлы для отображения
            _currentNodes.value = result
        }
    }

    fun addNode(fullName: String, tubeId: Long, nodeType: NodeType) {
        viewModelScope.launch {
            // Получаем текущие узлы для определения orderIndex
            val currentNodes = withContext(Dispatchers.IO) {
                database.nodeDao().getNodesByTubeId(tubeId)
            }
            val nextOrderIndex = currentNodes.size

            val node = NodeEntity(
                name = fullName,
                tubeId = tubeId,
                nodeType = nodeType.name,
                orderIndex = nextOrderIndex
            )

            withContext(Dispatchers.IO) {
                database.nodeDao().insert(node)
            }
            loadNodesByTubeId(tubeId)
        }
    }

    fun deleteNode(id: Long, tubeId: Long) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.nodeDao().deleteById(id)
            }
            // После удаления пересчитываем порядок
            reorderNodesAfterDeletion(tubeId)
        }
    }

    fun updateNode(id: Long, newName: String, tubeId: Long) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.nodeDao().update(id, newName)
            }
            loadNodesByTubeId(tubeId)
        }
    }

    // Функция для обновления порядка узлов
    fun updateNodesOrder(tubeId: Long, newOrder: List<NodeEntity>) {
        viewModelScope.launch {
            val updatedNodes = newOrder.mapIndexed { index, node ->
                node.copy(orderIndex = index)
            }

            withContext(Dispatchers.IO) {
                updatedNodes.forEach { node ->
                    database.nodeDao().updateOrder(node.id, node.orderIndex)
                }
            }

            loadNodesByTubeId(tubeId)
        }
    }

    // Пересчет порядка после удаления
    private suspend fun reorderNodesAfterDeletion(tubeId: Long) {
        val remainingNodes = withContext(Dispatchers.IO) {
            database.nodeDao().getNodesByTubeId(tubeId)
        }

        val reorderedNodes = remainingNodes.sortedBy { it.orderIndex }.mapIndexed { index, node ->
            node.copy(orderIndex = index)
        }

        withContext(Dispatchers.IO) {
            reorderedNodes.forEach { node ->
                database.nodeDao().updateOrder(node.id, node.orderIndex)
            }
        }

        loadNodesByTubeId(tubeId)
    }

    // Добавьте этот метод в класс NodeViewModel
// В NodeViewModel, в методе moveNode добавьте логирование:
// В NodeViewModel
    fun moveNode(tubeId: Long, fromIndex: Int, toIndex: Int) {
        viewModelScope.launch {
            try {
                val nodes = withContext(Dispatchers.IO) {
                    database.nodeDao().getNodesByTubeId(tubeId)
                }.sortedBy { it.orderIndex }

                if (fromIndex in nodes.indices && toIndex in nodes.indices) {
                    val updatedNodes = nodes.toMutableList()
                    val movedNode = updatedNodes.removeAt(fromIndex)
                    updatedNodes.add(toIndex, movedNode)

                    // Обновляем порядковые номера
                    val reorderedNodes = updatedNodes.mapIndexed { index, node ->
                        node.copy(orderIndex = index)
                    }

                    // Сохраняем в базу
                    withContext(Dispatchers.IO) {
                        reorderedNodes.forEach { node ->
                            database.nodeDao().updateOrder(node.id, node.orderIndex)
                        }
                    }

                    // Немедленно обновляем UI
                    loadNodesByTubeId(tubeId)
                }
            } catch (e: Exception) {
                // Обработка ошибок
                e.printStackTrace()
            }
        }
    }

    // В NodeViewModel
    fun reorderNodes(tubeId: Long, fromIndex: Int, toIndex: Int) {
        viewModelScope.launch {
            println("🔄 REORDER: Moving from $fromIndex to $toIndex in tube $tubeId")

            try {
                // Получаем текущие узлы
                val nodes = withContext(Dispatchers.IO) {
                    database.nodeDao().getNodesByTubeId(tubeId)
                }.sortedBy { it.orderIndex }

                println("📊 BEFORE: ${nodes.map { it.name }}")

                if (fromIndex in nodes.indices && toIndex in nodes.indices) {
                    // Создаем копию и перемещаем элемент
                    val updatedNodes = nodes.toMutableList()
                    val movedNode = updatedNodes.removeAt(fromIndex)
                    updatedNodes.add(toIndex, movedNode)

                    // Обновляем порядковые номера
                    val reorderedNodes = updatedNodes.mapIndexed { index, node ->
                        node.copy(orderIndex = index)
                    }

                    println("📊 AFTER: ${reorderedNodes.map { it.name }}")

                    // Сохраняем в базу
                    withContext(Dispatchers.IO) {
                        reorderedNodes.forEach { node ->
                            database.nodeDao().updateOrder(node.id, node.orderIndex)
                        }
                    }

                    // Обновляем UI
                    loadNodesByTubeId(tubeId)
                }
            } catch (e: Exception) {
                println("❌ ERROR: ${e.message}")
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\NodeViewModelFactory.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.example.kipia.database.AppDatabase

class NodeViewModelFactory(private val database: AppDatabase) : ViewModelProvider.Factory {
    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(NodeViewModel::class.java)) {
            return NodeViewModel(database) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\PermissionScreen.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import android.Manifest
import android.os.Build
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.core.content.ContextCompat
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.isGranted
import com.google.accompanist.permissions.rememberMultiplePermissionsState

@OptIn(ExperimentalPermissionsApi::class, ExperimentalMaterial3Api::class)
@Composable
fun PermissionScreen(
    onPermissionsGranted: () -> Unit,
    onSkip: () -> Unit
) {
    val context = LocalContext.current

    // Список необходимых разрешений
    val requiredPermissions = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
        listOf(
            Manifest.permission.ACCESS_FINE_LOCATION,
            Manifest.permission.BLUETOOTH_ADVERTISE,
            Manifest.permission.BLUETOOTH_CONNECT,
            Manifest.permission.BLUETOOTH_SCAN,
            Manifest.permission.ACCESS_WIFI_STATE,
            Manifest.permission.CHANGE_WIFI_STATE,
            Manifest.permission.NEARBY_WIFI_DEVICES
        )
    } else {
        listOf(
            Manifest.permission.ACCESS_FINE_LOCATION,
            Manifest.permission.BLUETOOTH,
            Manifest.permission.BLUETOOTH_ADMIN,
            Manifest.permission.ACCESS_WIFI_STATE,
            Manifest.permission.CHANGE_WIFI_STATE
        )
    }

    val permissionState = rememberMultiplePermissionsState(permissions = requiredPermissions)

    // Проверяем, все ли разрешения уже предоставлены
    val allPermissionsGranted = requiredPermissions.all { permission ->
        ContextCompat.checkSelfPermission(context, permission) == android.content.pm.PackageManager.PERMISSION_GRANTED
    }

    // Если все разрешения уже есть, переходим дальше
    LaunchedEffect(allPermissionsGranted) {
        if (allPermissionsGranted) {
            onPermissionsGranted()
        }
    }

    // Если пользователь предоставил все разрешения через диалог
    LaunchedEffect(permissionState.allPermissionsGranted) {
        if (permissionState.allPermissionsGranted) {
            onPermissionsGranted()
        }
    }

    Scaffold(
        topBar = {
            CenterAlignedTopAppBar(
                title = {
                    Text(
                        "Разрешения для синхронизации",
                        fontWeight = FontWeight.Bold
                    )
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .verticalScroll(rememberScrollState())
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(24.dp)
        ) {
            // Заголовок
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.Sync,
                    contentDescription = "Синхронизация",
                    modifier = Modifier.size(64.dp),
                    tint = MaterialTheme.colorScheme.primary
                )

                Text(
                    text = "Необходимые разрешения",
                    fontSize = 24.sp,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onSurface
                )

                Text(
                    text = "Для работы синхронизации между устройствами требуются следующие разрешения:",
                    fontSize = 16.sp,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f),
                    textAlign = androidx.compose.ui.text.style.TextAlign.Center
                )
            }

            // Список разрешений с пояснениями
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                PermissionItem(
                    icon = Icons.Default.LocationOn,
                    title = "Доступ к местоположению",
                    description = "Нужен для поиска nearby устройств через Bluetooth и WiFi",
                    isGranted = permissionState.permissions.getOrNull(0)?.status?.isGranted == true
                )

                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                    PermissionItem(
                        icon = Icons.Default.Bluetooth,
                        title = "Bluetooth (Android 12+)",
                        description = "Разрешения на подключение, сканирование и трансляцию",
                        isGranted = permissionState.permissions.getOrNull(1)?.status?.isGranted == true &&
                                permissionState.permissions.getOrNull(2)?.status?.isGranted == true &&
                                permissionState.permissions.getOrNull(3)?.status?.isGranted == true
                    )
                } else {
                    PermissionItem(
                        icon = Icons.Default.Bluetooth,
                        title = "Bluetooth",
                        description = "Разрешения на использование Bluetooth",
                        isGranted = permissionState.permissions.getOrNull(1)?.status?.isGranted == true &&
                                permissionState.permissions.getOrNull(2)?.status?.isGranted == true
                    )
                }

                PermissionItem(
                    icon = Icons.Default.Wifi,
                    title = "Управление WiFi",
                    description = "Для поиска устройств в локальной сети",
                    isGranted = permissionState.permissions.getOrNull(
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) 4 else 3
                    )?.status?.isGranted == true
                )
            }

            // Пояснительный текст
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.surfaceVariant
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Text(
                        text = "Почему нужны эти разрешения?",
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        text = "• Местоположение: для поиска nearby устройств\n" +
                                "• Bluetooth: для прямого подключения между телефонами\n" +
                                "• WiFi: для обнаружения устройств в локальной сети\n" +
                                "• Ваши данные остаются на устройстве и не передаются в интернет",
                        color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.8f),
                        fontSize = 14.sp
                    )
                }
            }

            // Кнопки действий
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                if (!permissionState.allPermissionsGranted) {
                    Button(
                        onClick = {
                            permissionState.launchMultiplePermissionRequest()
                        },
                        modifier = Modifier.fillMaxWidth(),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.primary
                        )
                    ) {
                        Icon(Icons.Default.Check, contentDescription = null)
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("Предоставить все разрешения")
                    }
                } else {
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(
                            containerColor = MaterialTheme.colorScheme.primaryContainer
                        )
                    ) {
                        Row(
                            modifier = Modifier.padding(16.dp),
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.Center
                        ) {
                            Icon(
                                Icons.Default.CheckCircle,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.primary
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(
                                "Все разрешения предоставлены!",
                                fontWeight = FontWeight.Medium,
                                color = MaterialTheme.colorScheme.onPrimaryContainer
                            )
                        }
                    }

                    Button(
                        onClick = onPermissionsGranted,
                        modifier = Modifier.fillMaxWidth(),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.primary
                        )
                    ) {
                        Text("Продолжить синхронизацию")
                    }
                }

                // Кнопка пропуска (только если не все разрешения)
                if (!permissionState.allPermissionsGranted) {
                    TextButton(
                        onClick = onSkip,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Пропустить и перейти к ручной синхронизации")
                    }
                }
            }
        }
    }
}

@Composable
fun PermissionItem(
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    title: String,
    description: String,
    isGranted: Boolean
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = if (isGranted) {
                MaterialTheme.colorScheme.primaryContainer
            } else {
                MaterialTheme.colorScheme.surface
            }
        ),
        border = CardDefaults.outlinedCardBorder()
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Icon(
                imageVector = icon,
                contentDescription = null,
                tint = if (isGranted) {
                    MaterialTheme.colorScheme.primary
                } else {
                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)
                },
                modifier = Modifier.size(32.dp)
            )

            Column(
                modifier = Modifier.weight(1f),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Text(
                    text = title,
                    fontWeight = FontWeight.Medium,
                    color = if (isGranted) {
                        MaterialTheme.colorScheme.onPrimaryContainer
                    } else {
                        MaterialTheme.colorScheme.onSurface
                    }
                )
                Text(
                    text = description,
                    fontSize = 14.sp,
                    color = if (isGranted) {
                        MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.8f)
                    } else {
                        MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)
                    }
                )
            }

            Icon(
                imageVector = if (isGranted) Icons.Default.CheckCircle else Icons.Default.Info,
                contentDescription = if (isGranted) "Разрешено" else "Требуется",
                tint = if (isGranted) {
                    MaterialTheme.colorScheme.primary
                } else {
                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.4f)
                }
            )
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\PhotoPickerUtils.kt ---
------------------------------------------------------------

package com.example.kipia.utils

import android.net.Uri
import android.util.Log
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.runtime.Composable

@Composable
fun rememberPhotoPickerLauncher(
    onPhotosSelected: (List<Uri>) -> Unit
) = rememberLauncherForActivityResult(
    contract = ActivityResultContracts.PickMultipleVisualMedia(),
    onResult = { uris ->
        Log.d("PhotoPicker", "Photo picker result: ${uris?.size ?: 0} photos selected")
        try {
            onPhotosSelected(uris ?: emptyList())
        } catch (e: Exception) {
            Log.e("PhotoPicker", "Error in photo picker result", e)
            onPhotosSelected(emptyList())
        }
    }
)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\PKUItem.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material.icons.filled.KeyboardArrowUp
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.example.kipia.database.PKUEntity
import com.example.kipia.database.SectionEntity

@Composable
fun PKUItem(
    pku: PKUEntity,
    sectionViewModel: SectionViewModel,
    onEdit: (PKUEntity) -> Unit,
    onDelete: () -> Unit,
    onAddSection: (String, Long) -> Unit,
    onViewSectionEquipment: (Long) -> Unit = {}
) {
    var expanded by remember { mutableStateOf(false) }
    var showAddSectionDialog by remember { mutableStateOf(false) }

    val sections by sectionViewModel.sections.collectAsState()

    // Загружаем секции при создании
    LaunchedEffect(pku.id) {
        sectionViewModel.loadSectionsByPKUId(pku.id)
    }

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 2.dp),
        elevation = 2.dp,
        backgroundColor = MaterialTheme.colors.surface
    ) {
        Column(modifier = Modifier.padding(8.dp)) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Кнопка раскрытия/скрытия секций
                IconButton(
                    onClick = { expanded = !expanded },
                    modifier = Modifier.size(24.dp)
                ) {
                    Icon(
                        if (expanded) Icons.Default.KeyboardArrowUp else Icons.Default.KeyboardArrowDown,
                        contentDescription = if (expanded) "Скрыть секции" else "Показать секции"
                    )
                }

                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = pku.name,
                        style = MaterialTheme.typography.body1,
                        color = MaterialTheme.colors.onSurface
                    )
                    if (pku.description.isNotEmpty()) {
                        Text(
                            text = pku.description,
                            style = MaterialTheme.typography.body2,
                            color = MaterialTheme.colors.onSurface.copy(alpha = 0.7f)
                        )
                    }
                }

                // Кнопка добавления секции
                IconButton(
                    onClick = { showAddSectionDialog = true },
                    modifier = Modifier.size(40.dp)
                ) {
                    Icon(
                        Icons.Default.Add,
                        contentDescription = "Добавить секцию",
                        tint = MaterialTheme.colors.onSurface
                    )
                }

                // Кнопка редактирования ПКУ
                IconButton(
                    onClick = { onEdit(pku) },
                    modifier = Modifier.size(40.dp)
                ) {
                    Icon(
                        Icons.Default.Edit,
                        contentDescription = "Редактировать ПКУ",
                        tint = MaterialTheme.colors.onSurface
                    )
                }

                // Кнопка удаления ПКУ
                IconButton(
                    onClick = onDelete,
                    modifier = Modifier.size(40.dp)
                ) {
                    Icon(
                        Icons.Default.Delete,
                        contentDescription = "Удалить ПКУ",
                        tint = MaterialTheme.colors.onSurface
                    )
                }
            }

            // Секции ПКУ (показываются при раскрытии)
            if (expanded) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 8.dp)
                ) {
                    if (sections.isEmpty()) {
                        Text(
                            text = "Нет секций",
                            style = MaterialTheme.typography.caption,
                            color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f),
                            modifier = Modifier.padding(start = 32.dp, top = 8.dp, bottom = 8.dp)
                        )
                    } else {
                        sections.forEach { section ->
                            SectionItem(
                                section = section,
                                onViewEquipment = { onViewSectionEquipment(section.id) },
                                onDeleteSection = { sectionViewModel.deleteSection(section) }
                            )
                        }
                    }
                }
            }
        }
    }

    if (showAddSectionDialog) {
        AddSectionDialog(
            pkuName = pku.name,
            onDismiss = { showAddSectionDialog = false },
            onConfirm = { sectionName ->
                onAddSection(sectionName, pku.id)
                showAddSectionDialog = false
            }
        )
    }
}

// Обновленный компонент для отображения секции
@Composable
fun SectionItem(
    section: SectionEntity,
    onViewEquipment: () -> Unit,
    onDeleteSection: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(start = 32.dp, top = 4.dp, bottom = 4.dp)
            .clickable { onViewEquipment() },
        elevation = 1.dp,
        backgroundColor = MaterialTheme.colors.surface.copy(alpha = 0.8f)
    ) {
        Row(
            modifier = Modifier.padding(8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = section.name,
                style = MaterialTheme.typography.body2,
                modifier = Modifier.weight(1f),
                color = MaterialTheme.colors.onSurface
            )

            // Кнопка просмотра оборудования
            IconButton(
                onClick = onViewEquipment,
                modifier = Modifier.size(20.dp)
            ) {
                Icon(
                    Icons.Default.Add,
                    contentDescription = "Просмотр оборудования",
                    modifier = Modifier.size(14.dp),
                    tint = MaterialTheme.colors.onSurface
                )
            }

            // Кнопка удаления секции
            IconButton(
                onClick = onDeleteSection,
                modifier = Modifier.size(20.dp)
            ) {
                Icon(
                    Icons.Default.Delete,
                    contentDescription = "Удалить секцию",
                    modifier = Modifier.size(14.dp),
                    tint = MaterialTheme.colors.onSurface
                )
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\PKUViewModel.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.kipia.database.AppDatabase
import com.example.kipia.database.PKUEntity
import com.example.kipia.database.SectionEntity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class PKUViewModel(private val database: AppDatabase) : ViewModel() {

    private val _pkus = MutableStateFlow<List<PKUEntity>>(emptyList())
    val pkus: StateFlow<List<PKUEntity>> = _pkus

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    private val _errorMessage = MutableStateFlow<String?>(null)
    val errorMessage: StateFlow<String?> = _errorMessage

    fun loadPKUsByControlPointId(controlPointId: Long) {
        viewModelScope.launch {
            _isLoading.value = true
            _errorMessage.value = null
            try {
                val result = withContext(Dispatchers.IO) {
                    database.pkuDao().getPKUsByControlPointId(controlPointId)
                }
                _pkus.value = result
            } catch (e: Exception) {
                _errorMessage.value = "Не удалось загрузить ПКУ: ${e.message}"
            } finally {
                _isLoading.value = false
            }
        }
    }

    fun clearError() {
        _errorMessage.value = null
    }

    // Метод addPKU - добавление ПКУ с автоматическим созданием стандартных отсеков
    fun addPKU(name: String, description: String = "", controlPointId: Long) {
        viewModelScope.launch {
            // Сначала создаем ПКУ
            val pku = PKUEntity(name = name, description = description, controlPointId = controlPointId)
            withContext(Dispatchers.IO) {
                database.pkuDao().insert(pku)
            }

            // Находим созданный ПКУ по имени и controlPointId
            val pkus = withContext(Dispatchers.IO) {
                database.pkuDao().getPKUsByControlPointId(controlPointId)
            }
            val newPKU = pkus.find { it.name == name && it.controlPointId == controlPointId }

            // Автоматически создаем стандартные отсеки
            newPKU?.let { pku ->
                val defaultSections = listOf(
                    SectionEntity(name = "Инженерный отсек", pkuId = pku.id),
                    SectionEntity(name = "Трансформаторный отсек", pkuId = pku.id)
                )

                withContext(Dispatchers.IO) {
                    defaultSections.forEach { section ->
                        database.sectionDao().insert(section)
                    }
                }
            }

            loadPKUsByControlPointId(controlPointId)
        }
    }

    fun deletePKU(id: Long, controlPointId: Long) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.pkuDao().deleteById(id)
            }
            loadPKUsByControlPointId(controlPointId)
        }
    }

    fun updatePKU(id: Long, newName: String, newDescription: String = "") {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.pkuDao().update(id, newName, newDescription)
            }
            // Обновляем список ПКУ для текущего КП
            val current = withContext(Dispatchers.IO) {
                database.pkuDao().getPKUById(id)
            }
            current?.let { pku ->
                loadPKUsByControlPointId(pku.controlPointId)
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\PKUViewModelFactory.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/PKUViewModelFactory.kt

package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.example.kipia.database.AppDatabase

class PKUViewModelFactory(private val database: AppDatabase) : ViewModelProvider.Factory {
    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(PKUViewModel::class.java)) {
            return PKUViewModel(database) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\RemarkComponents.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material.icons.filled.Edit
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import com.example.kipia.database.RemarkEntity

@Composable
fun RemarkItemCard(
    remark: RemarkEntity,
    onStatusChange: (String) -> Unit,
    onEdit: () -> Unit,
    showPhotos: Boolean = true
) {
    val photoPaths = remark.getPhotoList()

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 8.dp, vertical = 4.dp),
        elevation = 2.dp,
        backgroundColor = getRemarkCardColor(remark.priority, remark.status)
    ) {
        Column(modifier = Modifier.padding(12.dp)) {
            // Первая строка: заголовок + приоритет + дата
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = remark.title,
                    style = MaterialTheme.typography.subtitle1,
                    modifier = Modifier.weight(1f),
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )

                // Бейдж приоритета
                PriorityBadge(remark.priority)

                Text(
                    text = remark.deadline,
                    style = MaterialTheme.typography.caption,
                    color = getDeadlineColor(remark.deadline),
                    modifier = Modifier.padding(start = 8.dp)
                )
            }

            // Вторая строка: описание (если есть)
            if (remark.description.isNotEmpty()) {
                Text(
                    text = remark.description,
                    style = MaterialTheme.typography.body2,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis,
                    modifier = Modifier.padding(top = 4.dp)
                )
            }

            // Индикатор фото (если есть фото)
            if (showPhotos && photoPaths.isNotEmpty()) {
                Spacer(modifier = Modifier.height(4.dp))
                Text(
                    text = "📷 ${photoPaths.size} фото",
                    style = MaterialTheme.typography.caption,
                    color = MaterialTheme.colors.primary,
                    modifier = Modifier.padding(top = 4.dp)
                )
            }

            // Третья строка: категория + статус + действия
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 8.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Категория
                Text(
                    text = when (remark.category) {
                        "Документация" -> "Документы"
                        "Оборудование" -> "Оборуд."
                        else -> remark.category
                    },
                    style = MaterialTheme.typography.caption,
                    color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f)
                )

                Spacer(modifier = Modifier.weight(1f))

                // Селектор статуса
                StatusDropdown(
                    currentStatus = remark.status,
                    onStatusChange = onStatusChange
                )

                Spacer(modifier = Modifier.width(8.dp))

                // Кнопка редактирования
                IconButton(
                    onClick = onEdit,
                    modifier = Modifier.size(24.dp)
                ) {
                    Icon(
                        Icons.Default.Edit,
                        contentDescription = "Редактировать",
                        modifier = Modifier.size(16.dp)
                    )
                }
            }
        }
    }
}

@Composable
fun PriorityBadge(priority: String) {
    Box(
        modifier = Modifier
            .clip(CircleShape)
            .background(getPriorityColor(priority).copy(alpha = 0.2f))
            .padding(horizontal = 8.dp, vertical = 2.dp)
    ) {
        Text(
            text = getPriorityEmoji(priority),
            style = MaterialTheme.typography.caption
        )
    }
}

@Composable
fun StatusDropdown(
    currentStatus: String,
    onStatusChange: (String) -> Unit
) {
    var expanded by remember { mutableStateOf(false) }

    Box {
        TextButton(
            onClick = { expanded = true },
            colors = ButtonDefaults.textButtonColors(
                contentColor = getStatusColor(currentStatus)
            )
        ) {
            Text(
                text = currentStatus,
                style = MaterialTheme.typography.caption
            )
            Icon(
                Icons.Default.ArrowDropDown,
                contentDescription = "Изменить статус",
                modifier = Modifier.size(16.dp)
            )
        }

        DropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false }
        ) {
            listOf("Открыто", "В работе", "Выполнено").forEach { status ->
                DropdownMenuItem(onClick = {
                    onStatusChange(status)
                    expanded = false
                }) {
                    Text(status)
                }
            }
        }
    }
}

@Composable
fun RemarkStats(remarks: List<RemarkEntity>) {
    val total = remarks.size
    val completed = remarks.count { it.status == "Выполнено" }
    val inProgress = remarks.count { it.status == "В работе" }
    val highPriority = remarks.count { it.priority == "Высокий" && it.status != "Выполнено" }

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp),
        elevation = 4.dp
    ) {
        Row(
            modifier = Modifier.padding(12.dp),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            StatItem("Всего", total.toString())
            StatItem("Выполнено", completed.toString(), getStatusColor("Выполнено"))
            StatItem("В работе", inProgress.toString(), getStatusColor("В работе"))
            StatItem("Срочные", highPriority.toString(), getPriorityColor("Высокий"))
        }
    }
}

@Composable
fun StatItem(label: String, value: String, color: Color = MaterialTheme.colors.primary) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(
            text = value,
            style = MaterialTheme.typography.h6,
            color = color
        )
        Text(
            text = label,
            style = MaterialTheme.typography.caption,
            color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f)
        )
    }
}

@Composable
fun RemarkFilters(
    selectedCategory: String = "Все",
    onCategoryChange: (String) -> Unit = {}
) {
    val categories = listOf("Все", "Оборудование", "Безопасность", "Документация", "Прочее")

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 8.dp),
        horizontalArrangement = Arrangement.SpaceEvenly
    ) {
        categories.forEach { category ->
            FilterChip(
                label = category,
                isSelected = category == selectedCategory,
                onSelected = { onCategoryChange(category) }
            )
        }
    }
}

@Composable
fun FilterChip(
    label: String,
    isSelected: Boolean,
    onSelected: () -> Unit
) {
    val backgroundColor = if (isSelected) MaterialTheme.colors.primary else Color.Transparent
    val contentColor = if (isSelected) MaterialTheme.colors.onPrimary else MaterialTheme.colors.onSurface

    // Сокращаем длинные названия
    val displayLabel = when (label) {
        "Документация" -> "Документы"
        "Оборудование" -> "Оборуд."
        else -> label
    }

    Card(
        modifier = Modifier
            .clickable { onSelected() },
        elevation = if (isSelected) 4.dp else 0.dp,
        backgroundColor = backgroundColor,
        border = if (!isSelected) {
            ButtonDefaults.outlinedBorder
        } else null
    ) {
        Text(
            text = displayLabel,
            color = contentColor,
            style = MaterialTheme.typography.caption,
            modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp)
        )
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\RemarkDetailScreen.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.platform.LocalContext
import coil.compose.AsyncImage
import android.net.Uri
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale

@Composable
fun RemarkDetailScreen(
    remarkId: Long,
    onBackClick: () -> Unit,
    onEditClick: () -> Unit,
    onDeleteClick: () -> Unit
) {
    // TODO: Загрузить данные замечания по ID
    // Пока заглушка - в реальности нужно загрузить из базы данных
    val remark = remember {
        // Заглушка - в реальности нужно загрузить из ViewModel
        com.example.kipia.database.RemarkEntity(
            id = remarkId,
            controlPointId = 1,
            title = "Пример замечания",
            description = "Подробное описание замечания",
            category = "Оборудование",
            priority = "Высокий",
            status = "Открыто",
            createdDate = "20.11.2023",
            deadline = "27.11.2023",
            completedDate = "",
            photos = ""
        )
    }

    val photoPaths = remark.getPhotoList()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Замечание") },
                navigationIcon = {
                    IconButton(onClick = onBackClick) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Назад")
                    }
                },
                actions = {
                    IconButton(onClick = onEditClick) {
                        Icon(Icons.Default.Edit, contentDescription = "Редактировать")
                    }
                    IconButton(onClick = onDeleteClick) {
                        Icon(Icons.Default.Delete, contentDescription = "Удалить")
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .padding(innerPadding)
                .fillMaxSize()
                .verticalScroll(rememberScrollState())
        ) {
            // Карточка с основной информацией
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                elevation = 4.dp
            ) {
                Column(modifier = Modifier.padding(16.dp)) {
                    // Заголовок и приоритет
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = remark.title,
                            style = MaterialTheme.typography.h6
                        )
                        PriorityBadge(remark.priority)
                    }

                    Spacer(modifier = Modifier.height(8.dp))

                    // Описание
                    if (remark.description.isNotEmpty()) {
                        Text(
                            text = "Описание:",
                            style = MaterialTheme.typography.subtitle2,
                            color = MaterialTheme.colors.primary
                        )
                        Text(
                            text = remark.description,
                            style = MaterialTheme.typography.body1,
                            modifier = Modifier.padding(top = 4.dp)
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                    }

                    // Детали
                    RemarkDetailItem("Категория", remark.category)
                    RemarkDetailItem("Статус", remark.status)
                    RemarkDetailItem("Дата создания", remark.createdDate)
                    RemarkDetailItem("Срок устранения", remark.deadline)

                    if (remark.completedDate.isNotEmpty()) {
                        RemarkDetailItem("Дата выполнения", remark.completedDate)
                    }
                }
            }

            // Секция с фото
            if (photoPaths.isNotEmpty()) {
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    elevation = 4.dp
                ) {
                    Column(modifier = Modifier.padding(16.dp)) {
                        Text(
                            text = "Прикрепленные фото (${photoPaths.size})",
                            style = MaterialTheme.typography.h6
                        )

                        Spacer(modifier = Modifier.height(8.dp))

                        // Отображение фото в сетке
                        val columns = 2
                        val rows = (photoPaths.size + columns - 1) / columns

                        Column {
                            for (i in 0 until rows) {
                                Row(
                                    modifier = Modifier.fillMaxWidth(),
                                    horizontalArrangement = Arrangement.SpaceEvenly
                                ) {
                                    for (j in 0 until columns) {
                                        val index = i * columns + j
                                        if (index < photoPaths.size) {
                                            val uri = Uri.parse(photoPaths[index])
                                            Box(
                                                modifier = Modifier
                                                    .weight(1f)
                                                    .padding(4.dp)
                                                    .aspectRatio(1f)
                                            ) {
                                                AsyncImage(
                                                    model = uri,
                                                    contentDescription = "Фото замечания",
                                                    modifier = Modifier
                                                        .fillMaxSize()
                                                        .clip(MaterialTheme.shapes.medium),
                                                    contentScale = ContentScale.Crop
                                                )
                                            }
                                        } else {
                                            Spacer(modifier = Modifier.weight(1f))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // История изменений (можно добавить позже)
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                elevation = 4.dp
            ) {
                Column(modifier = Modifier.padding(16.dp)) {
                    Text(
                        text = "История изменений",
                        style = MaterialTheme.typography.h6
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = "Создано: ${remark.createdDate}",
                        style = MaterialTheme.typography.caption
                    )
                    if (remark.completedDate.isNotEmpty()) {
                        Text(
                            text = "Завершено: ${remark.completedDate}",
                            style = MaterialTheme.typography.caption
                        )
                    }
                }
            }
        }
    }
}

@Composable
fun RemarkDetailItem(label: String, value: String) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp)
    ) {
        Text(
            text = "$label:",
            style = MaterialTheme.typography.subtitle2,
            modifier = Modifier.weight(1f)
        )
        Text(
            text = value,
            style = MaterialTheme.typography.body1,
            modifier = Modifier.weight(1f)
        )
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\RemarksTab.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Edit
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import com.example.kipia.database.RemarkEntity

@Composable
fun RemarksTab(
    remarks: List<RemarkEntity>,
    onAddRemarkWithPhotos: (String, String, String, String, String, List<String>) -> Unit,
    onEditRemark: (RemarkEntity) -> Unit,
    onUpdateStatus: (Long, String) -> Unit,
    controlPointName: String = ""
) {
    var selectedCategory by remember { mutableStateOf("Все") }
    var showAddDialog by remember { mutableStateOf(false) }
    var editingRemark by remember { mutableStateOf<RemarkEntity?>(null) }
    var viewingRemark by remember { mutableStateOf<RemarkEntity?>(null) }

    val filteredRemarks = if (selectedCategory == "Все") {
        remarks
    } else {
        remarks.filter { it.category == selectedCategory }
    }

    // ИСПОЛЬЗУЕМ Box для плавающей кнопки
    Box(modifier = Modifier.fillMaxSize()) {
        Column(modifier = Modifier.fillMaxSize()) {
            // УБИРАЕМ КНОПКУ ИЗ ВЕРХНЕЙ ЧАСТИ

            // Статистика
            if (remarks.isNotEmpty()) {
                RemarkStats(remarks)
            }

            // Быстрые фильтры
            RemarkFilters(
                selectedCategory = selectedCategory,
                onCategoryChange = { selectedCategory = it }
            )

            Spacer(modifier = Modifier.height(8.dp))

            // Список замечаний
            if (filteredRemarks.isNotEmpty()) {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .weight(1f)
                ) {
                    items(filteredRemarks) { remark ->
                        // КАРТОЧКА С КЛИКОМ ДЛЯ ПРОСМОТРА
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(horizontal = 8.dp, vertical = 4.dp)
                                .clickable { viewingRemark = remark }, // ОТКРЫВАЕМ ПРОСМОТР
                            elevation = 2.dp,
                            backgroundColor = getRemarkCardColor(remark.priority, remark.status)
                        ) {
                            Column(modifier = Modifier.padding(12.dp)) {
                                // Первая строка: заголовок + приоритет + дата
                                Row(
                                    modifier = Modifier.fillMaxWidth(),
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    Text(
                                        text = remark.title,
                                        style = MaterialTheme.typography.subtitle1,
                                        modifier = Modifier.weight(1f),
                                        maxLines = 1,
                                        overflow = TextOverflow.Ellipsis
                                    )

                                    PriorityBadge(remark.priority)

                                    Text(
                                        text = remark.deadline,
                                        style = MaterialTheme.typography.caption,
                                        color = getDeadlineColor(remark.deadline),
                                        modifier = Modifier.padding(start = 8.dp)
                                    )
                                }

                                // Вторая строка: описание (если есть)
                                if (remark.description.isNotEmpty()) {
                                    Text(
                                        text = remark.description,
                                        style = MaterialTheme.typography.body2,
                                        maxLines = 2,
                                        overflow = TextOverflow.Ellipsis,
                                        modifier = Modifier.padding(top = 4.dp)
                                    )
                                }

                                // Индикатор фото
                                val photoPaths = remark.getPhotoList()
                                if (photoPaths.isNotEmpty()) {
                                    Spacer(modifier = Modifier.height(4.dp))
                                    Text(
                                        text = "📷 ${photoPaths.size} фото",
                                        style = MaterialTheme.typography.caption,
                                        color = MaterialTheme.colors.primary,
                                        modifier = Modifier.padding(top = 4.dp)
                                    )
                                }

                                // Третья строка: категория + статус + действия
                                Row(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .padding(top = 8.dp),
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    // Категория
                                    Text(
                                        text = when (remark.category) {
                                            "Документация" -> "Документы"
                                            "Оборудование" -> "Оборуд."
                                            else -> remark.category
                                        },
                                        style = MaterialTheme.typography.caption,
                                        color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f)
                                    )

                                    Spacer(modifier = Modifier.weight(1f))

                                    // Селектор статуса
                                    StatusDropdown(
                                        currentStatus = remark.status,
                                        onStatusChange = { newStatus ->
                                            onUpdateStatus(remark.id, newStatus)
                                        }
                                    )

                                    Spacer(modifier = Modifier.width(8.dp))

                                    // Кнопка редактирования
                                    IconButton(
                                        onClick = { editingRemark = remark },
                                        modifier = Modifier.size(24.dp)
                                    ) {
                                        Icon(
                                            Icons.Default.Edit,
                                            contentDescription = "Редактировать",
                                            modifier = Modifier.size(16.dp)
                                        )
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                // Сообщение, если замечаний нет
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .weight(1f),
                    contentAlignment = Alignment.Center
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text(
                            text = if (remarks.isEmpty()) "Нет замечаний" else "Нет замечаний в выбранной категории",
                            style = MaterialTheme.typography.body1,
                            color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f)
                        )

                        if (remarks.isEmpty()) {
                            Spacer(modifier = Modifier.height(16.dp))
                            Button(
                                onClick = { showAddDialog = true },
                                modifier = Modifier.padding(8.dp)
                            ) {
                                Icon(Icons.Default.Add, contentDescription = null)
                                Spacer(modifier = Modifier.width(8.dp))
                                Text("Создать первое замечание")
                            }
                        }
                    }
                }
            }
        }

        // ПЛАВАЮЩАЯ КНОПКА В ПРАВОМ НИЖНЕМ УГЛУ
        FloatingActionButton(
            onClick = { showAddDialog = true },
            modifier = Modifier
                .align(Alignment.BottomEnd)
                .padding(16.dp),
            backgroundColor = MaterialTheme.colors.primary
        ) {
            Icon(Icons.Default.Add, contentDescription = "Добавить замечание", tint = MaterialTheme.colors.onPrimary)
        }
    }

    // Диалоги (без изменений)
    if (showAddDialog) {
        AddRemarkDialog(
            controlPointName = controlPointName,
            onDismiss = { showAddDialog = false },
            onConfirm = { title, description, category, priority, deadline, photoPaths ->
                onAddRemarkWithPhotos(title, description, category, priority, deadline, photoPaths)
                showAddDialog = false
            }
        )
    }

    if (editingRemark != null) {
        EditRemarkDialog(
            remark = editingRemark!!,
            onDismiss = { editingRemark = null },
            onConfirm = { title, description, category, priority, deadline, photoPaths ->
                val updatedRemark = editingRemark!!.copy(
                    title = title,
                    description = description,
                    category = category,
                    priority = priority,
                    deadline = deadline
                ).withPhotos(photoPaths)

                onEditRemark(updatedRemark)
                editingRemark = null
            }
        )
    }

    if (viewingRemark != null) {
        ViewRemarkDialog(
            remark = viewingRemark!!,
            onDismiss = { viewingRemark = null },
            onEdit = {
                editingRemark = viewingRemark
                viewingRemark = null
            }
        )
    }
}

// УДАЛИТЕ ЭТУ ДУБЛИРУЮЩУЮСЯ ФУНКЦИЮ - она вызывает ошибки!
// @Composable
// fun AddRemarkDialog(
//     controlPointName: String,
//     onDismiss: () -> Unit,
//     onConfirm: (ERROR, ERROR, ERROR, ERROR, ERROR, ERROR) -> Unit
// ) {
//     TODO("Not yet implemented")
// }
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\RemarksTabWithArchive.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Archive
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.filled.Unarchive
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import com.example.kipia.database.RemarkEntity

@Composable
fun RemarksTabWithArchive(
    activeRemarks: List<RemarkEntity>,
    archivedRemarks: List<RemarkEntity>,
    onAddRemarkWithPhotos: (String, String, String, String, String, List<String>) -> Unit,
    onEditRemark: (RemarkEntity) -> Unit,
    onUpdateStatus: (Long, String) -> Unit,
    onArchiveRemark: (Long) -> Unit,
    onUnarchiveRemark: (Long) -> Unit,
    onDeleteRemark: (android.content.Context, RemarkEntity) -> Unit,
    controlPointName: String = ""
) {
    var selectedTab by remember { mutableStateOf(0) }
    var showAddDialog by remember { mutableStateOf(false) }
    val context = LocalContext.current

    val tabs = listOf("Активные (${activeRemarks.size})", "Архив (${archivedRemarks.size})")

    Column(modifier = Modifier.fillMaxSize()) {
        // Вкладки
        TabRow(selectedTabIndex = selectedTab) {
            tabs.forEachIndexed { index, title ->
                Tab(
                    text = {
                        Text(
                            text = title,
                            style = MaterialTheme.typography.caption
                        )
                    },
                    selected = selectedTab == index,
                    onClick = { selectedTab = index }
                )
            }
        }

        // Содержимое вкладок
        when (selectedTab) {
            0 -> {
                // Активные замечания
                RemarksTabContent(
                    remarks = activeRemarks,
                    onAddRemark = { showAddDialog = true },
                    onEditRemark = onEditRemark,
                    onUpdateStatus = onUpdateStatus,
                    onArchiveRemark = onArchiveRemark,
                    onDeleteRemark = { remark -> onDeleteRemark(context, remark) },
                    emptyMessage = "Нет активных замечаний",
                    showArchiveButton = true
                )
            }
            1 -> {
                // Архивные замечания
                RemarksTabContent(
                    remarks = archivedRemarks,
                    onAddRemark = { showAddDialog = true },
                    onEditRemark = onEditRemark,
                    onUpdateStatus = onUpdateStatus,
                    onArchiveRemark = { remarkId -> onUnarchiveRemark(remarkId) },
                    onDeleteRemark = { remark -> onDeleteRemark(context, remark) },
                    emptyMessage = "Архив пуст",
                    showArchiveButton = false,
                    archiveButtonText = "Вернуть из архива"
                )
            }
        }
    }

    // Диалог добавления замечания
    if (showAddDialog) {
        AddRemarkDialog(
            controlPointName = controlPointName,
            onDismiss = { showAddDialog = false },
            onConfirm = { title, description, category, priority, deadline, photoPaths ->
                onAddRemarkWithPhotos(title, description, category, priority, deadline, photoPaths)
                showAddDialog = false
            }
        )
    }
}

@Composable
fun RemarksTabContent(
    remarks: List<RemarkEntity>,
    onAddRemark: () -> Unit,
    onEditRemark: (RemarkEntity) -> Unit,
    onUpdateStatus: (Long, String) -> Unit,
    onArchiveRemark: (Long) -> Unit,
    onDeleteRemark: (RemarkEntity) -> Unit,
    emptyMessage: String,
    showArchiveButton: Boolean,
    archiveButtonText: String = "В архив"
) {
    var selectedCategory by remember { mutableStateOf("Все") }
    var editingRemark by remember { mutableStateOf<RemarkEntity?>(null) }
    var viewingRemark by remember { mutableStateOf<RemarkEntity?>(null) }

    val filteredRemarks = if (selectedCategory == "Все") {
        remarks
    } else {
        remarks.filter { it.category == selectedCategory }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        Column(modifier = Modifier.fillMaxSize()) {
            // Статистика
            if (remarks.isNotEmpty()) {
                RemarkStats(remarks)
            }

            // Фильтры
            RemarkFilters(
                selectedCategory = selectedCategory,
                onCategoryChange = { selectedCategory = it }
            )

            Spacer(modifier = Modifier.height(8.dp))

            // Список замечаний
            if (filteredRemarks.isNotEmpty()) {
                RemarkList(
                    remarks = filteredRemarks,
                    onEditRemark = { editingRemark = it },
                    onViewRemark = { viewingRemark = it },
                    onUpdateStatus = onUpdateStatus,
                    onArchiveRemark = onArchiveRemark,
                    onDeleteRemark = onDeleteRemark,
                    showArchiveButton = showArchiveButton,
                    archiveButtonText = archiveButtonText
                )
            } else {
                EmptyRemarksMessage(
                    message = emptyMessage,
                    onAddRemark = onAddRemark,
                    showAddButton = emptyMessage == "Нет активных замечаний"
                )
            }
        }

        // Плавающая кнопка только для активных замечаний
        if (emptyMessage == "Нет активных замечаний") {
            FloatingActionButton(
                onClick = onAddRemark,
                modifier = Modifier
                    .align(Alignment.BottomEnd)
                    .padding(16.dp),
                backgroundColor = MaterialTheme.colors.primary
            ) {
                Icon(Icons.Default.Add, contentDescription = "Добавить замечание")
            }
        }
    }

    // Диалоги
    editingRemark?.let { remark ->
        EditRemarkDialog(
            remark = remark,
            onDismiss = { editingRemark = null },
            onConfirm = { title, description, category, priority, deadline, photoPaths ->
                val updatedRemark = remark.copy(
                    title = title,
                    description = description,
                    category = category,
                    priority = priority,
                    deadline = deadline
                ).withPhotos(photoPaths)
                onEditRemark(updatedRemark)
                editingRemark = null
            }
        )
    }

    viewingRemark?.let { remark ->
        ViewRemarkDialog(
            remark = remark,
            onDismiss = { viewingRemark = null },
            onEdit = {
                editingRemark = remark
                viewingRemark = null
            }
        )
    }
}

@Composable
fun RemarkList(
    remarks: List<RemarkEntity>,
    onEditRemark: (RemarkEntity) -> Unit,
    onViewRemark: (RemarkEntity) -> Unit,
    onUpdateStatus: (Long, String) -> Unit,
    onArchiveRemark: (Long) -> Unit,
    onDeleteRemark: (RemarkEntity) -> Unit,
    showArchiveButton: Boolean,
    archiveButtonText: String
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
    ) {
        remarks.forEach { remark ->
            RemarkItemWithActions(
                remark = remark,
                onView = { onViewRemark(remark) },
                onEdit = { onEditRemark(remark) },
                onStatusChange = { newStatus -> onUpdateStatus(remark.id, newStatus) },
                onArchive = { onArchiveRemark(remark.id) },
                onDelete = { onDeleteRemark(remark) },
                showArchiveButton = showArchiveButton,
                archiveButtonText = archiveButtonText
            )
        }
    }
}

@Composable
fun RemarkItemWithActions(
    remark: RemarkEntity,
    onView: () -> Unit,
    onEdit: () -> Unit,
    onStatusChange: (String) -> Unit,
    onArchive: () -> Unit,
    onDelete: () -> Unit,
    showArchiveButton: Boolean,
    archiveButtonText: String
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 8.dp, vertical = 4.dp)
            .clickable(onClick = onView),
        elevation = 2.dp,
        backgroundColor = getRemarkCardColor(remark.priority, remark.status)
    ) {
        Column(modifier = Modifier.padding(12.dp)) {
            // Основная информация замечания (используем существующий RemarkItemCard)
            RemarkItemCardContent(remark = remark, onStatusChange = onStatusChange, onEdit = onEdit)

            // Кнопки действий
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 8.dp),
                horizontalArrangement = Arrangement.End
            ) {
                if (showArchiveButton) {
                    TextButton(
                        onClick = onArchive,
                        colors = ButtonDefaults.textButtonColors(
                            contentColor = MaterialTheme.colors.primary
                        )
                    ) {
                        Icon(Icons.Default.Archive, contentDescription = null, modifier = Modifier.size(16.dp))
                        Spacer(modifier = Modifier.width(4.dp))
                        Text(archiveButtonText, style = MaterialTheme.typography.caption)
                    }
                } else {
                    TextButton(
                        onClick = onArchive,
                        colors = ButtonDefaults.textButtonColors(
                            contentColor = MaterialTheme.colors.primary
                        )
                    ) {
                        Icon(Icons.Default.Unarchive, contentDescription = null, modifier = Modifier.size(16.dp))
                        Spacer(modifier = Modifier.width(4.dp))
                        Text(archiveButtonText, style = MaterialTheme.typography.caption)
                    }
                }

                Spacer(modifier = Modifier.width(8.dp))

                TextButton(
                    onClick = onDelete,
                    colors = ButtonDefaults.textButtonColors(
                        contentColor = MaterialTheme.colors.error
                    )
                ) {
                    Icon(Icons.Default.Delete, contentDescription = null, modifier = Modifier.size(16.dp))
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("Удалить", style = MaterialTheme.typography.caption)
                }
            }
        }
    }
}

@Composable
fun EmptyRemarksMessage(
    message: String,
    onAddRemark: () -> Unit,
    showAddButton: Boolean
) {
    Box(
        modifier = Modifier
            .fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            Text(
                text = message,
                style = MaterialTheme.typography.body1,
                color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f)
            )

            if (showAddButton) {
                Spacer(modifier = Modifier.height(16.dp))
                Button(
                    onClick = onAddRemark,
                    modifier = Modifier.padding(8.dp)
                ) {
                    Icon(Icons.Default.Add, contentDescription = null)
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("Создать первое замечание")
                }
            }
        }
    }
}

// Вспомогательная функция для отображения контента карточки
@Composable
fun RemarkItemCardContent(
    remark: RemarkEntity,
    onStatusChange: (String) -> Unit,
    onEdit: () -> Unit
) {
    Column {
        // Первая строка: заголовок + приоритет + дата
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = remark.title,
                style = MaterialTheme.typography.subtitle1,
                modifier = Modifier.weight(1f),
                maxLines = 1,
                overflow = TextOverflow.Ellipsis
            )

            PriorityBadge(remark.priority)

            Text(
                text = remark.deadline,
                style = MaterialTheme.typography.caption,
                color = getDeadlineColor(remark.deadline),
                modifier = Modifier.padding(start = 8.dp)
            )
        }

        // Вторая строка: описание (если есть)
        if (remark.description.isNotEmpty()) {
            Text(
                text = remark.description,
                style = MaterialTheme.typography.body2,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis,
                modifier = Modifier.padding(top = 4.dp)
            )
        }

        // Индикатор фото
        val photoPaths = remark.getPhotoList()
        if (photoPaths.isNotEmpty()) {
            Spacer(modifier = Modifier.height(4.dp))
            Text(
                text = "📷 ${photoPaths.size} фото",
                style = MaterialTheme.typography.caption,
                color = MaterialTheme.colors.primary,
                modifier = Modifier.padding(top = 4.dp)
            )
        }

        // Третья строка: категория + статус + действия
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(top = 8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Категория
            Text(
                text = when (remark.category) {
                    "Документация" -> "Документы"
                    "Оборудование" -> "Оборуд."
                    else -> remark.category
                },
                style = MaterialTheme.typography.caption,
                color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f)
            )

            Spacer(modifier = Modifier.weight(1f))

            // Селектор статуса
            StatusDropdown(
                currentStatus = remark.status,
                onStatusChange = onStatusChange
            )

            Spacer(modifier = Modifier.width(8.dp))

            // Кнопка редактирования
            IconButton(
                onClick = onEdit,
                modifier = Modifier.size(24.dp)
            ) {
                Icon(
                    Icons.Default.Edit,
                    contentDescription = "Редактировать",
                    modifier = Modifier.size(16.dp)
                )
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\RemarkUtils.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.material.MaterialTheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color
import com.example.kipia.database.RemarkEntity
import java.text.SimpleDateFormat
import java.util.*

// Функции для цветов статусов и приоритетов
fun getPriorityColor(priority: String): Color {
    return when (priority) {
        "Высокий" -> Color(0xFFFF5252)    // Красный
        "Средний" -> Color(0xFFFFB74D)    // Оранжевый
        else -> Color(0xFF4CAF50)         // Зеленый
    }
}

fun getStatusColor(status: String): Color {
    return when (status) {
        "Открыто" -> Color(0xFFFF5252)    // Красный
        "В работе" -> Color(0xFFFFB74D)   // Оранжевый
        "Выполнено" -> Color(0xFF4CAF50)  // Зеленый
        else -> Color.Gray
    }
}

@Composable
fun getRemarkCardColor(priority: String, status: String): Color {
    return when {
        status == "Выполнено" -> MaterialTheme.colors.surface
        status == "В работе" -> MaterialTheme.colors.secondary.copy(alpha = 0.1f)
        priority == "Высокий" -> MaterialTheme.colors.error.copy(alpha = 0.1f)
        priority == "Средний" -> MaterialTheme.colors.secondary.copy(alpha = 0.1f)
        else -> MaterialTheme.colors.surface
    }
}

fun getDeadlineColor(deadline: String): Color {
    return try {
        val sdf = SimpleDateFormat("dd.MM.yyyy", Locale.getDefault())
        val deadlineDate = sdf.parse(deadline)
        val currentDate = Date()

        deadlineDate?.let {
            val daysDiff = ((it.time - currentDate.time) / (1000 * 60 * 60 * 24)).toInt()
            when {
                daysDiff < 0 -> Color(0xFFFF5252)    // Просрочено - красный
                daysDiff <= 3 -> Color(0xFFFFB74D)   // Скоро срок - оранжевый
                else -> Color(0xFF4CAF50)            // В норме - зеленый
            }
        } ?: Color.Gray
    } catch (e: Exception) {
        Color.Gray
    }
}

// Функция для получения эмодзи приоритета
fun getPriorityEmoji(priority: String): String {
    return when (priority) {
        "Высокий" -> "‼️"
        "Средний" -> "⚠️"
        else -> "✅"
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\RemarkViewModel.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.kipia.database.AppDatabase
import com.example.kipia.database.RemarkEntity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.text.SimpleDateFormat
import java.util.*
import android.util.Log
import com.example.kipia.utils.PhotoStorageUtils

class RemarkViewModel(private val database: AppDatabase) : ViewModel() {

    private val _remarks = MutableStateFlow<List<RemarkEntity>>(emptyList())
    val remarks: StateFlow<List<RemarkEntity>> = _remarks

    private val _activeRemarks = MutableStateFlow<List<RemarkEntity>>(emptyList())
    val activeRemarks: StateFlow<List<RemarkEntity>> = _activeRemarks

    private val _archivedRemarks = MutableStateFlow<List<RemarkEntity>>(emptyList())
    val archivedRemarks: StateFlow<List<RemarkEntity>> = _archivedRemarks

    private var _currentControlPointId: Long = 0L

    fun loadRemarksByControlPointId(controlPointId: Long) {
        _currentControlPointId = controlPointId
        viewModelScope.launch {
            val result = withContext(Dispatchers.IO) {
                database.remarkDao().getRemarksByControlPointId(controlPointId)
            }
            _remarks.value = result
        }
    }

    // ДОБАВЛЕНО: Загрузка активных замечаний
    fun loadActiveRemarksByControlPointId(controlPointId: Long) {
        _currentControlPointId = controlPointId
        viewModelScope.launch {
            val result = withContext(Dispatchers.IO) {
                database.remarkDao().getActiveRemarksByControlPointId(controlPointId)
            }
            _activeRemarks.value = result
        }
    }

    // ДОБАВЛЕНО: Загрузка архивных замечаний
    fun loadArchivedRemarksByControlPointId(controlPointId: Long) {
        _currentControlPointId = controlPointId
        viewModelScope.launch {
            val result = withContext(Dispatchers.IO) {
                database.remarkDao().getArchivedRemarksByControlPointId(controlPointId)
            }
            _archivedRemarks.value = result
        }
    }

    // ДОБАВЛЕНО: Загрузка всех данных сразу
    fun loadAllRemarksByControlPointId(controlPointId: Long) {
        _currentControlPointId = controlPointId
        viewModelScope.launch {
            val activeResult = withContext(Dispatchers.IO) {
                database.remarkDao().getActiveRemarksByControlPointId(controlPointId)
            }
            val archivedResult = withContext(Dispatchers.IO) {
                database.remarkDao().getArchivedRemarksByControlPointId(controlPointId)
            }
            _activeRemarks.value = activeResult
            _archivedRemarks.value = archivedResult
            _remarks.value = activeResult + archivedResult
        }
    }

    fun addRemark(
        title: String,
        description: String = "",
        category: String = "Оборудование",
        priority: String = "Средний",
        deadline: String = getNextWeekDate()
    ) {
        viewModelScope.launch {
            val currentDate = getCurrentDate()
            val remark = RemarkEntity(
                controlPointId = _currentControlPointId,
                title = title,
                description = description,
                category = category,
                priority = priority,
                status = "Открыто",
                createdDate = currentDate,
                deadline = deadline
            )
            withContext(Dispatchers.IO) {
                database.remarkDao().insert(remark)
            }
            loadAllRemarksByControlPointId(_currentControlPointId)
        }
    }

    fun addRemarkWithPhotos(
        title: String,
        description: String = "",
        category: String = "Оборудование",
        priority: String = "Средний",
        deadline: String = getNextWeekDate(),
        photoPaths: List<String> = emptyList()
    ) {
        Log.d("RemarkViewModel", "Adding remark with ${photoPaths.size} photos")
        viewModelScope.launch {
            val currentDate = getCurrentDate()
            val remark = RemarkEntity(
                controlPointId = _currentControlPointId,
                title = title,
                description = description,
                category = category,
                priority = priority,
                status = "Открыто",
                createdDate = currentDate,
                deadline = deadline
            ).withPhotos(photoPaths)

            Log.d("RemarkViewModel", "Saving remark to database")
            withContext(Dispatchers.IO) {
                database.remarkDao().insert(remark)
            }
            Log.d("RemarkViewModel", "Remark saved, reloading list")
            loadAllRemarksByControlPointId(_currentControlPointId)
        }
    }

    fun updateRemarkStatus(remarkId: Long, newStatus: String) {
        viewModelScope.launch {
            val completedDate = if (newStatus == "Выполнено") getCurrentDate() else ""
            withContext(Dispatchers.IO) {
                database.remarkDao().updateStatus(remarkId, newStatus, completedDate)

                // Автоматически архивируем выполненные замечания
                if (newStatus == "Выполнено") {
                    database.remarkDao().archiveRemark(remarkId)
                }
            }
            loadAllRemarksByControlPointId(_currentControlPointId)
        }
    }

    // ДОБАВЛЕНО: Архивирование замечания
    fun archiveRemark(remarkId: Long) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.remarkDao().archiveRemark(remarkId)
            }
            loadAllRemarksByControlPointId(_currentControlPointId)
        }
    }

    // ДОБАВЛЕНО: Возврат из архива
    fun unarchiveRemark(remarkId: Long) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.remarkDao().unarchiveRemark(remarkId)
            }
            loadAllRemarksByControlPointId(_currentControlPointId)
        }
    }

    fun updateRemark(remark: RemarkEntity) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.remarkDao().update(remark)
            }
            loadAllRemarksByControlPointId(_currentControlPointId)
        }
    }

    fun deleteRemark(context: android.content.Context, remark: RemarkEntity) {
        viewModelScope.launch {
            // УДАЛЯЕМ ФОТО ИЗ ХРАНИЛИЩА
            withContext(Dispatchers.IO) {
                remark.getPhotoList().forEach { path ->
                    PhotoStorageUtils.deletePhotoFromStorage(context, path)
                }
                database.remarkDao().delete(remark)
            }
            loadAllRemarksByControlPointId(_currentControlPointId)
        }
    }

    private fun getCurrentDate(): String {
        val sdf = SimpleDateFormat("dd.MM.yyyy", Locale.getDefault())
        return sdf.format(Date())
    }

    private fun getNextWeekDate(): String {
        val calendar = Calendar.getInstance()
        calendar.add(Calendar.DAY_OF_YEAR, 7)
        val sdf = SimpleDateFormat("dd.MM.yyyy", Locale.getDefault())
        return sdf.format(calendar.time)
    }
}

// Функции для использования в UI
fun getNextWeekDate(): String {
    val calendar = Calendar.getInstance()
    calendar.add(Calendar.DAY_OF_YEAR, 7)
    val sdf = SimpleDateFormat("dd.MM.yyyy", Locale.getDefault())
    return sdf.format(calendar.time)
}

fun getCurrentDate(): String {
    val sdf = SimpleDateFormat("dd.MM.yyyy", Locale.getDefault())
    return sdf.format(Date())
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\RemarkViewModelFactory.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.example.kipia.database.AppDatabase

class RemarkViewModelFactory(private val database: AppDatabase) : ViewModelProvider.Factory {
    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(RemarkViewModel::class.java)) {
            return RemarkViewModel(database) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\SectionViewModel.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.kipia.database.AppDatabase
import com.example.kipia.database.SectionEntity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class SectionViewModel(private val database: AppDatabase) : ViewModel() {

    private val _sections = MutableStateFlow<List<SectionEntity>>(emptyList())
    val sections: StateFlow<List<SectionEntity>> = _sections

    fun loadSectionsByPKUId(pkuId: Long) {
        viewModelScope.launch {
            val result = withContext(Dispatchers.IO) {
                database.sectionDao().getSectionsByPKUId(pkuId)
            }
            _sections.value = result
        }
    }

    fun addSection(name: String, pkuId: Long) {
        viewModelScope.launch {
            val section = SectionEntity(name = name, pkuId = pkuId)
            withContext(Dispatchers.IO) {
                database.sectionDao().insert(section)
            }
            loadSectionsByPKUId(pkuId)
        }
    }

    fun deleteSection(section: SectionEntity) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.sectionDao().delete(section)
            }
            loadSectionsByPKUId(section.pkuId)
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\SectionViewModelFactory.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.example.kipia.database.AppDatabase

class SectionViewModelFactory(private val database: AppDatabase) : ViewModelProvider.Factory {
    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(SectionViewModel::class.java)) {
            return SectionViewModel(database) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\SettingsScreen.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/SettingsScreen.kt
package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun SettingsScreen(
    initialMuteSplash: Boolean,
    onMuteSplashChange: (Boolean) -> Unit,
    onBackClick: () -> Unit
) {
    var muteSplash by remember { mutableStateOf(initialMuteSplash) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Настройки") },
                navigationIcon = {
                    IconButton(onClick = onBackClick) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Назад")
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .padding(innerPadding)
                .fillMaxSize()
                .padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Отключить звук заставки",
                    style = MaterialTheme.typography.body1
                )
                Switch(
                    checked = muteSplash,
                    onCheckedChange = { newValue ->
                        muteSplash = newValue
                        onMuteSplashChange(newValue)
                    }
                )
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\SimpleDraggableNodeItem.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/SimpleDraggableNodeItem.kt
package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyItemScope
import androidx.compose.material.Card
import androidx.compose.material.Icon
import androidx.compose.material.IconButton
import androidx.compose.material.Text
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.filled.Menu
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun LazyItemScope.SimpleDraggableNodeItem(
    node: com.example.kipia.database.NodeEntity,
    onEdit: (com.example.kipia.database.NodeEntity) -> Unit,
    onDelete: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(start = 12.dp, top = 2.dp, bottom = 2.dp),
        elevation = 1.dp
    ) {
        Row(
            modifier = Modifier.padding(6.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Иконка для визуального обозначения возможности перетаскивания
            Icon(
                imageVector = Icons.Default.Menu,
                contentDescription = "Перетащить",
                modifier = Modifier
                    .size(20.dp)
                    .padding(end = 8.dp),
                tint = androidx.compose.ui.graphics.Color.Gray
            )

            Text(
                text = node.name,
                style = androidx.compose.material.MaterialTheme.typography.body2,
                modifier = Modifier.weight(1f)
            )

            // Кнопка редактирования объекта
            IconButton(
                onClick = { onEdit(node) },
                modifier = Modifier.size(20.dp)
            ) {
                Icon(
                    Icons.Default.Edit,
                    contentDescription = "Редактировать объект",
                    modifier = Modifier.size(14.dp)
                )
            }

            // Кнопка удаления объекта
            IconButton(
                onClick = onDelete,
                modifier = Modifier.size(20.dp)
            ) {
                Icon(
                    Icons.Default.Delete,
                    contentDescription = "Удалить объект",
                    modifier = Modifier.size(14.dp)
                )
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\SyncScreen.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Sync
import androidx.compose.material.icons.filled.SyncDisabled
import androidx.compose.material.icons.filled.Wifi
import androidx.compose.material.icons.filled.Error
import androidx.compose.material.icons.filled.Security
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import java.text.SimpleDateFormat
import java.util.*
import com.example.kipia.ui.SyncState // ДОБАВЬТЕ ЭТУ СТРОКУ

@Composable
fun SyncScreen(
    onBackClick: () -> Unit
) {
    val context = LocalContext.current
    val syncViewModel: SyncViewModel = viewModel(
        factory = SyncViewModelFactory(context)
    )
    val syncState by syncViewModel.syncState.collectAsState()

    var showPermissionScreen by remember { mutableStateOf(false) }

    // Показываем экран разрешений при первом входе или если нужны разрешения
    LaunchedEffect(Unit) {
        if (!syncViewModel.hasRequiredPermissions()) {
            showPermissionScreen = true
        }
    }

    if (showPermissionScreen) {
        PermissionScreen(
            onPermissionsGranted = {
                showPermissionScreen = false
                // Автоматически запускаем синхронизацию после предоставления разрешений
                syncViewModel.startSync()
            },
            onSkip = {
                showPermissionScreen = false
                // Пользователь может использовать ручную синхронизацию
            }
        )
    } else {
        // Стандартный экран синхронизации
        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text("Синхронизация данных") },
                    navigationIcon = {
                        IconButton(onClick = onBackClick) {
                            Icon(
                                imageVector = Icons.Default.ArrowBack,
                                contentDescription = "Назад"
                            )
                        }
                    },
                    actions = {
                        // Кнопка для повторного запроса разрешений
                        IconButton(onClick = { showPermissionScreen = true }) {
                            Icon(Icons.Default.Security, contentDescription = "Разрешения")
                        }
                    }
                )
            }
        ) { padding ->
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                item {
                    SyncStatusCard(syncState, syncViewModel)
                }

                item {
                    SyncControlsCard(syncState, syncViewModel)
                }

                item {
                    SyncSettingsCard(syncViewModel, syncState)
                }

                item {
                    LastSyncInfo(syncState)
                }

                if (syncState.connectedDevices.isNotEmpty()) {
                    item {
                        ConnectedDevicesCard(syncState)
                    }
                }
            }
        }
    }
}
@Composable
fun SyncStatusCard(
    state: SyncState,
    viewModel: SyncViewModel
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        elevation = 4.dp,
        shape = RoundedCornerShape(8.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Icon(
                    imageVector = if (state.isSyncing) Icons.Default.Sync else Icons.Default.SyncDisabled,
                    contentDescription = null,
                    tint = if (state.isSyncing) MaterialTheme.colors.primary else MaterialTheme.colors.onSurface.copy(alpha = 0.6f)
                )
                Text(
                    text = if (state.isSyncing) "Синхронизация..." else "Синхронизация отключена",
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Medium
                )
            }

            if (state.isSyncing) {
                Spacer(modifier = Modifier.height(8.dp))
                LinearProgressIndicator(
                    modifier = Modifier.fillMaxWidth(),
                    progress = state.syncProgress / 100f
                )
                Spacer(modifier = Modifier.height(4.dp))
                Text(
                    text = state.syncStatus,
                    fontSize = 14.sp,
                    color = MaterialTheme.colors.onSurface.copy(alpha = 0.8f)
                )
            }

            state.errorMessage?.let { error ->
                Spacer(modifier = Modifier.height(8.dp))
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Error,
                        contentDescription = null,
                        tint = MaterialTheme.colors.error
                    )
                    Text(
                        text = error,
                        fontSize = 14.sp,
                        color = MaterialTheme.colors.error
                    )
                }

                Spacer(modifier = Modifier.height(8.dp))
                Button(
                    onClick = { viewModel.clearError() },
                    colors = ButtonDefaults.buttonColors(backgroundColor = MaterialTheme.colors.error)
                ) {
                    Text("ОК")
                }
            }
        }
    }
}

@Composable
private fun SyncControlsCard(
    state: SyncState,
    viewModel: SyncViewModel
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp),
        elevation = 4.dp,
        shape = RoundedCornerShape(8.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Управление синхронизацией",
                fontSize = 16.sp,
                fontWeight = FontWeight.Medium
            )

            Spacer(modifier = Modifier.height(16.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Button(
                    onClick = { viewModel.startSync() },
                    enabled = !state.isSyncing,
                    modifier = Modifier.weight(1f)
                ) {
                    Icon(Icons.Default.Sync, contentDescription = null)
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("Начать синхронизацию")
                }

                Button(
                    onClick = { viewModel.stopSync() },
                    enabled = state.isSyncing,
                    colors = ButtonDefaults.buttonColors(backgroundColor = MaterialTheme.colors.error),
                    modifier = Modifier.weight(1f)
                ) {
                    Icon(Icons.Default.SyncDisabled, contentDescription = null)
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("Остановить")
                }
            }

            Spacer(modifier = Modifier.height(8.dp)) // Исправлено: было Mod вместо Modifier

            Button(
                onClick = { viewModel.prepareManualSync() },
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(backgroundColor = MaterialTheme.colors.secondary)
            ) {
                Text("Подготовить данные для экспорта")
            }
        }
    }
}

@Composable
private fun SyncSettingsCard(
    viewModel: SyncViewModel,
    state: SyncState // Добавляем параметр state
) {
    var syncEnabled by remember { mutableStateOf(true) }
    var autoSync by remember { mutableStateOf(false) }

    // Используем состояние из ViewModel
    LaunchedEffect(state) {
        // Здесь можно обновлять локальное состояние на основе state
    }

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp),
        elevation = 4.dp,
        shape = RoundedCornerShape(8.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Настройки синхронизации",
                fontSize = 16.sp,
                fontWeight = FontWeight.Medium
            )

            Spacer(modifier = Modifier.height(16.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Синхронизация по Wi-Fi Direct")
                Switch(
                    checked = syncEnabled,
                    onCheckedChange = { enabled -> // Явно указываем тип параметра
                        syncEnabled = enabled
                        viewModel.setSyncEnabled(enabled)
                    }
                )
            }

            Spacer(modifier = Modifier.height(8.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Автоматическая синхронизация")
                Switch(
                    checked = autoSync,
                    onCheckedChange = { enabled -> // Явно указываем тип параметра
                        autoSync = enabled
                        viewModel.setAutoSync(enabled)
                    }
                )
            }
        }
    }
}

// В SyncScreen.kt обновите LastSyncInfo:
@Composable
private fun LastSyncInfo(state: SyncState) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp),
        elevation = 4.dp,
        shape = RoundedCornerShape(8.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Информация о синхронизации",
                fontSize = 16.sp,
                fontWeight = FontWeight.Medium
            )

            Spacer(modifier = Modifier.height(8.dp))

            if (state.lastSyncTime > 0) {
                val dateFormat = SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.getDefault())
                val dateString = dateFormat.format(Date(state.lastSyncTime))

                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Icon(Icons.Default.Wifi, contentDescription = null)
                    Text("Последняя синхронизация: $dateString")
                }

                if (state.syncCompleted) {
                    Spacer(modifier = Modifier.height(4.dp))
                    Text(
                        text = "✅ Синхронизация завершена",
                        color = MaterialTheme.colors.primary,
                        fontWeight = FontWeight.Medium
                    )
                    if (state.newItemsCount > 0) {
                        Text(
                            text = "Добавлено новых элементов: ${state.newItemsCount}",
                            color = MaterialTheme.colors.primary.copy(alpha = 0.8f)
                        )
                    }
                }
            } else {
                Text("Синхронизация еще не выполнялась")
            }

            Spacer(modifier = Modifier.height(8.dp))

            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Icon(Icons.Default.Sync, contentDescription = null)
                Text("Статус: ${getSyncStatus(state)}")
            }

            // Показываем подключенные устройства
            if (state.connectedDevices.isNotEmpty()) {
                Spacer(modifier = Modifier.height(8.dp))
                Text("Подключенные устройства: ${state.connectedDevices.size}")
            }
        }
    }
}

@Composable
private fun getSyncStatus(state: SyncState): String {
    return when {
        state.isSyncing -> "Синхронизация..."
        state.connectedDevices.isNotEmpty() -> "Устройства подключены"
        state.isAdvertising && state.isDiscovering -> "Поиск устройств..."
        state.isAdvertising -> "Ожидание подключения..."
        else -> "Ожидание"
    }
}
@Composable
private fun ConnectedDevicesCard(state: SyncState) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        elevation = 4.dp,
        shape = RoundedCornerShape(8.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Подключенные устройства",
                fontSize = 16.sp,
                fontWeight = FontWeight.Medium
            )

            Spacer(modifier = Modifier.height(8.dp))

            state.connectedDevices.forEach { device ->
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Icon(Icons.Default.Wifi, contentDescription = null)
                    Text(device)
                }
                Spacer(modifier = Modifier.height(4.dp))
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\SyncState.kt ---
------------------------------------------------------------

package com.example.kipia.ui

// В SyncState.kt добавьте поля:
data class SyncState(
    val isSyncing: Boolean = false,
    val lastSyncTime: Long = 0,
    val syncProgress: Int = 0,
    val syncStatus: String = "",
    val isAdvertising: Boolean = false,
    val isDiscovering: Boolean = false,
    val connectedDevices: List<String> = emptyList(),
    val errorMessage: String? = null,
    val syncCompleted: Boolean = false, // Добавьте это
    val newItemsCount: Int = 0 // Добавьте это
)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\SyncViewModel.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/SyncViewModel.kt
package com.example.kipia.ui

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.Build
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.kipia.data.PreferencesManager
import com.example.kipia.sync.NearbySyncService
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import android.Manifest
import android.content.pm.PackageManager
import androidx.core.content.ContextCompat

class SyncViewModel(private val context: Context) : ViewModel() {
    private val preferencesManager = PreferencesManager(context)

    private val _syncState = MutableStateFlow(SyncState())
    val syncState: StateFlow<SyncState> = _syncState.asStateFlow()

    private val syncUpdateReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            when (intent?.action) {
                NearbySyncService.ACTION_SYNC_UPDATE -> {
                    val isAdvertising = intent.getBooleanExtra("is_advertising", false)
                    val isDiscovering = intent.getBooleanExtra("is_discovering", false)
                    val connectedDevices = intent.getStringArrayExtra("connected_devices")?.toList() ?: emptyList()
                    val error = intent.getStringExtra("error")
                    val syncCompleted = intent.getBooleanExtra("sync_completed", false)
                    val newItemsCount = intent.getIntExtra("new_items", 0)

                    _syncState.value = _syncState.value.copy(
                        isAdvertising = isAdvertising,
                        isDiscovering = isDiscovering,
                        connectedDevices = connectedDevices,
                        errorMessage = error,
                        syncCompleted = syncCompleted,
                        newItemsCount = newItemsCount,
                        lastSyncTime = if (syncCompleted) System.currentTimeMillis() else _syncState.value.lastSyncTime
                    )

                    if (syncCompleted) {
                        android.util.Log.d("SyncViewModel", "🎉 Синхронизация завершена! Новых элементов: $newItemsCount")
                    }
                }
            }
        }
    }

    init {
        // Регистрируем BroadcastReceiver с правильными флагами для Android 14+
        val filter = IntentFilter(NearbySyncService.ACTION_SYNC_UPDATE)

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            // Для Android 13+ нужно указать флаг экспорта
            context.registerReceiver(
                syncUpdateReceiver,
                filter,
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    Context.RECEIVER_NOT_EXPORTED
                } else {
                    Context.RECEIVER_EXPORTED  // Для версий ниже
                }
            )
        } else {
            // Для старых версий Android
            context.registerReceiver(syncUpdateReceiver, filter)
        }

        viewModelScope.launch {
            preferencesManager.lastSyncTimestamp.collect { timestamp ->
                _syncState.value = _syncState.value.copy(lastSyncTime = timestamp)
            }
        }

        viewModelScope.launch {
            preferencesManager.syncEnabled.collect { enabled ->
                if (enabled) {
                    startSyncService()
                } else {
                    stopSyncService()
                }
            }
        }
    }

    fun hasRequiredPermissions(): Boolean {
        val requiredPermissions = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            arrayOf(
                Manifest.permission.ACCESS_FINE_LOCATION,
                Manifest.permission.BLUETOOTH_ADVERTISE,
                Manifest.permission.BLUETOOTH_CONNECT,
                Manifest.permission.BLUETOOTH_SCAN,
                Manifest.permission.ACCESS_WIFI_STATE,
                Manifest.permission.CHANGE_WIFI_STATE,
                Manifest.permission.NEARBY_WIFI_DEVICES
            )
        } else {
            arrayOf(
                Manifest.permission.ACCESS_FINE_LOCATION,
                Manifest.permission.BLUETOOTH,
                Manifest.permission.BLUETOOTH_ADMIN,
                Manifest.permission.ACCESS_WIFI_STATE,
                Manifest.permission.CHANGE_WIFI_STATE
            )
        }

        return requiredPermissions.all { permission ->
            ContextCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED
        }
    }

    fun startSync() {
        if (!hasRequiredPermissions()) {
            _syncState.value = _syncState.value.copy(
                errorMessage = "Для синхронизации требуются разрешения на доступ к местоположению и Bluetooth"
            )
            return
        }

        _syncState.value = _syncState.value.copy(
            isSyncing = true,
            syncProgress = 0,
            syncStatus = "Начало синхронизации..."
        )

        viewModelScope.launch {
            try {
                val intent = android.content.Intent(context, NearbySyncService::class.java)
                context.startService(intent)

                _syncState.value = _syncState.value.copy(
                    syncProgress = 50,
                    syncStatus = "Поиск устройств..."
                )

            } catch (e: Exception) {
                _syncState.value = _syncState.value.copy(
                    isSyncing = false,
                    errorMessage = "Ошибка синхронизации: ${e.message}"
                )
            }
        }
    }

    fun stopSync() {
        _syncState.value = _syncState.value.copy(
            isSyncing = false,
            syncStatus = "Синхронизация остановлена"
        )

        stopSyncService()
    }

    fun setSyncEnabled(enabled: Boolean) {
        viewModelScope.launch {
            preferencesManager.setSyncEnabled(enabled)
        }
    }

    fun setAutoSync(enabled: Boolean) {
        viewModelScope.launch {
            preferencesManager.setAutoSync(enabled)
        }
    }

    fun clearError() {
        _syncState.value = _syncState.value.copy(errorMessage = null)
    }

    fun prepareManualSync() {
        viewModelScope.launch {
            try {
                _syncState.value = _syncState.value.copy(
                    syncStatus = "Данные подготовлены для экспорта"
                )
            } catch (e: Exception) {
                _syncState.value = _syncState.value.copy(
                    errorMessage = "Ошибка подготовки данных: ${e.message}"
                )
            }
        }
    }

    private fun startSyncService() {
        val intent = android.content.Intent(context, NearbySyncService::class.java)
        context.startService(intent)

        _syncState.value = _syncState.value.copy(
            isAdvertising = true,
            isDiscovering = true
        )
    }

    private fun stopSyncService() {
        val intent = android.content.Intent(context, NearbySyncService::class.java)
        context.stopService(intent)

        _syncState.value = _syncState.value.copy(
            isAdvertising = false,
            isDiscovering = false
        )
    }

    override fun onCleared() {
        super.onCleared()
        try {
            context.unregisterReceiver(syncUpdateReceiver)
        } catch (e: Exception) {
            // Игнорируем ошибки при отмене регистрации
            android.util.Log.e("SyncViewModel", "Ошибка при отмене регистрации receiver", e)
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\SyncViewModelFactory.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/SyncViewModelFactory.kt
package com.example.kipia.ui

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider

class SyncViewModelFactory(private val context: Context) : ViewModelProvider.Factory {
    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(SyncViewModel::class.java)) {
            return SyncViewModel(context) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\theme\Color.kt ---
------------------------------------------------------------

package com.example.kipia.ui.theme

import androidx.compose.ui.graphics.Color

val Purple200 = Color(0xFFBB86FC)
val Purple500 = Color(0xFF6200EE)
val Purple700 = Color(0xFF3700B3)
val Teal200 = Color(0xFF03DAC5)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\theme\Shapes.kt ---
------------------------------------------------------------

package com.example.kipia.ui.theme

import androidx.compose.material.Shapes
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.ui.unit.dp

val Shapes = Shapes(
    small = RoundedCornerShape(4.dp),
    medium = RoundedCornerShape(4.dp),
    large = RoundedCornerShape(0.dp)
)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\theme\Theme.kt ---
------------------------------------------------------------

package com.example.kipia.ui.theme

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material.MaterialTheme
import androidx.compose.material.darkColors
import androidx.compose.material.lightColors
import androidx.compose.runtime.Composable

private val DarkColorPalette = darkColors(
    primary = Purple200,
    primaryVariant = Purple700,
    secondary = Teal200
)

private val LightColorPalette = lightColors(
    primary = Purple500,
    primaryVariant = Purple700,
    secondary = Teal200
)

@Composable
fun KIPITheme(darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable () -> Unit) {
    val colors = if (darkTheme) {
        DarkColorPalette
    } else {
        LightColorPalette
    }

    MaterialTheme(
        colors = colors,
        typography = Typography,
        shapes = Shapes,
        content = content
    )
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\theme\Typography.kt ---
------------------------------------------------------------

package com.example.kipia.ui.theme

import androidx.compose.material.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    body1 = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp
    )
    /* Other default text styles to override
    button = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.W500,
        fontSize = 14.sp
    ),
    caption = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 12.sp
    )
    */
)
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\TubeItem.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch

@Composable
fun TubeItem(
    tube: com.example.kipia.database.TubeEntity,
    nodeViewModel: NodeViewModel,
    onEdit: (com.example.kipia.database.TubeEntity) -> Unit,
    onDelete: () -> Unit,
    onAddNode: (String, com.example.kipia.model.NodeType) -> Unit,
    onDeleteNode: (Long) -> Unit,
    onEditNode: (com.example.kipia.database.NodeEntity) -> Unit,
    onViewEquipment: (com.example.kipia.database.NodeEntity) -> Unit = {}
) {
    val nodesForThisTube by nodeViewModel.getNodesFlowForTube(tube.id).collectAsState(initial = emptyList())
    var showAddNodeDialog by remember { mutableStateOf(false) }
    val coroutineScope = rememberCoroutineScope()

    LaunchedEffect(tube.id) {
        nodeViewModel.loadNodesByTubeId(tube.id)
    }

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp),
        elevation = 8.dp,
        backgroundColor = MaterialTheme.colors.surface
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(
                    text = tube.name,
                    style = MaterialTheme.typography.h6,
                    modifier = Modifier.weight(1f),
                    color = MaterialTheme.colors.onSurface
                )

                IconButton(onClick = { onEdit(tube) }) {
                    Icon(
                        Icons.Default.Edit,
                        contentDescription = "Редактировать",
                        tint = MaterialTheme.colors.onSurface
                    )
                }

                IconButton(onClick = { showAddNodeDialog = true }) {
                    Icon(
                        Icons.Default.Add,
                        contentDescription = "Добавить объект",
                        tint = MaterialTheme.colors.onSurface
                    )
                }

                IconButton(onClick = onDelete) {
                    Icon(
                        Icons.Default.Delete,
                        contentDescription = "Удалить",
                        tint = MaterialTheme.colors.onSurface
                    )
                }
            }

            Spacer(modifier = Modifier.height(12.dp))

            // Список объектов (ОД, В, Задвижки) - теперь без дублирования
            if (nodesForThisTube.isNotEmpty()) {
                val sortedNodes = nodesForThisTube.sortedBy { it.orderIndex }

                LazyColumn(
                    modifier = Modifier
                        .fillMaxWidth()
                        .heightIn(max = 500.dp)
                ) {
                    items(sortedNodes) { node ->
                        // Используем NodeItemWithEquipment для всех объектов
                        NodeItemWithEquipment(
                            node = node,
                            onEdit = { onEditNode(node) },
                            onDelete = { onDeleteNode(node.id) },
                            onViewEquipment = { onViewEquipment(node) }
                        )
                    }
                }
            } else {
                Text(
                    text = "📝 Нет объектов. Нажмите '+' чтобы добавить",
                    style = MaterialTheme.typography.body2,
                    color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f),
                    modifier = Modifier.padding(vertical = 24.dp)
                )
            }
        }
    }

    if (showAddNodeDialog) {
        AddNodeDialog(
            tubeName = tube.name,
            onDismiss = { showAddNodeDialog = false },
            onConfirm = { name, type ->
                onAddNode(name, type)
                showAddNodeDialog = false
            }
        )
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\TubeViewModel.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.kipia.database.AppDatabase
import com.example.kipia.database.TubeEntity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class TubeViewModel(private val database: AppDatabase) : ViewModel() {

    private val _tubes: MutableStateFlow<List<TubeEntity>> = MutableStateFlow(emptyList())
    val tubes: StateFlow<List<TubeEntity>> = _tubes

    // Метод loadTubesByControlPointId - загрузка Труб по ID КП
    fun loadTubesByControlPointId(controlPointId: Long) {
        viewModelScope.launch {
            val result = withContext(Dispatchers.IO) {
                database.tubeDao().getTubesByControlPointId(controlPointId)
            }
            _tubes.value = result
        }
    }

    // Метод addTube - добавление Трубы, теперь требует controlPointId
    fun addTube(name: String, controlPointId: Long) {
        viewModelScope.launch {
            val tube = TubeEntity(name = name, controlPointId = controlPointId)
            withContext(Dispatchers.IO) {
                database.tubeDao().insert(tube)
            }
            loadTubesByControlPointId(controlPointId) // обновляем список
        }
    }

    fun deleteTube(id: Long, controlPointId: Long) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.tubeDao().deleteById(id)
            }
            loadTubesByControlPointId(controlPointId) // обновляем список
        }
    }

    fun updateTube(id: Long, newName: String) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                database.tubeDao().update(id, newName)
            }
            // Обновляем список труб для текущего КП
            val current = withContext(Dispatchers.IO) {
                database.tubeDao().getTubeById(id)
            }
            current?.let { tube ->
                loadTubesByControlPointId(tube.controlPointId)
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\TubeViewModelFactory.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/TubeViewModelFactory.kt
package com.example.kipia.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.example.kipia.database.AppDatabase

class TubeViewModelFactory(private val database: AppDatabase) : ViewModelProvider.Factory {
    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(TubeViewModel::class.java)) {
            return TubeViewModel(database) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\ViewEquipmentScreen.kt ---
------------------------------------------------------------

// app/src/main/java/com/example/kipia/ui/ViewEquipmentScreen.kt
package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Edit
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.example.kipia.database.AppDatabase
import com.example.kipia.database.DetailedEquipmentEntity
import com.example.kipia.model.EquipmentType

@Composable
fun ViewEquipmentScreen(
    equipmentId: Long,
    onBackClick: () -> Unit,
    onEditClick: () -> Unit
) {
    val context = LocalContext.current
    val equipmentViewModel: EquipmentViewModel = viewModel(
        factory = EquipmentViewModelFactory(AppDatabase.getInstance(context))
    )

    var currentEquipment by remember { mutableStateOf<DetailedEquipmentEntity?>(null) }

    // Загружаем оборудование при открытии
    LaunchedEffect(equipmentId) {
        val equipment = equipmentViewModel.getEquipmentById(equipmentId)
        currentEquipment = equipment
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Просмотр оборудования") },
                navigationIcon = {
                    IconButton(onClick = onBackClick) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Назад")
                    }
                },
                actions = {
                    IconButton(
                        onClick = onEditClick,
                        enabled = currentEquipment != null
                    ) {
                        Icon(Icons.Default.Edit, contentDescription = "Редактировать")
                    }
                }
            )
        }
    ) { innerPadding ->
        currentEquipment?.let { equipment ->
            EquipmentView(
                equipment = equipment,
                modifier = Modifier
                    .padding(innerPadding)
                    .fillMaxSize()
                    .verticalScroll(rememberScrollState())
                    .padding(16.dp)
            )
        } ?: run {
            Box(
                modifier = Modifier
                    .padding(innerPadding)
                    .fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        }
    }
}

@Composable
fun EquipmentView(
    equipment: DetailedEquipmentEntity,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier) {
        // Основная информация
        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = 4.dp
        ) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(
                    text = "Основная информация",
                    style = MaterialTheme.typography.h6,
                    modifier = Modifier.padding(bottom = 8.dp)
                )

                EquipmentInfoRow("Название", equipment.name)
                EquipmentInfoRow("Тип оборудования", EquipmentType.valueOf(equipment.equipmentType).displayName)
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        // Общие характеристики
        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = 4.dp
        ) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(
                    text = "Общие характеристики",
                    style = MaterialTheme.typography.h6,
                    modifier = Modifier.padding(bottom = 8.dp)
                )

                EquipmentInfoRow("Модель", equipment.model)
                EquipmentInfoRow("Производитель", equipment.manufacturer)
                EquipmentInfoRow("Заводской номер", equipment.serialNumber)
                EquipmentInfoRow("Год выпуска", equipment.productionYear)
                EquipmentInfoRow("Год поверки", equipment.verificationYear)
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

// В функции EquipmentView в ViewEquipmentScreen.kt обновляем блок специфических характеристик:

// Специфические характеристики
        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = 4.dp
        ) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(
                    text = "Специфические характеристики",
                    style = MaterialTheme.typography.h6,
                    modifier = Modifier.padding(bottom = 8.dp)
                )

                EquipmentInfoRow("Номинал", equipment.nominal)
                EquipmentInfoRow("Граница давления", equipment.pressureLimit)
                EquipmentInfoRow("Версия ПО", equipment.softwareVersion)

                // Дополнительные характеристики для БУР, БКЭП и других релейных защит
                if (equipment.equipmentType in listOf("BUR", "BKEP", "DPS", "BKP", "UZR")) {
                    EquipmentInfoRow("МО", equipment.mo)
                    EquipmentInfoRow("МЗ", equipment.mz)
                    EquipmentInfoRow("МТО", equipment.mto)
                    EquipmentInfoRow("МТЗ", equipment.mtz)
                    EquipmentInfoRow("МУО", equipment.muo)
                    EquipmentInfoRow("МУЗ", equipment.muz)
                    EquipmentInfoRow("Кол.об.вых.зв", equipment.outputContacts)
                }
            }
        }
    }
}

@Composable
fun EquipmentInfoRow(label: String, value: String) {
    if (value.isNotEmpty()) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 4.dp),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Text(
                text = "$label:",
                style = MaterialTheme.typography.body2,
                color = MaterialTheme.colors.onSurface.copy(alpha = 0.7f)
            )
            Text(
                text = value,
                style = MaterialTheme.typography.body2
            )
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\ViewRemarkDialog.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Edit
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import coil.compose.AsyncImage
import com.example.kipia.database.RemarkEntity
import android.net.Uri
import androidx.compose.foundation.clickable
import androidx.compose.ui.platform.LocalContext
import com.example.kipia.utils.PhotoStorageUtils

@Composable
fun ViewRemarkDialog(
    remark: RemarkEntity,
    onDismiss: () -> Unit,
    onEdit: () -> Unit
) {
    var selectedPhotoUri by remember { mutableStateOf<Uri?>(null) }
    val context = LocalContext.current
    val photoPaths = remark.getPhotoList()

    // Полноэкранный просмотр фото
    if (selectedPhotoUri != null) {
        FullScreenPhotoView(
            photoUri = selectedPhotoUri!!,
            onDismiss = { selectedPhotoUri = null }
        )
        return
    }

    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .heightIn(max = 600.dp),
            elevation = 8.dp
        ) {
            Column(
                modifier = Modifier
                    .padding(16.dp)
                    .verticalScroll(rememberScrollState())
            ) {
                // Заголовок и кнопки
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = "Просмотр замечания",
                        style = MaterialTheme.typography.h6
                    )

                    Row {
                        IconButton(
                            onClick = {
                                onEdit()
                                onDismiss()
                            }
                        ) {
                            Icon(Icons.Default.Edit, contentDescription = "Редактировать")
                        }
                        IconButton(onClick = onDismiss) {
                            Icon(Icons.Default.Close, contentDescription = "Закрыть")
                        }
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Основная информация
                Card(elevation = 2.dp) {
                    Column(modifier = Modifier.padding(16.dp)) {
                        Text(
                            text = remark.title,
                            style = MaterialTheme.typography.h6
                        )

                        Spacer(modifier = Modifier.height(8.dp))

                        if (remark.description.isNotEmpty()) {
                            Text(
                                text = remark.description,
                                style = MaterialTheme.typography.body1
                            )
                            Spacer(modifier = Modifier.height(8.dp))
                        }

                        SimpleDetailRow("Категория", remark.category)
                        SimpleDetailRow("Приоритет", remark.priority)
                        SimpleDetailRow("Статус", remark.status)
                        SimpleDetailRow("Дата создания", remark.createdDate)
                        SimpleDetailRow("Срок устранения", remark.deadline)
                    }
                }

                // Фото с возможностью полноэкранного просмотра
                if (photoPaths.isNotEmpty()) {
                    Spacer(modifier = Modifier.height(16.dp))

                    Card(elevation = 2.dp) {
                        Column(modifier = Modifier.padding(16.dp)) {
                            Text(
                                text = "Прикрепленные фото (${photoPaths.size})",
                                style = MaterialTheme.typography.subtitle1
                            )

                            Spacer(modifier = Modifier.height(8.dp))

                            // ФОТО С ВОЗМОЖНОСТЬЮ КЛИКА - ИСПОЛЬЗУЕМ ПОСТОЯННЫЕ ПУТИ
                            Column {
                                photoPaths.forEachIndexed { index, path ->
                                    // СОЗДАЕМ URI ИЗ ПОСТОЯННОГО ПУТИ
                                    val uri = PhotoStorageUtils.getUriForAppFile(context, path)
                                    Card(
                                        modifier = Modifier
                                            .fillMaxWidth()
                                            .padding(vertical = 4.dp)
                                            .clickable {
                                                selectedPhotoUri = uri // ОТКРЫВАЕМ ПОЛНОЭКРАННЫЙ ПРОСМОТР
                                            },
                                        elevation = 1.dp
                                    ) {
                                        Column {
                                            AsyncImage(
                                                model = uri,
                                                contentDescription = "Фото замечания",
                                                modifier = Modifier
                                                    .fillMaxWidth()
                                                    .height(200.dp),
                                                contentScale = ContentScale.Crop
                                            )
                                            Text(
                                                text = "Нажмите для просмотра в полный размер",
                                                style = MaterialTheme.typography.caption,
                                                modifier = Modifier
                                                    .fillMaxWidth()
                                                    .padding(8.dp)
                                            )
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Кнопка закрытия
                Button(
                    onClick = onDismiss,
                    modifier = Modifier.align(Alignment.End)
                ) {
                    Text("Закрыть")
                }
            }
        }
    }
}


@Composable
fun SimpleDetailRow(label: String, value: String) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp)
    ) {
        Text(
            text = "$label:",
            style = MaterialTheme.typography.subtitle2,
            modifier = Modifier.weight(1f)
        )
        Text(
            text = value,
            style = MaterialTheme.typography.body1,
            modifier = Modifier.weight(1f)
        )
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\ViewRemarkScreen.kt ---
------------------------------------------------------------

package com.example.kipia.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Edit
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImage
import android.net.Uri
import androidx.compose.ui.platform.LocalContext
import com.example.kipia.utils.PhotoStorageUtils

@Composable
fun ViewRemarkScreen(
    remarkId: Long,
    onBackClick: () -> Unit,
    onEditClick: () -> Unit
) {
    val context = LocalContext.current

    // TODO: Загрузить замечание по ID из ViewModel
    // Пока используем заглушку
    val remark = remember {
        // В реальном приложении загружаем из базы
        com.example.kipia.database.RemarkEntity(
            id = remarkId,
            controlPointId = 1,
            title = "Пример замечания для просмотра",
            description = "Это подробное описание замечания с деталями проблемы и рекомендациями по устранению.",
            category = "Оборудование",
            priority = "Высокий",
            status = "В работе",
            createdDate = "20.11.2023",
            deadline = "27.11.2023",
            completedDate = "",
            photos = "" // В реальном приложении здесь будут постоянные пути
        )
    }

    val photoPaths = remark.getPhotoList()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Просмотр замечания") },
                navigationIcon = {
                    IconButton(onClick = onBackClick) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Назад")
                    }
                },
                actions = {
                    IconButton(onClick = onEditClick) {
                        Icon(Icons.Default.Edit, contentDescription = "Редактировать")
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .padding(innerPadding)
                .fillMaxSize()
                .verticalScroll(rememberScrollState())
        ) {
            // Основная информация
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                elevation = 4.dp
            ) {
                Column(modifier = Modifier.padding(16.dp)) {
                    // Заголовок и приоритет
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = remark.title,
                            style = MaterialTheme.typography.h6
                        )
                        PriorityBadge(remark.priority)
                    }

                    Spacer(modifier = Modifier.height(12.dp))

                    // Описание
                    if (remark.description.isNotEmpty()) {
                        Text(
                            text = "Описание:",
                            style = MaterialTheme.typography.subtitle2,
                            color = MaterialTheme.colors.primary
                        )
                        Text(
                            text = remark.description,
                            style = MaterialTheme.typography.body1,
                            modifier = Modifier.padding(top = 4.dp)
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                    }

                    // Детали (используем функцию из ViewRemarkUtils)
                    ViewRemarkDetailItem("Категория", remark.category)
                    ViewRemarkDetailItem("Статус", remark.status)
                    ViewRemarkDetailItem("Дата создания", remark.createdDate)
                    ViewRemarkDetailItem("Срок устранения", remark.deadline)

                    if (remark.completedDate.isNotEmpty()) {
                        ViewRemarkDetailItem("Дата выполнения", remark.completedDate)
                    }
                }
            }

            // Секция с фото - ИСПОЛЬЗУЕМ ПОСТОЯННЫЕ ПУТИ
            if (photoPaths.isNotEmpty()) {
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    elevation = 4.dp
                ) {
                    Column(modifier = Modifier.padding(16.dp)) {
                        Text(
                            text = "Прикрепленные фото (${photoPaths.size})",
                            style = MaterialTheme.typography.h6
                        )

                        Spacer(modifier = Modifier.height(12.dp))

                        // Отображение фото в сетке 2 колонки
                        val columns = 2
                        Column {
                            for (i in photoPaths.indices step columns) {
                                Row(
                                    modifier = Modifier.fillMaxWidth(),
                                    horizontalArrangement = Arrangement.SpaceEvenly
                                ) {
                                    for (j in 0 until columns) {
                                        val index = i + j
                                        if (index < photoPaths.size) {
                                            // СОЗДАЕМ URI ИЗ ПОСТОЯННОГО ПУТИ
                                            val uri = PhotoStorageUtils.getUriForAppFile(context, photoPaths[index])
                                            Box(
                                                modifier = Modifier
                                                    .weight(1f)
                                                    .padding(8.dp)
                                                    .aspectRatio(1f)
                                            ) {
                                                AsyncImage(
                                                    model = uri,
                                                    contentDescription = "Фото замечания",
                                                    modifier = Modifier
                                                        .fillMaxSize()
                                                        .clip(MaterialTheme.shapes.medium),
                                                    contentScale = ContentScale.Crop
                                                )
                                            }
                                        } else {
                                            Spacer(modifier = Modifier.weight(1f))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\ui\ViewRemarkUtils.kt ---
------------------------------------------------------------

    package com.example.kipia.ui

    import androidx.compose.foundation.layout.*
    import androidx.compose.material.MaterialTheme
    import androidx.compose.material.Text
    import androidx.compose.runtime.Composable
    import androidx.compose.ui.Modifier
    import androidx.compose.ui.unit.dp

    @Composable
    fun ViewRemarkDetailItem(label: String, value: String) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 6.dp)
        ) {
            Text(
                text = "$label:",
                style = MaterialTheme.typography.subtitle2,
                modifier = Modifier.weight(1f)
            )
            Text(
                text = value,
                style = MaterialTheme.typography.body1,
                modifier = Modifier.weight(1f)
            )
        }
    }
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\utils\EquipmentPhotoUtils.kt ---
------------------------------------------------------------

package com.example.kipia.utils

import android.content.Context
import android.net.Uri
import kotlinx.serialization.encodeToString
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.json.Json

object EquipmentPhotoUtils {

    fun saveEquipmentPhotos(context: Context, uris: List<Uri>): List<String> {
        return uris.mapNotNull { uri ->
            PhotoStorageUtils.copyPhotoToAppStorage(context, uri)
        }
    }

    fun getPhotoPathsFromJson(json: String): List<String> {
        return if (json.isNotEmpty()) {
            try {
                // Простая реализация без сложной сериализации
                if (json.startsWith("[") && json.endsWith("]")) {
                    json.removeSurrounding("[", "]")
                        .split(",")
                        .map { it.trim().removeSurrounding("\"") }
                        .filter { it.isNotEmpty() }
                } else {
                    emptyList()
                }
            } catch (e: Exception) {
                emptyList()
            }
        } else {
            emptyList()
        }
    }

    fun convertPhotoPathsToJson(photoPaths: List<String>): String {
        return try {
            Json.encodeToString(photoPaths)
        } catch (e: Exception) {
            // Альтернативная реализация если сериализация не работает
            if (photoPaths.isEmpty()) {
                "[]"
            } else {
                "[" + photoPaths.joinToString(",") { "\"$it\"" } + "]"
            }
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\utils\NameUtils.kt ---
------------------------------------------------------------

package com.example.kipia.utils

object NameUtils {

    // Соответствие КП для СП и ХК
    private val kpMapping = mapOf(
        "867" to "1101",
        "878" to "1113",
        "890" to "1126",
        "911" to "1146",
        "912" to "1147",
        "924" to "1159",
        "937" to "1172",
        "950" to "1185"
        // 1194 остается без изменений
    )

    // Получить название ПКУ от КП
    fun getPKUNameFromKP(kpName: String): String {
        return "ПКУ $kpName"
    }

    // Получить варианты названий участков МН от КП
    fun getTubeNameOptionsFromKP(kpName: String): List<String> {
        val kpNumber = extractNumber(kpName)
        val options = mutableListOf<String>()

        // Вариант СП
        options.add("Участок МН $kpNumber км СП")

        // Вариант ХК (если есть соответствие)
        kpMapping[kpNumber]?.let { hkNumber ->
            options.add("Участок МН $hkNumber км ХК")
        }

        // Свой вариант
        options.add("Участок МН $kpNumber км")

        return options
    }

    // Получить префикс для колодцев от участка МН
    fun getNodePrefixFromTube(tubeName: String): Pair<String, String> {
        return when {
            tubeName.contains("ОД") || tubeName.contains("СП") -> "ОД" to "ОД"
            tubeName.contains("В") || tubeName.contains("ХК") -> "В" to "В"
            tubeName.contains("Задвижка") -> "Задвижка" to "Задвижка"
            else -> "Объект" to ""
        }
    }

    // Извлечь число из названия КП
    private fun extractNumber(kpName: String): String {
        val regex = """(\d+)""".toRegex()
        return regex.find(kpName)?.value ?: ""
    }

    // Получить номер для колодца из названия участка МН
    fun getNodeNumberFromTube(tubeName: String): String {
        val regex = """(\d+)""".toRegex()
        return regex.find(tubeName)?.value ?: ""
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\utils\PermissionUtils.kt ---
------------------------------------------------------------

package com.example.kipia.utils

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import androidx.core.content.ContextCompat

object PermissionUtils {

    val requiredPermissions = arrayOf(
        Manifest.permission.ACCESS_FINE_LOCATION,
        Manifest.permission.ACCESS_COARSE_LOCATION,
        Manifest.permission.BLUETOOTH,
        Manifest.permission.BLUETOOTH_ADMIN,
        Manifest.permission.BLUETOOTH_ADVERTISE,
        Manifest.permission.BLUETOOTH_CONNECT,
        Manifest.permission.BLUETOOTH_SCAN,
        Manifest.permission.ACCESS_WIFI_STATE,
        Manifest.permission.CHANGE_WIFI_STATE,
        Manifest.permission.NEARBY_WIFI_DEVICES
    )

    fun checkPermissions(context: Context): Boolean {
        return requiredPermissions.all { permission ->
            ContextCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED
        }
    }

    fun getMissingPermissions(context: Context): List<String> {
        return requiredPermissions.filter { permission ->
            ContextCompat.checkSelfPermission(context, permission) != PackageManager.PERMISSION_GRANTED
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\java\com\example\kipia\utils\PhotoStorageUtils.kt ---
------------------------------------------------------------

package com.example.kipia.utils

import android.content.Context
import android.net.Uri
import android.util.Log
import java.io.File
import java.io.FileOutputStream
import java.io.InputStream

object PhotoStorageUtils {

    /**
     * Копирует фото из временного URI в постоянное хранилище приложения
     */
    fun copyPhotoToAppStorage(context: Context, uri: Uri): String? {
        return try {
            val fileName = "KIPiA_${System.currentTimeMillis()}.jpg"
            val storageDir = File(context.filesDir, "remarks_photos")

            // Создаем директорию если не существует
            if (!storageDir.exists()) {
                storageDir.mkdirs()
            }

            val outputFile = File(storageDir, fileName)

            context.contentResolver.openInputStream(uri)?.use { inputStream ->
                outputFile.outputStream().use { outputStream ->
                    inputStream.copyTo(outputStream)
                }
            }

            // Возвращаем путь к файлу внутри приложения
            outputFile.absolutePath

        } catch (e: Exception) {
            Log.e("PhotoStorage", "Error copying photo", e)
            null
        }
    }

    /**
     * Получает URI для файла в хранилище приложения
     */
    fun getUriForAppFile(context: Context, filePath: String): Uri {
        return Uri.fromFile(File(filePath))
    }

    /**
     * Удаляет фото из хранилища приложения
     */
    fun deletePhotoFromStorage(context: Context, filePath: String) {
        try {
            val file = File(filePath)
            if (file.exists()) {
                file.delete()
            }
        } catch (e: Exception) {
            Log.e("PhotoStorage", "Error deleting photo", e)
        }
    }

    /**
     * Конвертирует список URI в список постоянных путей
     */
    fun convertUrisToPersistentPaths(context: Context, uris: List<Uri>): List<String> {
        Log.d("PhotoStorage", "Converting ${uris.size} URIs to persistent paths")
        return uris.mapNotNull { uri ->
            copyPhotoToAppStorage(context, uri)
        }
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\test\java\com\example\kipia\ExampleUnitTest.kt ---
------------------------------------------------------------

package com.example.kipia

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\res\layout\activity_splash.xml ---
------------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/black">

    <VideoView
        android:id="@+id/videoView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

</RelativeLayout>
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\res\layout\activity_splash11.xml ---
------------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".SplashActivity">

</androidx.constraintlayout.widget.ConstraintLayout>
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\res\values\strings.xml ---
------------------------------------------------------------

  String Name: app_name, Value: KIPiA

----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\res\values\colors.xml ---
------------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?>
    <resources>
        <color name="purple_200">#FFBB86FC</color>
        <color name="purple_500">#FF6200EE</color>
        <color name="purple_700">#FF3700B3</color>
        <color name="teal_200">#FF03DAC5</color>
        <color name="teal_700">#FF018786</color>
        <color name="black">#FF000000</color>
        <color name="white">#FFFFFFFF</color>
    </resources>
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\res\xml\backup_rules.xml ---
------------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older than API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\res\xml\data_extraction_rules.xml ---
------------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>
----------------------------------------

------------------------------------------------------------
--- Файл: E:\AndroidStudioProjects\KIPiA_1.0\app\src\main\res\xml\file_paths.xml ---
------------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path name="external_files" path="."/>
    <cache-path name="cache_files" path="."/>
</paths>
----------------------------------------
================================================================================
--- ПАРСИНГ ЗАВЕРШЕН ---
================================================================================
Результаты сохранены в: E:\AndroidStudioProjects\KIPiA_1.0\KIPiA_1.0_parsed_android_full_selected_output.txt
